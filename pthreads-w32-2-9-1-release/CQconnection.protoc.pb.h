// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CQconnection.protoc

#ifndef PROTOBUF_CQconnection_2eprotoc__INCLUDED
#define PROTOBUF_CQconnection_2eprotoc__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CQconnection_2eprotoc();
void protobuf_AssignDesc_CQconnection_2eprotoc();
void protobuf_ShutdownFile_CQconnection_2eprotoc();

class INF_OneEntrust_Req;
class INF_OneCancel_Req;
class INF_QueryOneEntrust_Req;
class INF_QueryCJMX_Req;
class INF_QueryPosition_Req;
class INF_QueryETFbaseInfo_Req;
class INF_QueryETFlistInfo_Req;
class INF_QueryETFdynamicInfo_Req;
class INF_QueryFundCondition_Req;
class INF_ETFPurRedem_Req;
class INF_QueryBatchEntrust_Req;
class INF_BatchEntrust_Req;
class INF_BatchCancel_Req;
class INF_QueryVaildRedemNum_Req;
class INF_OneEntrust_Ack;
class INF_BatchEntrust_Ack;
class INF_QueryOneEntrust_Ack;
class INF_QueryBatchEntrust_Ack;
class INF_OneCancel_Ack;
class INF_BatchCancel_Ack;
class INF_QueryETFbaseInfo_Ack;
class INF_QueryETFlistInfo_Ack;
class INF_QueryETFdynamicInfo_Ack;
class INF_QueryFundCondition_Ack;
class INF_QueryPosition_Ack;
class INF_QueryCJMX_Ack;
class INF_ETFPurRedem_Ack;
class StockLoginResp;
class ACCOUNT_INFO;
class STOCK_INFO;
class ETF_INFO;
class LOGIN_REQ;
class LOGIN_ACK;
class INF_Account;
class INF_ETF_Message;
class ETF_Message_req;
class ETF_Message_ack;
class StockServer;

// ===================================================================

class INF_OneEntrust_Req : public ::google::protobuf::Message {
 public:
  INF_OneEntrust_Req();
  virtual ~INF_OneEntrust_Req();
  
  INF_OneEntrust_Req(const INF_OneEntrust_Req& from);
  
  inline INF_OneEntrust_Req& operator=(const INF_OneEntrust_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_OneEntrust_Req& default_instance();
  
  void Swap(INF_OneEntrust_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_OneEntrust_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_OneEntrust_Req& from);
  void MergeFrom(const INF_OneEntrust_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string MarketID = 6;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 6;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string ETFserialNO = 8;
  inline bool has_etfserialno() const;
  inline void clear_etfserialno();
  static const int kETFserialNOFieldNumber = 8;
  inline const ::std::string& etfserialno() const;
  inline void set_etfserialno(const ::std::string& value);
  inline void set_etfserialno(const char* value);
  inline void set_etfserialno(const char* value, size_t size);
  inline ::std::string* mutable_etfserialno();
  inline ::std::string* release_etfserialno();
  
  // optional string SecurityCode = 9;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 9;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string BSflag = 10;
  inline bool has_bsflag() const;
  inline void clear_bsflag();
  static const int kBSflagFieldNumber = 10;
  inline const ::std::string& bsflag() const;
  inline void set_bsflag(const ::std::string& value);
  inline void set_bsflag(const char* value);
  inline void set_bsflag(const char* value, size_t size);
  inline ::std::string* mutable_bsflag();
  inline ::std::string* release_bsflag();
  
  // optional string EntrustNum = 11;
  inline bool has_entrustnum() const;
  inline void clear_entrustnum();
  static const int kEntrustNumFieldNumber = 11;
  inline const ::std::string& entrustnum() const;
  inline void set_entrustnum(const ::std::string& value);
  inline void set_entrustnum(const char* value);
  inline void set_entrustnum(const char* value, size_t size);
  inline ::std::string* mutable_entrustnum();
  inline ::std::string* release_entrustnum();
  
  // optional string EntrustPrice = 12;
  inline bool has_entrustprice() const;
  inline void clear_entrustprice();
  static const int kEntrustPriceFieldNumber = 12;
  inline const ::std::string& entrustprice() const;
  inline void set_entrustprice(const ::std::string& value);
  inline void set_entrustprice(const char* value);
  inline void set_entrustprice(const char* value, size_t size);
  inline ::std::string* mutable_entrustprice();
  inline ::std::string* release_entrustprice();
  
  // optional string EntrustType = 13;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 13;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // optional string BandCode = 14;
  inline bool has_bandcode() const;
  inline void clear_bandcode();
  static const int kBandCodeFieldNumber = 14;
  inline const ::std::string& bandcode() const;
  inline void set_bandcode(const ::std::string& value);
  inline void set_bandcode(const char* value);
  inline void set_bandcode(const char* value, size_t size);
  inline ::std::string* mutable_bandcode();
  inline ::std::string* release_bandcode();
  
  // optional string BandAccount = 15;
  inline bool has_bandaccount() const;
  inline void clear_bandaccount();
  static const int kBandAccountFieldNumber = 15;
  inline const ::std::string& bandaccount() const;
  inline void set_bandaccount(const ::std::string& value);
  inline void set_bandaccount(const char* value);
  inline void set_bandaccount(const char* value, size_t size);
  inline ::std::string* mutable_bandaccount();
  inline ::std::string* release_bandaccount();
  
  // optional string FinancingSecurityMode = 16;
  inline bool has_financingsecuritymode() const;
  inline void clear_financingsecuritymode();
  static const int kFinancingSecurityModeFieldNumber = 16;
  inline const ::std::string& financingsecuritymode() const;
  inline void set_financingsecuritymode(const ::std::string& value);
  inline void set_financingsecuritymode(const char* value);
  inline void set_financingsecuritymode(const char* value, size_t size);
  inline ::std::string* mutable_financingsecuritymode();
  inline ::std::string* release_financingsecuritymode();
  
  // optional string EntrustBatchNO = 17;
  inline bool has_entrustbatchno() const;
  inline void clear_entrustbatchno();
  static const int kEntrustBatchNOFieldNumber = 17;
  inline const ::std::string& entrustbatchno() const;
  inline void set_entrustbatchno(const ::std::string& value);
  inline void set_entrustbatchno(const char* value);
  inline void set_entrustbatchno(const char* value, size_t size);
  inline ::std::string* mutable_entrustbatchno();
  inline ::std::string* release_entrustbatchno();
  
  // optional string EntrustRiskAssessFlag = 18;
  inline bool has_entrustriskassessflag() const;
  inline void clear_entrustriskassessflag();
  static const int kEntrustRiskAssessFlagFieldNumber = 18;
  inline const ::std::string& entrustriskassessflag() const;
  inline void set_entrustriskassessflag(const ::std::string& value);
  inline void set_entrustriskassessflag(const char* value);
  inline void set_entrustriskassessflag(const char* value, size_t size);
  inline ::std::string* mutable_entrustriskassessflag();
  inline ::std::string* release_entrustriskassessflag();
  
  // optional string EntrustToBusiness = 19;
  inline bool has_entrusttobusiness() const;
  inline void clear_entrusttobusiness();
  static const int kEntrustToBusinessFieldNumber = 19;
  inline const ::std::string& entrusttobusiness() const;
  inline void set_entrusttobusiness(const ::std::string& value);
  inline void set_entrusttobusiness(const char* value);
  inline void set_entrusttobusiness(const char* value, size_t size);
  inline ::std::string* mutable_entrusttobusiness();
  inline ::std::string* release_entrusttobusiness();
  
  // optional string AgreementNO = 20;
  inline bool has_agreementno() const;
  inline void clear_agreementno();
  static const int kAgreementNOFieldNumber = 20;
  inline const ::std::string& agreementno() const;
  inline void set_agreementno(const ::std::string& value);
  inline void set_agreementno(const char* value);
  inline void set_agreementno(const char* value, size_t size);
  inline ::std::string* mutable_agreementno();
  inline ::std::string* release_agreementno();
  
  // optional string OppositeTradeUnit = 21;
  inline bool has_oppositetradeunit() const;
  inline void clear_oppositetradeunit();
  static const int kOppositeTradeUnitFieldNumber = 21;
  inline const ::std::string& oppositetradeunit() const;
  inline void set_oppositetradeunit(const ::std::string& value);
  inline void set_oppositetradeunit(const char* value);
  inline void set_oppositetradeunit(const char* value, size_t size);
  inline ::std::string* mutable_oppositetradeunit();
  inline ::std::string* release_oppositetradeunit();
  
  // optional string BargainNO = 22;
  inline bool has_bargainno() const;
  inline void clear_bargainno();
  static const int kBargainNOFieldNumber = 22;
  inline const ::std::string& bargainno() const;
  inline void set_bargainno(const ::std::string& value);
  inline void set_bargainno(const char* value);
  inline void set_bargainno(const char* value, size_t size);
  inline ::std::string* mutable_bargainno();
  inline ::std::string* release_bargainno();
  
  // optional string BsettleVipNO = 23;
  inline bool has_bsettlevipno() const;
  inline void clear_bsettlevipno();
  static const int kBsettleVipNOFieldNumber = 23;
  inline const ::std::string& bsettlevipno() const;
  inline void set_bsettlevipno(const ::std::string& value);
  inline void set_bsettlevipno(const char* value);
  inline void set_bsettlevipno(const char* value, size_t size);
  inline ::std::string* mutable_bsettlevipno();
  inline ::std::string* release_bsettlevipno();
  
  // optional string IsLowPriceEntrust = 24;
  inline bool has_islowpriceentrust() const;
  inline void clear_islowpriceentrust();
  static const int kIsLowPriceEntrustFieldNumber = 24;
  inline const ::std::string& islowpriceentrust() const;
  inline void set_islowpriceentrust(const ::std::string& value);
  inline void set_islowpriceentrust(const char* value);
  inline void set_islowpriceentrust(const char* value, size_t size);
  inline ::std::string* mutable_islowpriceentrust();
  inline ::std::string* release_islowpriceentrust();
  
  // @@protoc_insertion_point(class_scope:INF_OneEntrust_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_etfserialno();
  inline void clear_has_etfserialno();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_bsflag();
  inline void clear_has_bsflag();
  inline void set_has_entrustnum();
  inline void clear_has_entrustnum();
  inline void set_has_entrustprice();
  inline void clear_has_entrustprice();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  inline void set_has_bandcode();
  inline void clear_has_bandcode();
  inline void set_has_bandaccount();
  inline void clear_has_bandaccount();
  inline void set_has_financingsecuritymode();
  inline void clear_has_financingsecuritymode();
  inline void set_has_entrustbatchno();
  inline void clear_has_entrustbatchno();
  inline void set_has_entrustriskassessflag();
  inline void clear_has_entrustriskassessflag();
  inline void set_has_entrusttobusiness();
  inline void clear_has_entrusttobusiness();
  inline void set_has_agreementno();
  inline void clear_has_agreementno();
  inline void set_has_oppositetradeunit();
  inline void clear_has_oppositetradeunit();
  inline void set_has_bargainno();
  inline void clear_has_bargainno();
  inline void set_has_bsettlevipno();
  inline void clear_has_bsettlevipno();
  inline void set_has_islowpriceentrust();
  inline void clear_has_islowpriceentrust();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* marketid_;
  ::std::string* rt6_;
  ::std::string* etfserialno_;
  ::std::string* securitycode_;
  ::std::string* bsflag_;
  ::std::string* entrustnum_;
  ::std::string* entrustprice_;
  ::std::string* entrusttype_;
  ::std::string* bandcode_;
  ::std::string* bandaccount_;
  ::std::string* financingsecuritymode_;
  ::std::string* entrustbatchno_;
  ::std::string* entrustriskassessflag_;
  ::std::string* entrusttobusiness_;
  ::std::string* agreementno_;
  ::std::string* oppositetradeunit_;
  ::std::string* bargainno_;
  ::std::string* bsettlevipno_;
  ::std::string* islowpriceentrust_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_OneEntrust_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_OneCancel_Req : public ::google::protobuf::Message {
 public:
  INF_OneCancel_Req();
  virtual ~INF_OneCancel_Req();
  
  INF_OneCancel_Req(const INF_OneCancel_Req& from);
  
  inline INF_OneCancel_Req& operator=(const INF_OneCancel_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_OneCancel_Req& default_instance();
  
  void Swap(INF_OneCancel_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_OneCancel_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_OneCancel_Req& from);
  void MergeFrom(const INF_OneCancel_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string MarketID = 6;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 6;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string EntrustSerial = 9;
  inline bool has_entrustserial() const;
  inline void clear_entrustserial();
  static const int kEntrustSerialFieldNumber = 9;
  inline const ::std::string& entrustserial() const;
  inline void set_entrustserial(const ::std::string& value);
  inline void set_entrustserial(const char* value);
  inline void set_entrustserial(const char* value, size_t size);
  inline ::std::string* mutable_entrustserial();
  inline ::std::string* release_entrustserial();
  
  // optional string EntrustType = 10;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 10;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // @@protoc_insertion_point(class_scope:INF_OneCancel_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_entrustserial();
  inline void clear_has_entrustserial();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* marketid_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* entrustserial_;
  ::std::string* entrusttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_OneCancel_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryOneEntrust_Req : public ::google::protobuf::Message {
 public:
  INF_QueryOneEntrust_Req();
  virtual ~INF_QueryOneEntrust_Req();
  
  INF_QueryOneEntrust_Req(const INF_QueryOneEntrust_Req& from);
  
  inline INF_QueryOneEntrust_Req& operator=(const INF_QueryOneEntrust_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryOneEntrust_Req& default_instance();
  
  void Swap(INF_QueryOneEntrust_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryOneEntrust_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryOneEntrust_Req& from);
  void MergeFrom(const INF_QueryOneEntrust_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string RT5 = 6;
  inline bool has_rt5() const;
  inline void clear_rt5();
  static const int kRT5FieldNumber = 6;
  inline const ::std::string& rt5() const;
  inline void set_rt5(const ::std::string& value);
  inline void set_rt5(const char* value);
  inline void set_rt5(const char* value, size_t size);
  inline ::std::string* mutable_rt5();
  inline ::std::string* release_rt5();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string RT8 = 9;
  inline bool has_rt8() const;
  inline void clear_rt8();
  static const int kRT8FieldNumber = 9;
  inline const ::std::string& rt8() const;
  inline void set_rt8(const ::std::string& value);
  inline void set_rt8(const char* value);
  inline void set_rt8(const char* value, size_t size);
  inline ::std::string* mutable_rt8();
  inline ::std::string* release_rt8();
  
  // optional string RT9 = 10;
  inline bool has_rt9() const;
  inline void clear_rt9();
  static const int kRT9FieldNumber = 10;
  inline const ::std::string& rt9() const;
  inline void set_rt9(const ::std::string& value);
  inline void set_rt9(const char* value);
  inline void set_rt9(const char* value, size_t size);
  inline ::std::string* mutable_rt9();
  inline ::std::string* release_rt9();
  
  // optional string EntrustSerial = 11;
  inline bool has_entrustserial() const;
  inline void clear_entrustserial();
  static const int kEntrustSerialFieldNumber = 11;
  inline const ::std::string& entrustserial() const;
  inline void set_entrustserial(const ::std::string& value);
  inline void set_entrustserial(const char* value);
  inline void set_entrustserial(const char* value, size_t size);
  inline ::std::string* mutable_entrustserial();
  inline ::std::string* release_entrustserial();
  
  // optional string RT11 = 12;
  inline bool has_rt11() const;
  inline void clear_rt11();
  static const int kRT11FieldNumber = 12;
  inline const ::std::string& rt11() const;
  inline void set_rt11(const ::std::string& value);
  inline void set_rt11(const char* value);
  inline void set_rt11(const char* value, size_t size);
  inline ::std::string* mutable_rt11();
  inline ::std::string* release_rt11();
  
  // optional string RT12 = 13;
  inline bool has_rt12() const;
  inline void clear_rt12();
  static const int kRT12FieldNumber = 13;
  inline const ::std::string& rt12() const;
  inline void set_rt12(const ::std::string& value);
  inline void set_rt12(const char* value);
  inline void set_rt12(const char* value, size_t size);
  inline ::std::string* mutable_rt12();
  inline ::std::string* release_rt12();
  
  // optional string RT13 = 14;
  inline bool has_rt13() const;
  inline void clear_rt13();
  static const int kRT13FieldNumber = 14;
  inline const ::std::string& rt13() const;
  inline void set_rt13(const ::std::string& value);
  inline void set_rt13(const char* value);
  inline void set_rt13(const char* value, size_t size);
  inline ::std::string* mutable_rt13();
  inline ::std::string* release_rt13();
  
  // optional string RT14 = 15;
  inline bool has_rt14() const;
  inline void clear_rt14();
  static const int kRT14FieldNumber = 15;
  inline const ::std::string& rt14() const;
  inline void set_rt14(const ::std::string& value);
  inline void set_rt14(const char* value);
  inline void set_rt14(const char* value, size_t size);
  inline ::std::string* mutable_rt14();
  inline ::std::string* release_rt14();
  
  // optional string EntrustType = 16;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 16;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // optional string RT16 = 17;
  inline bool has_rt16() const;
  inline void clear_rt16();
  static const int kRT16FieldNumber = 17;
  inline const ::std::string& rt16() const;
  inline void set_rt16(const ::std::string& value);
  inline void set_rt16(const char* value);
  inline void set_rt16(const char* value, size_t size);
  inline ::std::string* mutable_rt16();
  inline ::std::string* release_rt16();
  
  // optional string RT17 = 18;
  inline bool has_rt17() const;
  inline void clear_rt17();
  static const int kRT17FieldNumber = 18;
  inline const ::std::string& rt17() const;
  inline void set_rt17(const ::std::string& value);
  inline void set_rt17(const char* value);
  inline void set_rt17(const char* value, size_t size);
  inline ::std::string* mutable_rt17();
  inline ::std::string* release_rt17();
  
  // optional string RT18 = 19;
  inline bool has_rt18() const;
  inline void clear_rt18();
  static const int kRT18FieldNumber = 19;
  inline const ::std::string& rt18() const;
  inline void set_rt18(const ::std::string& value);
  inline void set_rt18(const char* value);
  inline void set_rt18(const char* value, size_t size);
  inline ::std::string* mutable_rt18();
  inline ::std::string* release_rt18();
  
  // optional string RT19 = 20;
  inline bool has_rt19() const;
  inline void clear_rt19();
  static const int kRT19FieldNumber = 20;
  inline const ::std::string& rt19() const;
  inline void set_rt19(const ::std::string& value);
  inline void set_rt19(const char* value);
  inline void set_rt19(const char* value, size_t size);
  inline ::std::string* mutable_rt19();
  inline ::std::string* release_rt19();
  
  // optional string RT20 = 21;
  inline bool has_rt20() const;
  inline void clear_rt20();
  static const int kRT20FieldNumber = 21;
  inline const ::std::string& rt20() const;
  inline void set_rt20(const ::std::string& value);
  inline void set_rt20(const char* value);
  inline void set_rt20(const char* value, size_t size);
  inline ::std::string* mutable_rt20();
  inline ::std::string* release_rt20();
  
  // optional string RT21 = 22;
  inline bool has_rt21() const;
  inline void clear_rt21();
  static const int kRT21FieldNumber = 22;
  inline const ::std::string& rt21() const;
  inline void set_rt21(const ::std::string& value);
  inline void set_rt21(const char* value);
  inline void set_rt21(const char* value, size_t size);
  inline ::std::string* mutable_rt21();
  inline ::std::string* release_rt21();
  
  // optional string IsCancel = 23;
  inline bool has_iscancel() const;
  inline void clear_iscancel();
  static const int kIsCancelFieldNumber = 23;
  inline const ::std::string& iscancel() const;
  inline void set_iscancel(const ::std::string& value);
  inline void set_iscancel(const char* value);
  inline void set_iscancel(const char* value, size_t size);
  inline ::std::string* mutable_iscancel();
  inline ::std::string* release_iscancel();
  
  // @@protoc_insertion_point(class_scope:INF_QueryOneEntrust_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_rt5();
  inline void clear_has_rt5();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_rt8();
  inline void clear_has_rt8();
  inline void set_has_rt9();
  inline void clear_has_rt9();
  inline void set_has_entrustserial();
  inline void clear_has_entrustserial();
  inline void set_has_rt11();
  inline void clear_has_rt11();
  inline void set_has_rt12();
  inline void clear_has_rt12();
  inline void set_has_rt13();
  inline void clear_has_rt13();
  inline void set_has_rt14();
  inline void clear_has_rt14();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  inline void set_has_rt16();
  inline void clear_has_rt16();
  inline void set_has_rt17();
  inline void clear_has_rt17();
  inline void set_has_rt18();
  inline void clear_has_rt18();
  inline void set_has_rt19();
  inline void clear_has_rt19();
  inline void set_has_rt20();
  inline void clear_has_rt20();
  inline void set_has_rt21();
  inline void clear_has_rt21();
  inline void set_has_iscancel();
  inline void clear_has_iscancel();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* rt5_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* rt8_;
  ::std::string* rt9_;
  ::std::string* entrustserial_;
  ::std::string* rt11_;
  ::std::string* rt12_;
  ::std::string* rt13_;
  ::std::string* rt14_;
  ::std::string* entrusttype_;
  ::std::string* rt16_;
  ::std::string* rt17_;
  ::std::string* rt18_;
  ::std::string* rt19_;
  ::std::string* rt20_;
  ::std::string* rt21_;
  ::std::string* iscancel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryOneEntrust_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryCJMX_Req : public ::google::protobuf::Message {
 public:
  INF_QueryCJMX_Req();
  virtual ~INF_QueryCJMX_Req();
  
  INF_QueryCJMX_Req(const INF_QueryCJMX_Req& from);
  
  inline INF_QueryCJMX_Req& operator=(const INF_QueryCJMX_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryCJMX_Req& default_instance();
  
  void Swap(INF_QueryCJMX_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryCJMX_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryCJMX_Req& from);
  void MergeFrom(const INF_QueryCJMX_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string RT5 = 6;
  inline bool has_rt5() const;
  inline void clear_rt5();
  static const int kRT5FieldNumber = 6;
  inline const ::std::string& rt5() const;
  inline void set_rt5(const ::std::string& value);
  inline void set_rt5(const char* value);
  inline void set_rt5(const char* value, size_t size);
  inline ::std::string* mutable_rt5();
  inline ::std::string* release_rt5();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string RT8 = 9;
  inline bool has_rt8() const;
  inline void clear_rt8();
  static const int kRT8FieldNumber = 9;
  inline const ::std::string& rt8() const;
  inline void set_rt8(const ::std::string& value);
  inline void set_rt8(const char* value);
  inline void set_rt8(const char* value, size_t size);
  inline ::std::string* mutable_rt8();
  inline ::std::string* release_rt8();
  
  // optional string RT9 = 10;
  inline bool has_rt9() const;
  inline void clear_rt9();
  static const int kRT9FieldNumber = 10;
  inline const ::std::string& rt9() const;
  inline void set_rt9(const ::std::string& value);
  inline void set_rt9(const char* value);
  inline void set_rt9(const char* value, size_t size);
  inline ::std::string* mutable_rt9();
  inline ::std::string* release_rt9();
  
  // optional string DIRECTION = 11;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDIRECTIONFieldNumber = 11;
  inline const ::std::string& direction() const;
  inline void set_direction(const ::std::string& value);
  inline void set_direction(const char* value);
  inline void set_direction(const char* value, size_t size);
  inline ::std::string* mutable_direction();
  inline ::std::string* release_direction();
  
  // optional string CJMXmax = 12;
  inline bool has_cjmxmax() const;
  inline void clear_cjmxmax();
  static const int kCJMXmaxFieldNumber = 12;
  inline const ::std::string& cjmxmax() const;
  inline void set_cjmxmax(const ::std::string& value);
  inline void set_cjmxmax(const char* value);
  inline void set_cjmxmax(const char* value, size_t size);
  inline ::std::string* mutable_cjmxmax();
  inline ::std::string* release_cjmxmax();
  
  // optional string CJMXmode = 13;
  inline bool has_cjmxmode() const;
  inline void clear_cjmxmode();
  static const int kCJMXmodeFieldNumber = 13;
  inline const ::std::string& cjmxmode() const;
  inline void set_cjmxmode(const ::std::string& value);
  inline void set_cjmxmode(const char* value);
  inline void set_cjmxmode(const char* value, size_t size);
  inline ::std::string* mutable_cjmxmode();
  inline ::std::string* release_cjmxmode();
  
  // optional string QueryStartPos = 14;
  inline bool has_querystartpos() const;
  inline void clear_querystartpos();
  static const int kQueryStartPosFieldNumber = 14;
  inline const ::std::string& querystartpos() const;
  inline void set_querystartpos(const ::std::string& value);
  inline void set_querystartpos(const char* value);
  inline void set_querystartpos(const char* value, size_t size);
  inline ::std::string* mutable_querystartpos();
  inline ::std::string* release_querystartpos();
  
  // optional string EntrustType = 15;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 15;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // optional string QueryType = 16;
  inline bool has_querytype() const;
  inline void clear_querytype();
  static const int kQueryTypeFieldNumber = 16;
  inline const ::std::string& querytype() const;
  inline void set_querytype(const ::std::string& value);
  inline void set_querytype(const char* value);
  inline void set_querytype(const char* value, size_t size);
  inline ::std::string* mutable_querytype();
  inline ::std::string* release_querytype();
  
  // @@protoc_insertion_point(class_scope:INF_QueryCJMX_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_rt5();
  inline void clear_has_rt5();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_rt8();
  inline void clear_has_rt8();
  inline void set_has_rt9();
  inline void clear_has_rt9();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_cjmxmax();
  inline void clear_has_cjmxmax();
  inline void set_has_cjmxmode();
  inline void clear_has_cjmxmode();
  inline void set_has_querystartpos();
  inline void clear_has_querystartpos();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  inline void set_has_querytype();
  inline void clear_has_querytype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* rt5_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* rt8_;
  ::std::string* rt9_;
  ::std::string* direction_;
  ::std::string* cjmxmax_;
  ::std::string* cjmxmode_;
  ::std::string* querystartpos_;
  ::std::string* entrusttype_;
  ::std::string* querytype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryCJMX_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryPosition_Req : public ::google::protobuf::Message {
 public:
  INF_QueryPosition_Req();
  virtual ~INF_QueryPosition_Req();
  
  INF_QueryPosition_Req(const INF_QueryPosition_Req& from);
  
  inline INF_QueryPosition_Req& operator=(const INF_QueryPosition_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryPosition_Req& default_instance();
  
  void Swap(INF_QueryPosition_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryPosition_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryPosition_Req& from);
  void MergeFrom(const INF_QueryPosition_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string RT5 = 6;
  inline bool has_rt5() const;
  inline void clear_rt5();
  static const int kRT5FieldNumber = 6;
  inline const ::std::string& rt5() const;
  inline void set_rt5(const ::std::string& value);
  inline void set_rt5(const char* value);
  inline void set_rt5(const char* value, size_t size);
  inline ::std::string* mutable_rt5();
  inline ::std::string* release_rt5();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string RT8 = 9;
  inline bool has_rt8() const;
  inline void clear_rt8();
  static const int kRT8FieldNumber = 9;
  inline const ::std::string& rt8() const;
  inline void set_rt8(const ::std::string& value);
  inline void set_rt8(const char* value);
  inline void set_rt8(const char* value, size_t size);
  inline ::std::string* mutable_rt8();
  inline ::std::string* release_rt8();
  
  // optional string SecurityCode = 10;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 10;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string RT10 = 11;
  inline bool has_rt10() const;
  inline void clear_rt10();
  static const int kRT10FieldNumber = 11;
  inline const ::std::string& rt10() const;
  inline void set_rt10(const ::std::string& value);
  inline void set_rt10(const char* value);
  inline void set_rt10(const char* value, size_t size);
  inline ::std::string* mutable_rt10();
  inline ::std::string* release_rt10();
  
  // optional string RT11 = 12;
  inline bool has_rt11() const;
  inline void clear_rt11();
  static const int kRT11FieldNumber = 12;
  inline const ::std::string& rt11() const;
  inline void set_rt11(const ::std::string& value);
  inline void set_rt11(const char* value);
  inline void set_rt11(const char* value, size_t size);
  inline ::std::string* mutable_rt11();
  inline ::std::string* release_rt11();
  
  // optional string RT12 = 13;
  inline bool has_rt12() const;
  inline void clear_rt12();
  static const int kRT12FieldNumber = 13;
  inline const ::std::string& rt12() const;
  inline void set_rt12(const ::std::string& value);
  inline void set_rt12(const char* value);
  inline void set_rt12(const char* value, size_t size);
  inline ::std::string* mutable_rt12();
  inline ::std::string* release_rt12();
  
  // optional string RT13 = 14;
  inline bool has_rt13() const;
  inline void clear_rt13();
  static const int kRT13FieldNumber = 14;
  inline const ::std::string& rt13() const;
  inline void set_rt13(const ::std::string& value);
  inline void set_rt13(const char* value);
  inline void set_rt13(const char* value, size_t size);
  inline ::std::string* mutable_rt13();
  inline ::std::string* release_rt13();
  
  // optional string RT14 = 15;
  inline bool has_rt14() const;
  inline void clear_rt14();
  static const int kRT14FieldNumber = 15;
  inline const ::std::string& rt14() const;
  inline void set_rt14(const ::std::string& value);
  inline void set_rt14(const char* value);
  inline void set_rt14(const char* value, size_t size);
  inline ::std::string* mutable_rt14();
  inline ::std::string* release_rt14();
  
  // optional string OperateFunc = 16;
  inline bool has_operatefunc() const;
  inline void clear_operatefunc();
  static const int kOperateFuncFieldNumber = 16;
  inline const ::std::string& operatefunc() const;
  inline void set_operatefunc(const ::std::string& value);
  inline void set_operatefunc(const char* value);
  inline void set_operatefunc(const char* value, size_t size);
  inline ::std::string* mutable_operatefunc();
  inline ::std::string* release_operatefunc();
  
  // optional string EntrustType = 17;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 17;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // optional string RT17 = 18;
  inline bool has_rt17() const;
  inline void clear_rt17();
  static const int kRT17FieldNumber = 18;
  inline const ::std::string& rt17() const;
  inline void set_rt17(const ::std::string& value);
  inline void set_rt17(const char* value);
  inline void set_rt17(const char* value, size_t size);
  inline ::std::string* mutable_rt17();
  inline ::std::string* release_rt17();
  
  // optional string RT18 = 19;
  inline bool has_rt18() const;
  inline void clear_rt18();
  static const int kRT18FieldNumber = 19;
  inline const ::std::string& rt18() const;
  inline void set_rt18(const ::std::string& value);
  inline void set_rt18(const char* value);
  inline void set_rt18(const char* value, size_t size);
  inline ::std::string* mutable_rt18();
  inline ::std::string* release_rt18();
  
  // optional string RT19 = 20;
  inline bool has_rt19() const;
  inline void clear_rt19();
  static const int kRT19FieldNumber = 20;
  inline const ::std::string& rt19() const;
  inline void set_rt19(const ::std::string& value);
  inline void set_rt19(const char* value);
  inline void set_rt19(const char* value, size_t size);
  inline ::std::string* mutable_rt19();
  inline ::std::string* release_rt19();
  
  // @@protoc_insertion_point(class_scope:INF_QueryPosition_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_rt5();
  inline void clear_has_rt5();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_rt8();
  inline void clear_has_rt8();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_rt10();
  inline void clear_has_rt10();
  inline void set_has_rt11();
  inline void clear_has_rt11();
  inline void set_has_rt12();
  inline void clear_has_rt12();
  inline void set_has_rt13();
  inline void clear_has_rt13();
  inline void set_has_rt14();
  inline void clear_has_rt14();
  inline void set_has_operatefunc();
  inline void clear_has_operatefunc();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  inline void set_has_rt17();
  inline void clear_has_rt17();
  inline void set_has_rt18();
  inline void clear_has_rt18();
  inline void set_has_rt19();
  inline void clear_has_rt19();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* rt5_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* rt8_;
  ::std::string* securitycode_;
  ::std::string* rt10_;
  ::std::string* rt11_;
  ::std::string* rt12_;
  ::std::string* rt13_;
  ::std::string* rt14_;
  ::std::string* operatefunc_;
  ::std::string* entrusttype_;
  ::std::string* rt17_;
  ::std::string* rt18_;
  ::std::string* rt19_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryPosition_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryETFbaseInfo_Req : public ::google::protobuf::Message {
 public:
  INF_QueryETFbaseInfo_Req();
  virtual ~INF_QueryETFbaseInfo_Req();
  
  INF_QueryETFbaseInfo_Req(const INF_QueryETFbaseInfo_Req& from);
  
  inline INF_QueryETFbaseInfo_Req& operator=(const INF_QueryETFbaseInfo_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryETFbaseInfo_Req& default_instance();
  
  void Swap(INF_QueryETFbaseInfo_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryETFbaseInfo_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryETFbaseInfo_Req& from);
  void MergeFrom(const INF_QueryETFbaseInfo_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string MarketID = 6;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 6;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string SecurityCode = 9;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 9;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string EntrustType = 10;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 10;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // @@protoc_insertion_point(class_scope:INF_QueryETFbaseInfo_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* marketid_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* securitycode_;
  ::std::string* entrusttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryETFbaseInfo_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryETFlistInfo_Req : public ::google::protobuf::Message {
 public:
  INF_QueryETFlistInfo_Req();
  virtual ~INF_QueryETFlistInfo_Req();
  
  INF_QueryETFlistInfo_Req(const INF_QueryETFlistInfo_Req& from);
  
  inline INF_QueryETFlistInfo_Req& operator=(const INF_QueryETFlistInfo_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryETFlistInfo_Req& default_instance();
  
  void Swap(INF_QueryETFlistInfo_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryETFlistInfo_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryETFlistInfo_Req& from);
  void MergeFrom(const INF_QueryETFlistInfo_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string MarketID = 6;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 6;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string SecurityCode = 9;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 9;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string SortType = 10;
  inline bool has_sorttype() const;
  inline void clear_sorttype();
  static const int kSortTypeFieldNumber = 10;
  inline const ::std::string& sorttype() const;
  inline void set_sorttype(const ::std::string& value);
  inline void set_sorttype(const char* value);
  inline void set_sorttype(const char* value, size_t size);
  inline ::std::string* mutable_sorttype();
  inline ::std::string* release_sorttype();
  
  // optional string EntrustType = 11;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 11;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // @@protoc_insertion_point(class_scope:INF_QueryETFlistInfo_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_sorttype();
  inline void clear_has_sorttype();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* marketid_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* securitycode_;
  ::std::string* sorttype_;
  ::std::string* entrusttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryETFlistInfo_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryETFdynamicInfo_Req : public ::google::protobuf::Message {
 public:
  INF_QueryETFdynamicInfo_Req();
  virtual ~INF_QueryETFdynamicInfo_Req();
  
  INF_QueryETFdynamicInfo_Req(const INF_QueryETFdynamicInfo_Req& from);
  
  inline INF_QueryETFdynamicInfo_Req& operator=(const INF_QueryETFdynamicInfo_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryETFdynamicInfo_Req& default_instance();
  
  void Swap(INF_QueryETFdynamicInfo_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryETFdynamicInfo_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryETFdynamicInfo_Req& from);
  void MergeFrom(const INF_QueryETFdynamicInfo_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string MarketID = 6;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 6;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string EntrustBatchNO = 9;
  inline bool has_entrustbatchno() const;
  inline void clear_entrustbatchno();
  static const int kEntrustBatchNOFieldNumber = 9;
  inline const ::std::string& entrustbatchno() const;
  inline void set_entrustbatchno(const ::std::string& value);
  inline void set_entrustbatchno(const char* value);
  inline void set_entrustbatchno(const char* value, size_t size);
  inline ::std::string* mutable_entrustbatchno();
  inline ::std::string* release_entrustbatchno();
  
  // optional string SecurityCode = 10;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 10;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string ETFminPurRedemUint = 11;
  inline bool has_etfminpurredemuint() const;
  inline void clear_etfminpurredemuint();
  static const int kETFminPurRedemUintFieldNumber = 11;
  inline const ::std::string& etfminpurredemuint() const;
  inline void set_etfminpurredemuint(const ::std::string& value);
  inline void set_etfminpurredemuint(const char* value);
  inline void set_etfminpurredemuint(const char* value, size_t size);
  inline ::std::string* mutable_etfminpurredemuint();
  inline ::std::string* release_etfminpurredemuint();
  
  // optional string EntrustType = 12;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 12;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // @@protoc_insertion_point(class_scope:INF_QueryETFdynamicInfo_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_entrustbatchno();
  inline void clear_has_entrustbatchno();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_etfminpurredemuint();
  inline void clear_has_etfminpurredemuint();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* marketid_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* entrustbatchno_;
  ::std::string* securitycode_;
  ::std::string* etfminpurredemuint_;
  ::std::string* entrusttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryETFdynamicInfo_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryFundCondition_Req : public ::google::protobuf::Message {
 public:
  INF_QueryFundCondition_Req();
  virtual ~INF_QueryFundCondition_Req();
  
  INF_QueryFundCondition_Req(const INF_QueryFundCondition_Req& from);
  
  inline INF_QueryFundCondition_Req& operator=(const INF_QueryFundCondition_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryFundCondition_Req& default_instance();
  
  void Swap(INF_QueryFundCondition_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryFundCondition_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryFundCondition_Req& from);
  void MergeFrom(const INF_QueryFundCondition_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string MoneyType = 6;
  inline bool has_moneytype() const;
  inline void clear_moneytype();
  static const int kMoneyTypeFieldNumber = 6;
  inline const ::std::string& moneytype() const;
  inline void set_moneytype(const ::std::string& value);
  inline void set_moneytype(const char* value);
  inline void set_moneytype(const char* value, size_t size);
  inline ::std::string* mutable_moneytype();
  inline ::std::string* release_moneytype();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string EntrustType = 9;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 9;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // optional string PropertyDebt = 10;
  inline bool has_propertydebt() const;
  inline void clear_propertydebt();
  static const int kPropertyDebtFieldNumber = 10;
  inline const ::std::string& propertydebt() const;
  inline void set_propertydebt(const ::std::string& value);
  inline void set_propertydebt(const char* value);
  inline void set_propertydebt(const char* value, size_t size);
  inline ::std::string* mutable_propertydebt();
  inline ::std::string* release_propertydebt();
  
  // @@protoc_insertion_point(class_scope:INF_QueryFundCondition_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_moneytype();
  inline void clear_has_moneytype();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  inline void set_has_propertydebt();
  inline void clear_has_propertydebt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* moneytype_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* entrusttype_;
  ::std::string* propertydebt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryFundCondition_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_ETFPurRedem_Req : public ::google::protobuf::Message {
 public:
  INF_ETFPurRedem_Req();
  virtual ~INF_ETFPurRedem_Req();
  
  INF_ETFPurRedem_Req(const INF_ETFPurRedem_Req& from);
  
  inline INF_ETFPurRedem_Req& operator=(const INF_ETFPurRedem_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_ETFPurRedem_Req& default_instance();
  
  void Swap(INF_ETFPurRedem_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_ETFPurRedem_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_ETFPurRedem_Req& from);
  void MergeFrom(const INF_ETFPurRedem_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string MoneyID = 6;
  inline bool has_moneyid() const;
  inline void clear_moneyid();
  static const int kMoneyIDFieldNumber = 6;
  inline const ::std::string& moneyid() const;
  inline void set_moneyid(const ::std::string& value);
  inline void set_moneyid(const char* value);
  inline void set_moneyid(const char* value, size_t size);
  inline ::std::string* mutable_moneyid();
  inline ::std::string* release_moneyid();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string EntrustBatchNO = 9;
  inline bool has_entrustbatchno() const;
  inline void clear_entrustbatchno();
  static const int kEntrustBatchNOFieldNumber = 9;
  inline const ::std::string& entrustbatchno() const;
  inline void set_entrustbatchno(const ::std::string& value);
  inline void set_entrustbatchno(const char* value);
  inline void set_entrustbatchno(const char* value, size_t size);
  inline ::std::string* mutable_entrustbatchno();
  inline ::std::string* release_entrustbatchno();
  
  // optional string OperateFunc = 10;
  inline bool has_operatefunc() const;
  inline void clear_operatefunc();
  static const int kOperateFuncFieldNumber = 10;
  inline const ::std::string& operatefunc() const;
  inline void set_operatefunc(const ::std::string& value);
  inline void set_operatefunc(const char* value);
  inline void set_operatefunc(const char* value, size_t size);
  inline ::std::string* mutable_operatefunc();
  inline ::std::string* release_operatefunc();
  
  // optional string SecurityCode = 11;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 11;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string EntrustNum = 12;
  inline bool has_entrustnum() const;
  inline void clear_entrustnum();
  static const int kEntrustNumFieldNumber = 12;
  inline const ::std::string& entrustnum() const;
  inline void set_entrustnum(const ::std::string& value);
  inline void set_entrustnum(const char* value);
  inline void set_entrustnum(const char* value, size_t size);
  inline ::std::string* mutable_entrustnum();
  inline ::std::string* release_entrustnum();
  
  // optional string EntrustType = 13;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 13;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // @@protoc_insertion_point(class_scope:INF_ETFPurRedem_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_moneyid();
  inline void clear_has_moneyid();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_entrustbatchno();
  inline void clear_has_entrustbatchno();
  inline void set_has_operatefunc();
  inline void clear_has_operatefunc();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_entrustnum();
  inline void clear_has_entrustnum();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* moneyid_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* entrustbatchno_;
  ::std::string* operatefunc_;
  ::std::string* securitycode_;
  ::std::string* entrustnum_;
  ::std::string* entrusttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_ETFPurRedem_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryBatchEntrust_Req : public ::google::protobuf::Message {
 public:
  INF_QueryBatchEntrust_Req();
  virtual ~INF_QueryBatchEntrust_Req();
  
  INF_QueryBatchEntrust_Req(const INF_QueryBatchEntrust_Req& from);
  
  inline INF_QueryBatchEntrust_Req& operator=(const INF_QueryBatchEntrust_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryBatchEntrust_Req& default_instance();
  
  void Swap(INF_QueryBatchEntrust_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryBatchEntrust_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryBatchEntrust_Req& from);
  void MergeFrom(const INF_QueryBatchEntrust_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string RT5 = 6;
  inline bool has_rt5() const;
  inline void clear_rt5();
  static const int kRT5FieldNumber = 6;
  inline const ::std::string& rt5() const;
  inline void set_rt5(const ::std::string& value);
  inline void set_rt5(const char* value);
  inline void set_rt5(const char* value, size_t size);
  inline ::std::string* mutable_rt5();
  inline ::std::string* release_rt5();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string RT8 = 9;
  inline bool has_rt8() const;
  inline void clear_rt8();
  static const int kRT8FieldNumber = 9;
  inline const ::std::string& rt8() const;
  inline void set_rt8(const ::std::string& value);
  inline void set_rt8(const char* value);
  inline void set_rt8(const char* value, size_t size);
  inline ::std::string* mutable_rt8();
  inline ::std::string* release_rt8();
  
  // optional string RT9 = 10;
  inline bool has_rt9() const;
  inline void clear_rt9();
  static const int kRT9FieldNumber = 10;
  inline const ::std::string& rt9() const;
  inline void set_rt9(const ::std::string& value);
  inline void set_rt9(const char* value);
  inline void set_rt9(const char* value, size_t size);
  inline ::std::string* mutable_rt9();
  inline ::std::string* release_rt9();
  
  // optional string EntrustBatchNO = 11;
  inline bool has_entrustbatchno() const;
  inline void clear_entrustbatchno();
  static const int kEntrustBatchNOFieldNumber = 11;
  inline const ::std::string& entrustbatchno() const;
  inline void set_entrustbatchno(const ::std::string& value);
  inline void set_entrustbatchno(const char* value);
  inline void set_entrustbatchno(const char* value, size_t size);
  inline ::std::string* mutable_entrustbatchno();
  inline ::std::string* release_entrustbatchno();
  
  // optional string RT11 = 12;
  inline bool has_rt11() const;
  inline void clear_rt11();
  static const int kRT11FieldNumber = 12;
  inline const ::std::string& rt11() const;
  inline void set_rt11(const ::std::string& value);
  inline void set_rt11(const char* value);
  inline void set_rt11(const char* value, size_t size);
  inline ::std::string* mutable_rt11();
  inline ::std::string* release_rt11();
  
  // optional string CombineMode = 13;
  inline bool has_combinemode() const;
  inline void clear_combinemode();
  static const int kCombineModeFieldNumber = 13;
  inline const ::std::string& combinemode() const;
  inline void set_combinemode(const ::std::string& value);
  inline void set_combinemode(const char* value);
  inline void set_combinemode(const char* value, size_t size);
  inline ::std::string* mutable_combinemode();
  inline ::std::string* release_combinemode();
  
  // optional string QueryDir = 14;
  inline bool has_querydir() const;
  inline void clear_querydir();
  static const int kQueryDirFieldNumber = 14;
  inline const ::std::string& querydir() const;
  inline void set_querydir(const ::std::string& value);
  inline void set_querydir(const char* value);
  inline void set_querydir(const char* value, size_t size);
  inline ::std::string* mutable_querydir();
  inline ::std::string* release_querydir();
  
  // optional string RT14 = 15;
  inline bool has_rt14() const;
  inline void clear_rt14();
  static const int kRT14FieldNumber = 15;
  inline const ::std::string& rt14() const;
  inline void set_rt14(const ::std::string& value);
  inline void set_rt14(const char* value);
  inline void set_rt14(const char* value, size_t size);
  inline ::std::string* mutable_rt14();
  inline ::std::string* release_rt14();
  
  // optional string RT15 = 16;
  inline bool has_rt15() const;
  inline void clear_rt15();
  static const int kRT15FieldNumber = 16;
  inline const ::std::string& rt15() const;
  inline void set_rt15(const ::std::string& value);
  inline void set_rt15(const char* value);
  inline void set_rt15(const char* value, size_t size);
  inline ::std::string* mutable_rt15();
  inline ::std::string* release_rt15();
  
  // optional string EntrustType = 17;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 17;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // @@protoc_insertion_point(class_scope:INF_QueryBatchEntrust_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_rt5();
  inline void clear_has_rt5();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_rt8();
  inline void clear_has_rt8();
  inline void set_has_rt9();
  inline void clear_has_rt9();
  inline void set_has_entrustbatchno();
  inline void clear_has_entrustbatchno();
  inline void set_has_rt11();
  inline void clear_has_rt11();
  inline void set_has_combinemode();
  inline void clear_has_combinemode();
  inline void set_has_querydir();
  inline void clear_has_querydir();
  inline void set_has_rt14();
  inline void clear_has_rt14();
  inline void set_has_rt15();
  inline void clear_has_rt15();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* rt5_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* rt8_;
  ::std::string* rt9_;
  ::std::string* entrustbatchno_;
  ::std::string* rt11_;
  ::std::string* combinemode_;
  ::std::string* querydir_;
  ::std::string* rt14_;
  ::std::string* rt15_;
  ::std::string* entrusttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryBatchEntrust_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_BatchEntrust_Req : public ::google::protobuf::Message {
 public:
  INF_BatchEntrust_Req();
  virtual ~INF_BatchEntrust_Req();
  
  INF_BatchEntrust_Req(const INF_BatchEntrust_Req& from);
  
  inline INF_BatchEntrust_Req& operator=(const INF_BatchEntrust_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_BatchEntrust_Req& default_instance();
  
  void Swap(INF_BatchEntrust_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_BatchEntrust_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_BatchEntrust_Req& from);
  void MergeFrom(const INF_BatchEntrust_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string RT5 = 6;
  inline bool has_rt5() const;
  inline void clear_rt5();
  static const int kRT5FieldNumber = 6;
  inline const ::std::string& rt5() const;
  inline void set_rt5(const ::std::string& value);
  inline void set_rt5(const char* value);
  inline void set_rt5(const char* value, size_t size);
  inline ::std::string* mutable_rt5();
  inline ::std::string* release_rt5();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string ETFserialNO = 9;
  inline bool has_etfserialno() const;
  inline void clear_etfserialno();
  static const int kETFserialNOFieldNumber = 9;
  inline const ::std::string& etfserialno() const;
  inline void set_etfserialno(const ::std::string& value);
  inline void set_etfserialno(const char* value);
  inline void set_etfserialno(const char* value, size_t size);
  inline ::std::string* mutable_etfserialno();
  inline ::std::string* release_etfserialno();
  
  // optional string ControlArg = 10;
  inline bool has_controlarg() const;
  inline void clear_controlarg();
  static const int kControlArgFieldNumber = 10;
  inline const ::std::string& controlarg() const;
  inline void set_controlarg(const ::std::string& value);
  inline void set_controlarg(const char* value);
  inline void set_controlarg(const char* value, size_t size);
  inline ::std::string* mutable_controlarg();
  inline ::std::string* release_controlarg();
  
  // optional string EntrustType = 11;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 11;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // optional string EntrustBatchNO = 12;
  inline bool has_entrustbatchno() const;
  inline void clear_entrustbatchno();
  static const int kEntrustBatchNOFieldNumber = 12;
  inline const ::std::string& entrustbatchno() const;
  inline void set_entrustbatchno(const ::std::string& value);
  inline void set_entrustbatchno(const char* value);
  inline void set_entrustbatchno(const char* value, size_t size);
  inline ::std::string* mutable_entrustbatchno();
  inline ::std::string* release_entrustbatchno();
  
  // optional string EntrustHistoryNum = 13;
  inline bool has_entrusthistorynum() const;
  inline void clear_entrusthistorynum();
  static const int kEntrustHistoryNumFieldNumber = 13;
  inline const ::std::string& entrusthistorynum() const;
  inline void set_entrusthistorynum(const ::std::string& value);
  inline void set_entrusthistorynum(const char* value);
  inline void set_entrusthistorynum(const char* value, size_t size);
  inline ::std::string* mutable_entrusthistorynum();
  inline ::std::string* release_entrusthistorynum();
  
  // optional string EntrustData = 14;
  inline bool has_entrustdata() const;
  inline void clear_entrustdata();
  static const int kEntrustDataFieldNumber = 14;
  inline const ::std::string& entrustdata() const;
  inline void set_entrustdata(const ::std::string& value);
  inline void set_entrustdata(const char* value);
  inline void set_entrustdata(const char* value, size_t size);
  inline ::std::string* mutable_entrustdata();
  inline ::std::string* release_entrustdata();
  
  // @@protoc_insertion_point(class_scope:INF_BatchEntrust_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_rt5();
  inline void clear_has_rt5();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_etfserialno();
  inline void clear_has_etfserialno();
  inline void set_has_controlarg();
  inline void clear_has_controlarg();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  inline void set_has_entrustbatchno();
  inline void clear_has_entrustbatchno();
  inline void set_has_entrusthistorynum();
  inline void clear_has_entrusthistorynum();
  inline void set_has_entrustdata();
  inline void clear_has_entrustdata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* rt5_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* etfserialno_;
  ::std::string* controlarg_;
  ::std::string* entrusttype_;
  ::std::string* entrustbatchno_;
  ::std::string* entrusthistorynum_;
  ::std::string* entrustdata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_BatchEntrust_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_BatchCancel_Req : public ::google::protobuf::Message {
 public:
  INF_BatchCancel_Req();
  virtual ~INF_BatchCancel_Req();
  
  INF_BatchCancel_Req(const INF_BatchCancel_Req& from);
  
  inline INF_BatchCancel_Req& operator=(const INF_BatchCancel_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_BatchCancel_Req& default_instance();
  
  void Swap(INF_BatchCancel_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_BatchCancel_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_BatchCancel_Req& from);
  void MergeFrom(const INF_BatchCancel_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string RT5 = 6;
  inline bool has_rt5() const;
  inline void clear_rt5();
  static const int kRT5FieldNumber = 6;
  inline const ::std::string& rt5() const;
  inline void set_rt5(const ::std::string& value);
  inline void set_rt5(const char* value);
  inline void set_rt5(const char* value, size_t size);
  inline ::std::string* mutable_rt5();
  inline ::std::string* release_rt5();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string EntrustBatchNO = 9;
  inline bool has_entrustbatchno() const;
  inline void clear_entrustbatchno();
  static const int kEntrustBatchNOFieldNumber = 9;
  inline const ::std::string& entrustbatchno() const;
  inline void set_entrustbatchno(const ::std::string& value);
  inline void set_entrustbatchno(const char* value);
  inline void set_entrustbatchno(const char* value, size_t size);
  inline ::std::string* mutable_entrustbatchno();
  inline ::std::string* release_entrustbatchno();
  
  // optional string EntrustType = 10;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 10;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // @@protoc_insertion_point(class_scope:INF_BatchCancel_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_rt5();
  inline void clear_has_rt5();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_entrustbatchno();
  inline void clear_has_entrustbatchno();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* rt5_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* entrustbatchno_;
  ::std::string* entrusttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_BatchCancel_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryVaildRedemNum_Req : public ::google::protobuf::Message {
 public:
  INF_QueryVaildRedemNum_Req();
  virtual ~INF_QueryVaildRedemNum_Req();
  
  INF_QueryVaildRedemNum_Req(const INF_QueryVaildRedemNum_Req& from);
  
  inline INF_QueryVaildRedemNum_Req& operator=(const INF_QueryVaildRedemNum_Req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryVaildRedemNum_Req& default_instance();
  
  void Swap(INF_QueryVaildRedemNum_Req* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryVaildRedemNum_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryVaildRedemNum_Req& from);
  void MergeFrom(const INF_QueryVaildRedemNum_Req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string RT0 = 1;
  inline bool has_rt0() const;
  inline void clear_rt0();
  static const int kRT0FieldNumber = 1;
  inline const ::std::string& rt0() const;
  inline void set_rt0(const ::std::string& value);
  inline void set_rt0(const char* value);
  inline void set_rt0(const char* value, size_t size);
  inline ::std::string* mutable_rt0();
  inline ::std::string* release_rt0();
  
  // optional string Localhost = 2;
  inline bool has_localhost() const;
  inline void clear_localhost();
  static const int kLocalhostFieldNumber = 2;
  inline const ::std::string& localhost() const;
  inline void set_localhost(const ::std::string& value);
  inline void set_localhost(const char* value);
  inline void set_localhost(const char* value, size_t size);
  inline ::std::string* mutable_localhost();
  inline ::std::string* release_localhost();
  
  // optional string ReqID = 3;
  inline bool has_reqid() const;
  inline void clear_reqid();
  static const int kReqIDFieldNumber = 3;
  inline const ::std::string& reqid() const;
  inline void set_reqid(const ::std::string& value);
  inline void set_reqid(const char* value);
  inline void set_reqid(const char* value, size_t size);
  inline ::std::string* mutable_reqid();
  inline ::std::string* release_reqid();
  
  // optional string FuncID = 4;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 4;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // optional string DepartmentID = 5;
  inline bool has_departmentid() const;
  inline void clear_departmentid();
  static const int kDepartmentIDFieldNumber = 5;
  inline const ::std::string& departmentid() const;
  inline void set_departmentid(const ::std::string& value);
  inline void set_departmentid(const char* value);
  inline void set_departmentid(const char* value, size_t size);
  inline ::std::string* mutable_departmentid();
  inline ::std::string* release_departmentid();
  
  // optional string RT5 = 6;
  inline bool has_rt5() const;
  inline void clear_rt5();
  static const int kRT5FieldNumber = 6;
  inline const ::std::string& rt5() const;
  inline void set_rt5(const ::std::string& value);
  inline void set_rt5(const char* value);
  inline void set_rt5(const char* value, size_t size);
  inline ::std::string* mutable_rt5();
  inline ::std::string* release_rt5();
  
  // optional string RT6 = 7;
  inline bool has_rt6() const;
  inline void clear_rt6();
  static const int kRT6FieldNumber = 7;
  inline const ::std::string& rt6() const;
  inline void set_rt6(const ::std::string& value);
  inline void set_rt6(const char* value);
  inline void set_rt6(const char* value, size_t size);
  inline ::std::string* mutable_rt6();
  inline ::std::string* release_rt6();
  
  // optional string CustomID = 8;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIDFieldNumber = 8;
  inline const ::std::string& customid() const;
  inline void set_customid(const ::std::string& value);
  inline void set_customid(const char* value);
  inline void set_customid(const char* value, size_t size);
  inline ::std::string* mutable_customid();
  inline ::std::string* release_customid();
  
  // optional string ETFserialNumber = 9;
  inline bool has_etfserialnumber() const;
  inline void clear_etfserialnumber();
  static const int kETFserialNumberFieldNumber = 9;
  inline const ::std::string& etfserialnumber() const;
  inline void set_etfserialnumber(const ::std::string& value);
  inline void set_etfserialnumber(const char* value);
  inline void set_etfserialnumber(const char* value, size_t size);
  inline ::std::string* mutable_etfserialnumber();
  inline ::std::string* release_etfserialnumber();
  
  // optional string SecurityCode = 10;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 10;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string PurRedemFlag = 11;
  inline bool has_purredemflag() const;
  inline void clear_purredemflag();
  static const int kPurRedemFlagFieldNumber = 11;
  inline const ::std::string& purredemflag() const;
  inline void set_purredemflag(const ::std::string& value);
  inline void set_purredemflag(const char* value);
  inline void set_purredemflag(const char* value, size_t size);
  inline ::std::string* mutable_purredemflag();
  inline ::std::string* release_purredemflag();
  
  // optional string EntrustType = 12;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 12;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // @@protoc_insertion_point(class_scope:INF_QueryVaildRedemNum_Req)
 private:
  inline void set_has_rt0();
  inline void clear_has_rt0();
  inline void set_has_localhost();
  inline void clear_has_localhost();
  inline void set_has_reqid();
  inline void clear_has_reqid();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_departmentid();
  inline void clear_has_departmentid();
  inline void set_has_rt5();
  inline void clear_has_rt5();
  inline void set_has_rt6();
  inline void clear_has_rt6();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_etfserialnumber();
  inline void clear_has_etfserialnumber();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_purredemflag();
  inline void clear_has_purredemflag();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rt0_;
  ::std::string* localhost_;
  ::std::string* reqid_;
  ::std::string* funcid_;
  ::std::string* departmentid_;
  ::std::string* rt5_;
  ::std::string* rt6_;
  ::std::string* customid_;
  ::std::string* etfserialnumber_;
  ::std::string* securitycode_;
  ::std::string* purredemflag_;
  ::std::string* entrusttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryVaildRedemNum_Req* default_instance_;
};
// -------------------------------------------------------------------

class INF_OneEntrust_Ack : public ::google::protobuf::Message {
 public:
  INF_OneEntrust_Ack();
  virtual ~INF_OneEntrust_Ack();
  
  INF_OneEntrust_Ack(const INF_OneEntrust_Ack& from);
  
  inline INF_OneEntrust_Ack& operator=(const INF_OneEntrust_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_OneEntrust_Ack& default_instance();
  
  void Swap(INF_OneEntrust_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_OneEntrust_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_OneEntrust_Ack& from);
  void MergeFrom(const INF_OneEntrust_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string EntrustSerial = 1;
  inline bool has_entrustserial() const;
  inline void clear_entrustserial();
  static const int kEntrustSerialFieldNumber = 1;
  inline const ::std::string& entrustserial() const;
  inline void set_entrustserial(const ::std::string& value);
  inline void set_entrustserial(const char* value);
  inline void set_entrustserial(const char* value, size_t size);
  inline ::std::string* mutable_entrustserial();
  inline ::std::string* release_entrustserial();
  
  // optional string Valid = 2;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 2;
  inline const ::std::string& valid() const;
  inline void set_valid(const ::std::string& value);
  inline void set_valid(const char* value);
  inline void set_valid(const char* value, size_t size);
  inline ::std::string* mutable_valid();
  inline ::std::string* release_valid();
  
  // optional string RespFlag = 3;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 3;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string IsSuccess = 4;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 4;
  inline const ::std::string& issuccess() const;
  inline void set_issuccess(const ::std::string& value);
  inline void set_issuccess(const char* value);
  inline void set_issuccess(const char* value, size_t size);
  inline ::std::string* mutable_issuccess();
  inline ::std::string* release_issuccess();
  
  // optional string EntrustSeq = 5;
  inline bool has_entrustseq() const;
  inline void clear_entrustseq();
  static const int kEntrustSeqFieldNumber = 5;
  inline const ::std::string& entrustseq() const;
  inline void set_entrustseq(const ::std::string& value);
  inline void set_entrustseq(const char* value);
  inline void set_entrustseq(const char* value, size_t size);
  inline ::std::string* mutable_entrustseq();
  inline ::std::string* release_entrustseq();
  
  // optional string EntrustBatchNO = 6;
  inline bool has_entrustbatchno() const;
  inline void clear_entrustbatchno();
  static const int kEntrustBatchNOFieldNumber = 6;
  inline const ::std::string& entrustbatchno() const;
  inline void set_entrustbatchno(const ::std::string& value);
  inline void set_entrustbatchno(const char* value);
  inline void set_entrustbatchno(const char* value, size_t size);
  inline ::std::string* mutable_entrustbatchno();
  inline ::std::string* release_entrustbatchno();
  
  // optional string SuccessNum = 7;
  inline bool has_successnum() const;
  inline void clear_successnum();
  static const int kSuccessNumFieldNumber = 7;
  inline const ::std::string& successnum() const;
  inline void set_successnum(const ::std::string& value);
  inline void set_successnum(const char* value);
  inline void set_successnum(const char* value, size_t size);
  inline ::std::string* mutable_successnum();
  inline ::std::string* release_successnum();
  
  // @@protoc_insertion_point(class_scope:INF_OneEntrust_Ack)
 private:
  inline void set_has_entrustserial();
  inline void clear_has_entrustserial();
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_issuccess();
  inline void clear_has_issuccess();
  inline void set_has_entrustseq();
  inline void clear_has_entrustseq();
  inline void set_has_entrustbatchno();
  inline void clear_has_entrustbatchno();
  inline void set_has_successnum();
  inline void clear_has_successnum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* entrustserial_;
  ::std::string* valid_;
  ::std::string* respflag_;
  ::std::string* issuccess_;
  ::std::string* entrustseq_;
  ::std::string* entrustbatchno_;
  ::std::string* successnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_OneEntrust_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_BatchEntrust_Ack : public ::google::protobuf::Message {
 public:
  INF_BatchEntrust_Ack();
  virtual ~INF_BatchEntrust_Ack();
  
  INF_BatchEntrust_Ack(const INF_BatchEntrust_Ack& from);
  
  inline INF_BatchEntrust_Ack& operator=(const INF_BatchEntrust_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_BatchEntrust_Ack& default_instance();
  
  void Swap(INF_BatchEntrust_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_BatchEntrust_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_BatchEntrust_Ack& from);
  void MergeFrom(const INF_BatchEntrust_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string EntrustSerial = 1;
  inline bool has_entrustserial() const;
  inline void clear_entrustserial();
  static const int kEntrustSerialFieldNumber = 1;
  inline const ::std::string& entrustserial() const;
  inline void set_entrustserial(const ::std::string& value);
  inline void set_entrustserial(const char* value);
  inline void set_entrustserial(const char* value, size_t size);
  inline ::std::string* mutable_entrustserial();
  inline ::std::string* release_entrustserial();
  
  // optional string Valid = 2;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 2;
  inline const ::std::string& valid() const;
  inline void set_valid(const ::std::string& value);
  inline void set_valid(const char* value);
  inline void set_valid(const char* value, size_t size);
  inline ::std::string* mutable_valid();
  inline ::std::string* release_valid();
  
  // optional string RespFlag = 3;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 3;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string IsSuccess = 4;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 4;
  inline const ::std::string& issuccess() const;
  inline void set_issuccess(const ::std::string& value);
  inline void set_issuccess(const char* value);
  inline void set_issuccess(const char* value, size_t size);
  inline ::std::string* mutable_issuccess();
  inline ::std::string* release_issuccess();
  
  // optional string RecordNum = 5;
  inline bool has_recordnum() const;
  inline void clear_recordnum();
  static const int kRecordNumFieldNumber = 5;
  inline const ::std::string& recordnum() const;
  inline void set_recordnum(const ::std::string& value);
  inline void set_recordnum(const char* value);
  inline void set_recordnum(const char* value, size_t size);
  inline ::std::string* mutable_recordnum();
  inline ::std::string* release_recordnum();
  
  // optional string TradingResults = 6;
  inline bool has_tradingresults() const;
  inline void clear_tradingresults();
  static const int kTradingResultsFieldNumber = 6;
  inline const ::std::string& tradingresults() const;
  inline void set_tradingresults(const ::std::string& value);
  inline void set_tradingresults(const char* value);
  inline void set_tradingresults(const char* value, size_t size);
  inline ::std::string* mutable_tradingresults();
  inline ::std::string* release_tradingresults();
  
  // optional string EntrustBatchNO = 7;
  inline bool has_entrustbatchno() const;
  inline void clear_entrustbatchno();
  static const int kEntrustBatchNOFieldNumber = 7;
  inline const ::std::string& entrustbatchno() const;
  inline void set_entrustbatchno(const ::std::string& value);
  inline void set_entrustbatchno(const char* value);
  inline void set_entrustbatchno(const char* value, size_t size);
  inline ::std::string* mutable_entrustbatchno();
  inline ::std::string* release_entrustbatchno();
  
  // optional string BargainNO = 8;
  inline bool has_bargainno() const;
  inline void clear_bargainno();
  static const int kBargainNOFieldNumber = 8;
  inline const ::std::string& bargainno() const;
  inline void set_bargainno(const ::std::string& value);
  inline void set_bargainno(const char* value);
  inline void set_bargainno(const char* value, size_t size);
  inline ::std::string* mutable_bargainno();
  inline ::std::string* release_bargainno();
  
  // optional string EntrustSeq = 9;
  inline bool has_entrustseq() const;
  inline void clear_entrustseq();
  static const int kEntrustSeqFieldNumber = 9;
  inline const ::std::string& entrustseq() const;
  inline void set_entrustseq(const ::std::string& value);
  inline void set_entrustseq(const char* value);
  inline void set_entrustseq(const char* value, size_t size);
  inline ::std::string* mutable_entrustseq();
  inline ::std::string* release_entrustseq();
  
  // @@protoc_insertion_point(class_scope:INF_BatchEntrust_Ack)
 private:
  inline void set_has_entrustserial();
  inline void clear_has_entrustserial();
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_issuccess();
  inline void clear_has_issuccess();
  inline void set_has_recordnum();
  inline void clear_has_recordnum();
  inline void set_has_tradingresults();
  inline void clear_has_tradingresults();
  inline void set_has_entrustbatchno();
  inline void clear_has_entrustbatchno();
  inline void set_has_bargainno();
  inline void clear_has_bargainno();
  inline void set_has_entrustseq();
  inline void clear_has_entrustseq();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* entrustserial_;
  ::std::string* valid_;
  ::std::string* respflag_;
  ::std::string* issuccess_;
  ::std::string* recordnum_;
  ::std::string* tradingresults_;
  ::std::string* entrustbatchno_;
  ::std::string* bargainno_;
  ::std::string* entrustseq_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_BatchEntrust_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryOneEntrust_Ack : public ::google::protobuf::Message {
 public:
  INF_QueryOneEntrust_Ack();
  virtual ~INF_QueryOneEntrust_Ack();
  
  INF_QueryOneEntrust_Ack(const INF_QueryOneEntrust_Ack& from);
  
  inline INF_QueryOneEntrust_Ack& operator=(const INF_QueryOneEntrust_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryOneEntrust_Ack& default_instance();
  
  void Swap(INF_QueryOneEntrust_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryOneEntrust_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryOneEntrust_Ack& from);
  void MergeFrom(const INF_QueryOneEntrust_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Valid = 1;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 1;
  inline const ::std::string& valid() const;
  inline void set_valid(const ::std::string& value);
  inline void set_valid(const char* value);
  inline void set_valid(const char* value, size_t size);
  inline ::std::string* mutable_valid();
  inline ::std::string* release_valid();
  
  // optional string SecurityCode = 2;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 2;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string SecurityName = 3;
  inline bool has_securityname() const;
  inline void clear_securityname();
  static const int kSecurityNameFieldNumber = 3;
  inline const ::std::string& securityname() const;
  inline void set_securityname(const ::std::string& value);
  inline void set_securityname(const char* value);
  inline void set_securityname(const char* value, size_t size);
  inline ::std::string* mutable_securityname();
  inline ::std::string* release_securityname();
  
  // optional string EntrustNum = 4;
  inline bool has_entrustnum() const;
  inline void clear_entrustnum();
  static const int kEntrustNumFieldNumber = 4;
  inline const ::std::string& entrustnum() const;
  inline void set_entrustnum(const ::std::string& value);
  inline void set_entrustnum(const char* value);
  inline void set_entrustnum(const char* value, size_t size);
  inline ::std::string* mutable_entrustnum();
  inline ::std::string* release_entrustnum();
  
  // optional string EntrustPrice = 5;
  inline bool has_entrustprice() const;
  inline void clear_entrustprice();
  static const int kEntrustPriceFieldNumber = 5;
  inline const ::std::string& entrustprice() const;
  inline void set_entrustprice(const ::std::string& value);
  inline void set_entrustprice(const char* value);
  inline void set_entrustprice(const char* value, size_t size);
  inline ::std::string* mutable_entrustprice();
  inline ::std::string* release_entrustprice();
  
  // optional string EntrustSerial = 6;
  inline bool has_entrustserial() const;
  inline void clear_entrustserial();
  static const int kEntrustSerialFieldNumber = 6;
  inline const ::std::string& entrustserial() const;
  inline void set_entrustserial(const ::std::string& value);
  inline void set_entrustserial(const char* value);
  inline void set_entrustserial(const char* value, size_t size);
  inline ::std::string* mutable_entrustserial();
  inline ::std::string* release_entrustserial();
  
  // optional string CjNum = 7;
  inline bool has_cjnum() const;
  inline void clear_cjnum();
  static const int kCjNumFieldNumber = 7;
  inline const ::std::string& cjnum() const;
  inline void set_cjnum(const ::std::string& value);
  inline void set_cjnum(const char* value);
  inline void set_cjnum(const char* value, size_t size);
  inline ::std::string* mutable_cjnum();
  inline ::std::string* release_cjnum();
  
  // optional string EntrustTime = 8;
  inline bool has_entrusttime() const;
  inline void clear_entrusttime();
  static const int kEntrustTimeFieldNumber = 8;
  inline const ::std::string& entrusttime() const;
  inline void set_entrusttime(const ::std::string& value);
  inline void set_entrusttime(const char* value);
  inline void set_entrusttime(const char* value, size_t size);
  inline ::std::string* mutable_entrusttime();
  inline ::std::string* release_entrusttime();
  
  // optional string MarketID = 9;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 9;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string BSflag = 10;
  inline bool has_bsflag() const;
  inline void clear_bsflag();
  static const int kBSflagFieldNumber = 10;
  inline const ::std::string& bsflag() const;
  inline void set_bsflag(const ::std::string& value);
  inline void set_bsflag(const char* value);
  inline void set_bsflag(const char* value, size_t size);
  inline ::std::string* mutable_bsflag();
  inline ::std::string* release_bsflag();
  
  // optional string EntrustStatus = 11;
  inline bool has_entruststatus() const;
  inline void clear_entruststatus();
  static const int kEntrustStatusFieldNumber = 11;
  inline const ::std::string& entruststatus() const;
  inline void set_entruststatus(const ::std::string& value);
  inline void set_entruststatus(const char* value);
  inline void set_entruststatus(const char* value, size_t size);
  inline ::std::string* mutable_entruststatus();
  inline ::std::string* release_entruststatus();
  
  // optional string CjPriceSum = 12;
  inline bool has_cjpricesum() const;
  inline void clear_cjpricesum();
  static const int kCjPriceSumFieldNumber = 12;
  inline const ::std::string& cjpricesum() const;
  inline void set_cjpricesum(const ::std::string& value);
  inline void set_cjpricesum(const char* value);
  inline void set_cjpricesum(const char* value, size_t size);
  inline ::std::string* mutable_cjpricesum();
  inline ::std::string* release_cjpricesum();
  
  // optional string RespFlag = 13;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 13;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string IsSuccess = 14;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 14;
  inline const ::std::string& issuccess() const;
  inline void set_issuccess(const ::std::string& value);
  inline void set_issuccess(const char* value);
  inline void set_issuccess(const char* value, size_t size);
  inline ::std::string* mutable_issuccess();
  inline ::std::string* release_issuccess();
  
  // optional string RecordNum = 15;
  inline bool has_recordnum() const;
  inline void clear_recordnum();
  static const int kRecordNumFieldNumber = 15;
  inline const ::std::string& recordnum() const;
  inline void set_recordnum(const ::std::string& value);
  inline void set_recordnum(const char* value);
  inline void set_recordnum(const char* value, size_t size);
  inline ::std::string* mutable_recordnum();
  inline ::std::string* release_recordnum();
  
  // optional string StockholderAccount = 16;
  inline bool has_stockholderaccount() const;
  inline void clear_stockholderaccount();
  static const int kStockholderAccountFieldNumber = 16;
  inline const ::std::string& stockholderaccount() const;
  inline void set_stockholderaccount(const ::std::string& value);
  inline void set_stockholderaccount(const char* value);
  inline void set_stockholderaccount(const char* value, size_t size);
  inline ::std::string* mutable_stockholderaccount();
  inline ::std::string* release_stockholderaccount();
  
  // optional string BSTypeName = 17;
  inline bool has_bstypename() const;
  inline void clear_bstypename();
  static const int kBSTypeNameFieldNumber = 17;
  inline const ::std::string& bstypename() const;
  inline void set_bstypename(const ::std::string& value);
  inline void set_bstypename(const char* value);
  inline void set_bstypename(const char* value, size_t size);
  inline ::std::string* mutable_bstypename();
  inline ::std::string* release_bstypename();
  
  // optional string BSTypeFlag = 18;
  inline bool has_bstypeflag() const;
  inline void clear_bstypeflag();
  static const int kBSTypeFlagFieldNumber = 18;
  inline const ::std::string& bstypeflag() const;
  inline void set_bstypeflag(const ::std::string& value);
  inline void set_bstypeflag(const char* value);
  inline void set_bstypeflag(const char* value, size_t size);
  inline ::std::string* mutable_bstypeflag();
  inline ::std::string* release_bstypeflag();
  
  // optional string BargainNO = 19;
  inline bool has_bargainno() const;
  inline void clear_bargainno();
  static const int kBargainNOFieldNumber = 19;
  inline const ::std::string& bargainno() const;
  inline void set_bargainno(const ::std::string& value);
  inline void set_bargainno(const char* value);
  inline void set_bargainno(const char* value, size_t size);
  inline ::std::string* mutable_bargainno();
  inline ::std::string* release_bargainno();
  
  // optional string CjPrice = 20;
  inline bool has_cjprice() const;
  inline void clear_cjprice();
  static const int kCjPriceFieldNumber = 20;
  inline const ::std::string& cjprice() const;
  inline void set_cjprice(const ::std::string& value);
  inline void set_cjprice(const char* value);
  inline void set_cjprice(const char* value, size_t size);
  inline ::std::string* mutable_cjprice();
  inline ::std::string* release_cjprice();
  
  // optional string CjStatusName = 21;
  inline bool has_cjstatusname() const;
  inline void clear_cjstatusname();
  static const int kCjStatusNameFieldNumber = 21;
  inline const ::std::string& cjstatusname() const;
  inline void set_cjstatusname(const ::std::string& value);
  inline void set_cjstatusname(const char* value);
  inline void set_cjstatusname(const char* value, size_t size);
  inline ::std::string* mutable_cjstatusname();
  inline ::std::string* release_cjstatusname();
  
  // optional string Date = 22;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 22;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  
  // optional string ErrorMsg = 23;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrorMsgFieldNumber = 23;
  inline const ::std::string& errormsg() const;
  inline void set_errormsg(const ::std::string& value);
  inline void set_errormsg(const char* value);
  inline void set_errormsg(const char* value, size_t size);
  inline ::std::string* mutable_errormsg();
  inline ::std::string* release_errormsg();
  
  // optional string ErrorCode = 24;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 24;
  inline const ::std::string& errorcode() const;
  inline void set_errorcode(const ::std::string& value);
  inline void set_errorcode(const char* value);
  inline void set_errorcode(const char* value, size_t size);
  inline ::std::string* mutable_errorcode();
  inline ::std::string* release_errorcode();
  
  // optional string CjStatus = 25;
  inline bool has_cjstatus() const;
  inline void clear_cjstatus();
  static const int kCjStatusFieldNumber = 25;
  inline const ::std::string& cjstatus() const;
  inline void set_cjstatus(const ::std::string& value);
  inline void set_cjstatus(const char* value);
  inline void set_cjstatus(const char* value, size_t size);
  inline ::std::string* mutable_cjstatus();
  inline ::std::string* release_cjstatus();
  
  // optional string EntrustStatusFlag = 26;
  inline bool has_entruststatusflag() const;
  inline void clear_entruststatusflag();
  static const int kEntrustStatusFlagFieldNumber = 26;
  inline const ::std::string& entruststatusflag() const;
  inline void set_entruststatusflag(const ::std::string& value);
  inline void set_entruststatusflag(const char* value);
  inline void set_entruststatusflag(const char* value, size_t size);
  inline ::std::string* mutable_entruststatusflag();
  inline ::std::string* release_entruststatusflag();
  
  // optional string CancelOrderNum = 27;
  inline bool has_cancelordernum() const;
  inline void clear_cancelordernum();
  static const int kCancelOrderNumFieldNumber = 27;
  inline const ::std::string& cancelordernum() const;
  inline void set_cancelordernum(const ::std::string& value);
  inline void set_cancelordernum(const char* value);
  inline void set_cancelordernum(const char* value, size_t size);
  inline ::std::string* mutable_cancelordernum();
  inline ::std::string* release_cancelordernum();
  
  // optional string EntrustAttr = 28;
  inline bool has_entrustattr() const;
  inline void clear_entrustattr();
  static const int kEntrustAttrFieldNumber = 28;
  inline const ::std::string& entrustattr() const;
  inline void set_entrustattr(const ::std::string& value);
  inline void set_entrustattr(const char* value);
  inline void set_entrustattr(const char* value, size_t size);
  inline ::std::string* mutable_entrustattr();
  inline ::std::string* release_entrustattr();
  
  // optional string EntrustType = 29;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 29;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // @@protoc_insertion_point(class_scope:INF_QueryOneEntrust_Ack)
 private:
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_securityname();
  inline void clear_has_securityname();
  inline void set_has_entrustnum();
  inline void clear_has_entrustnum();
  inline void set_has_entrustprice();
  inline void clear_has_entrustprice();
  inline void set_has_entrustserial();
  inline void clear_has_entrustserial();
  inline void set_has_cjnum();
  inline void clear_has_cjnum();
  inline void set_has_entrusttime();
  inline void clear_has_entrusttime();
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_bsflag();
  inline void clear_has_bsflag();
  inline void set_has_entruststatus();
  inline void clear_has_entruststatus();
  inline void set_has_cjpricesum();
  inline void clear_has_cjpricesum();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_issuccess();
  inline void clear_has_issuccess();
  inline void set_has_recordnum();
  inline void clear_has_recordnum();
  inline void set_has_stockholderaccount();
  inline void clear_has_stockholderaccount();
  inline void set_has_bstypename();
  inline void clear_has_bstypename();
  inline void set_has_bstypeflag();
  inline void clear_has_bstypeflag();
  inline void set_has_bargainno();
  inline void clear_has_bargainno();
  inline void set_has_cjprice();
  inline void clear_has_cjprice();
  inline void set_has_cjstatusname();
  inline void clear_has_cjstatusname();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_cjstatus();
  inline void clear_has_cjstatus();
  inline void set_has_entruststatusflag();
  inline void clear_has_entruststatusflag();
  inline void set_has_cancelordernum();
  inline void clear_has_cancelordernum();
  inline void set_has_entrustattr();
  inline void clear_has_entrustattr();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* valid_;
  ::std::string* securitycode_;
  ::std::string* securityname_;
  ::std::string* entrustnum_;
  ::std::string* entrustprice_;
  ::std::string* entrustserial_;
  ::std::string* cjnum_;
  ::std::string* entrusttime_;
  ::std::string* marketid_;
  ::std::string* bsflag_;
  ::std::string* entruststatus_;
  ::std::string* cjpricesum_;
  ::std::string* respflag_;
  ::std::string* issuccess_;
  ::std::string* recordnum_;
  ::std::string* stockholderaccount_;
  ::std::string* bstypename_;
  ::std::string* bstypeflag_;
  ::std::string* bargainno_;
  ::std::string* cjprice_;
  ::std::string* cjstatusname_;
  ::std::string* date_;
  ::std::string* errormsg_;
  ::std::string* errorcode_;
  ::std::string* cjstatus_;
  ::std::string* entruststatusflag_;
  ::std::string* cancelordernum_;
  ::std::string* entrustattr_;
  ::std::string* entrusttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryOneEntrust_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryBatchEntrust_Ack : public ::google::protobuf::Message {
 public:
  INF_QueryBatchEntrust_Ack();
  virtual ~INF_QueryBatchEntrust_Ack();
  
  INF_QueryBatchEntrust_Ack(const INF_QueryBatchEntrust_Ack& from);
  
  inline INF_QueryBatchEntrust_Ack& operator=(const INF_QueryBatchEntrust_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryBatchEntrust_Ack& default_instance();
  
  void Swap(INF_QueryBatchEntrust_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryBatchEntrust_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryBatchEntrust_Ack& from);
  void MergeFrom(const INF_QueryBatchEntrust_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string EntrustBatchNO = 1;
  inline bool has_entrustbatchno() const;
  inline void clear_entrustbatchno();
  static const int kEntrustBatchNOFieldNumber = 1;
  inline const ::std::string& entrustbatchno() const;
  inline void set_entrustbatchno(const ::std::string& value);
  inline void set_entrustbatchno(const char* value);
  inline void set_entrustbatchno(const char* value, size_t size);
  inline ::std::string* mutable_entrustbatchno();
  inline ::std::string* release_entrustbatchno();
  
  // optional string EntrustSeq = 2;
  inline bool has_entrustseq() const;
  inline void clear_entrustseq();
  static const int kEntrustSeqFieldNumber = 2;
  inline const ::std::string& entrustseq() const;
  inline void set_entrustseq(const ::std::string& value);
  inline void set_entrustseq(const char* value);
  inline void set_entrustseq(const char* value, size_t size);
  inline ::std::string* mutable_entrustseq();
  inline ::std::string* release_entrustseq();
  
  // optional string MarketID = 3;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 3;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string SecurityCode = 4;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 4;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string BSflag = 5;
  inline bool has_bsflag() const;
  inline void clear_bsflag();
  static const int kBSflagFieldNumber = 5;
  inline const ::std::string& bsflag() const;
  inline void set_bsflag(const ::std::string& value);
  inline void set_bsflag(const char* value);
  inline void set_bsflag(const char* value, size_t size);
  inline ::std::string* mutable_bsflag();
  inline ::std::string* release_bsflag();
  
  // optional string EntrustNum = 6;
  inline bool has_entrustnum() const;
  inline void clear_entrustnum();
  static const int kEntrustNumFieldNumber = 6;
  inline const ::std::string& entrustnum() const;
  inline void set_entrustnum(const ::std::string& value);
  inline void set_entrustnum(const char* value);
  inline void set_entrustnum(const char* value, size_t size);
  inline ::std::string* mutable_entrustnum();
  inline ::std::string* release_entrustnum();
  
  // optional string EntrustPrice = 7;
  inline bool has_entrustprice() const;
  inline void clear_entrustprice();
  static const int kEntrustPriceFieldNumber = 7;
  inline const ::std::string& entrustprice() const;
  inline void set_entrustprice(const ::std::string& value);
  inline void set_entrustprice(const char* value);
  inline void set_entrustprice(const char* value, size_t size);
  inline ::std::string* mutable_entrustprice();
  inline ::std::string* release_entrustprice();
  
  // optional string EntrustStatus = 8;
  inline bool has_entruststatus() const;
  inline void clear_entruststatus();
  static const int kEntrustStatusFieldNumber = 8;
  inline const ::std::string& entruststatus() const;
  inline void set_entruststatus(const ::std::string& value);
  inline void set_entruststatus(const char* value);
  inline void set_entruststatus(const char* value, size_t size);
  inline ::std::string* mutable_entruststatus();
  inline ::std::string* release_entruststatus();
  
  // optional string CjNum = 9;
  inline bool has_cjnum() const;
  inline void clear_cjnum();
  static const int kCjNumFieldNumber = 9;
  inline const ::std::string& cjnum() const;
  inline void set_cjnum(const ::std::string& value);
  inline void set_cjnum(const char* value);
  inline void set_cjnum(const char* value, size_t size);
  inline ::std::string* mutable_cjnum();
  inline ::std::string* release_cjnum();
  
  // optional string CjPrice = 10;
  inline bool has_cjprice() const;
  inline void clear_cjprice();
  static const int kCjPriceFieldNumber = 10;
  inline const ::std::string& cjprice() const;
  inline void set_cjprice(const ::std::string& value);
  inline void set_cjprice(const char* value);
  inline void set_cjprice(const char* value, size_t size);
  inline ::std::string* mutable_cjprice();
  inline ::std::string* release_cjprice();
  
  // optional string EntrustTime = 11;
  inline bool has_entrusttime() const;
  inline void clear_entrusttime();
  static const int kEntrustTimeFieldNumber = 11;
  inline const ::std::string& entrusttime() const;
  inline void set_entrusttime(const ::std::string& value);
  inline void set_entrusttime(const char* value);
  inline void set_entrusttime(const char* value, size_t size);
  inline ::std::string* mutable_entrusttime();
  inline ::std::string* release_entrusttime();
  
  // optional string Valid = 12;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 12;
  inline const ::std::string& valid() const;
  inline void set_valid(const ::std::string& value);
  inline void set_valid(const char* value);
  inline void set_valid(const char* value, size_t size);
  inline ::std::string* mutable_valid();
  inline ::std::string* release_valid();
  
  // optional string RespFlag = 13;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 13;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string IsSuccess = 14;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 14;
  inline const ::std::string& issuccess() const;
  inline void set_issuccess(const ::std::string& value);
  inline void set_issuccess(const char* value);
  inline void set_issuccess(const char* value, size_t size);
  inline ::std::string* mutable_issuccess();
  inline ::std::string* release_issuccess();
  
  // optional string RecordNum = 15;
  inline bool has_recordnum() const;
  inline void clear_recordnum();
  static const int kRecordNumFieldNumber = 15;
  inline const ::std::string& recordnum() const;
  inline void set_recordnum(const ::std::string& value);
  inline void set_recordnum(const char* value);
  inline void set_recordnum(const char* value, size_t size);
  inline ::std::string* mutable_recordnum();
  inline ::std::string* release_recordnum();
  
  // optional string CurrentDate = 16;
  inline bool has_currentdate() const;
  inline void clear_currentdate();
  static const int kCurrentDateFieldNumber = 16;
  inline const ::std::string& currentdate() const;
  inline void set_currentdate(const ::std::string& value);
  inline void set_currentdate(const char* value);
  inline void set_currentdate(const char* value, size_t size);
  inline ::std::string* mutable_currentdate();
  inline ::std::string* release_currentdate();
  
  // optional string EntrustNo = 17;
  inline bool has_entrustno() const;
  inline void clear_entrustno();
  static const int kEntrustNoFieldNumber = 17;
  inline const ::std::string& entrustno() const;
  inline void set_entrustno(const ::std::string& value);
  inline void set_entrustno(const char* value);
  inline void set_entrustno(const char* value, size_t size);
  inline ::std::string* mutable_entrustno();
  inline ::std::string* release_entrustno();
  
  // optional string DeclareNo = 18;
  inline bool has_declareno() const;
  inline void clear_declareno();
  static const int kDeclareNoFieldNumber = 18;
  inline const ::std::string& declareno() const;
  inline void set_declareno(const ::std::string& value);
  inline void set_declareno(const char* value);
  inline void set_declareno(const char* value, size_t size);
  inline ::std::string* mutable_declareno();
  inline ::std::string* release_declareno();
  
  // optional string ClientNo = 19;
  inline bool has_clientno() const;
  inline void clear_clientno();
  static const int kClientNoFieldNumber = 19;
  inline const ::std::string& clientno() const;
  inline void set_clientno(const ::std::string& value);
  inline void set_clientno(const char* value);
  inline void set_clientno(const char* value, size_t size);
  inline ::std::string* mutable_clientno();
  inline ::std::string* release_clientno();
  
  // optional string StockholderAccount = 20;
  inline bool has_stockholderaccount() const;
  inline void clear_stockholderaccount();
  static const int kStockholderAccountFieldNumber = 20;
  inline const ::std::string& stockholderaccount() const;
  inline void set_stockholderaccount(const ::std::string& value);
  inline void set_stockholderaccount(const char* value);
  inline void set_stockholderaccount(const char* value, size_t size);
  inline ::std::string* mutable_stockholderaccount();
  inline ::std::string* release_stockholderaccount();
  
  // optional string SecurityName = 21;
  inline bool has_securityname() const;
  inline void clear_securityname();
  static const int kSecurityNameFieldNumber = 21;
  inline const ::std::string& securityname() const;
  inline void set_securityname(const ::std::string& value);
  inline void set_securityname(const char* value);
  inline void set_securityname(const char* value, size_t size);
  inline ::std::string* mutable_securityname();
  inline ::std::string* release_securityname();
  
  // optional string EntrustType = 22;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 22;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // optional string BSflagName = 23;
  inline bool has_bsflagname() const;
  inline void clear_bsflagname();
  static const int kBSflagNameFieldNumber = 23;
  inline const ::std::string& bsflagname() const;
  inline void set_bsflagname(const ::std::string& value);
  inline void set_bsflagname(const char* value);
  inline void set_bsflagname(const char* value, size_t size);
  inline ::std::string* mutable_bsflagname();
  inline ::std::string* release_bsflagname();
  
  // optional string CjStatus = 24;
  inline bool has_cjstatus() const;
  inline void clear_cjstatus();
  static const int kCjStatusFieldNumber = 24;
  inline const ::std::string& cjstatus() const;
  inline void set_cjstatus(const ::std::string& value);
  inline void set_cjstatus(const char* value);
  inline void set_cjstatus(const char* value, size_t size);
  inline ::std::string* mutable_cjstatus();
  inline ::std::string* release_cjstatus();
  
  // optional string CjStatusName = 25;
  inline bool has_cjstatusname() const;
  inline void clear_cjstatusname();
  static const int kCjStatusNameFieldNumber = 25;
  inline const ::std::string& cjstatusname() const;
  inline void set_cjstatusname(const ::std::string& value);
  inline void set_cjstatusname(const char* value);
  inline void set_cjstatusname(const char* value, size_t size);
  inline ::std::string* mutable_cjstatusname();
  inline ::std::string* release_cjstatusname();
  
  // optional string CjDate = 26;
  inline bool has_cjdate() const;
  inline void clear_cjdate();
  static const int kCjDateFieldNumber = 26;
  inline const ::std::string& cjdate() const;
  inline void set_cjdate(const ::std::string& value);
  inline void set_cjdate(const char* value);
  inline void set_cjdate(const char* value, size_t size);
  inline ::std::string* mutable_cjdate();
  inline ::std::string* release_cjdate();
  
  // optional string DeclareTime = 27;
  inline bool has_declaretime() const;
  inline void clear_declaretime();
  static const int kDeclareTimeFieldNumber = 27;
  inline const ::std::string& declaretime() const;
  inline void set_declaretime(const ::std::string& value);
  inline void set_declaretime(const char* value);
  inline void set_declaretime(const char* value, size_t size);
  inline ::std::string* mutable_declaretime();
  inline ::std::string* release_declaretime();
  
  // optional string EntrustPenNum = 28;
  inline bool has_entrustpennum() const;
  inline void clear_entrustpennum();
  static const int kEntrustPenNumFieldNumber = 28;
  inline const ::std::string& entrustpennum() const;
  inline void set_entrustpennum(const ::std::string& value);
  inline void set_entrustpennum(const char* value);
  inline void set_entrustpennum(const char* value, size_t size);
  inline ::std::string* mutable_entrustpennum();
  inline ::std::string* release_entrustpennum();
  
  // optional string PageStartPos = 29;
  inline bool has_pagestartpos() const;
  inline void clear_pagestartpos();
  static const int kPageStartPosFieldNumber = 29;
  inline const ::std::string& pagestartpos() const;
  inline void set_pagestartpos(const ::std::string& value);
  inline void set_pagestartpos(const char* value);
  inline void set_pagestartpos(const char* value, size_t size);
  inline ::std::string* mutable_pagestartpos();
  inline ::std::string* release_pagestartpos();
  
  // optional string HaveCancelNum = 30;
  inline bool has_havecancelnum() const;
  inline void clear_havecancelnum();
  static const int kHaveCancelNumFieldNumber = 30;
  inline const ::std::string& havecancelnum() const;
  inline void set_havecancelnum(const ::std::string& value);
  inline void set_havecancelnum(const char* value);
  inline void set_havecancelnum(const char* value, size_t size);
  inline ::std::string* mutable_havecancelnum();
  inline ::std::string* release_havecancelnum();
  
  // @@protoc_insertion_point(class_scope:INF_QueryBatchEntrust_Ack)
 private:
  inline void set_has_entrustbatchno();
  inline void clear_has_entrustbatchno();
  inline void set_has_entrustseq();
  inline void clear_has_entrustseq();
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_bsflag();
  inline void clear_has_bsflag();
  inline void set_has_entrustnum();
  inline void clear_has_entrustnum();
  inline void set_has_entrustprice();
  inline void clear_has_entrustprice();
  inline void set_has_entruststatus();
  inline void clear_has_entruststatus();
  inline void set_has_cjnum();
  inline void clear_has_cjnum();
  inline void set_has_cjprice();
  inline void clear_has_cjprice();
  inline void set_has_entrusttime();
  inline void clear_has_entrusttime();
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_issuccess();
  inline void clear_has_issuccess();
  inline void set_has_recordnum();
  inline void clear_has_recordnum();
  inline void set_has_currentdate();
  inline void clear_has_currentdate();
  inline void set_has_entrustno();
  inline void clear_has_entrustno();
  inline void set_has_declareno();
  inline void clear_has_declareno();
  inline void set_has_clientno();
  inline void clear_has_clientno();
  inline void set_has_stockholderaccount();
  inline void clear_has_stockholderaccount();
  inline void set_has_securityname();
  inline void clear_has_securityname();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  inline void set_has_bsflagname();
  inline void clear_has_bsflagname();
  inline void set_has_cjstatus();
  inline void clear_has_cjstatus();
  inline void set_has_cjstatusname();
  inline void clear_has_cjstatusname();
  inline void set_has_cjdate();
  inline void clear_has_cjdate();
  inline void set_has_declaretime();
  inline void clear_has_declaretime();
  inline void set_has_entrustpennum();
  inline void clear_has_entrustpennum();
  inline void set_has_pagestartpos();
  inline void clear_has_pagestartpos();
  inline void set_has_havecancelnum();
  inline void clear_has_havecancelnum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* entrustbatchno_;
  ::std::string* entrustseq_;
  ::std::string* marketid_;
  ::std::string* securitycode_;
  ::std::string* bsflag_;
  ::std::string* entrustnum_;
  ::std::string* entrustprice_;
  ::std::string* entruststatus_;
  ::std::string* cjnum_;
  ::std::string* cjprice_;
  ::std::string* entrusttime_;
  ::std::string* valid_;
  ::std::string* respflag_;
  ::std::string* issuccess_;
  ::std::string* recordnum_;
  ::std::string* currentdate_;
  ::std::string* entrustno_;
  ::std::string* declareno_;
  ::std::string* clientno_;
  ::std::string* stockholderaccount_;
  ::std::string* securityname_;
  ::std::string* entrusttype_;
  ::std::string* bsflagname_;
  ::std::string* cjstatus_;
  ::std::string* cjstatusname_;
  ::std::string* cjdate_;
  ::std::string* declaretime_;
  ::std::string* entrustpennum_;
  ::std::string* pagestartpos_;
  ::std::string* havecancelnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryBatchEntrust_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_OneCancel_Ack : public ::google::protobuf::Message {
 public:
  INF_OneCancel_Ack();
  virtual ~INF_OneCancel_Ack();
  
  INF_OneCancel_Ack(const INF_OneCancel_Ack& from);
  
  inline INF_OneCancel_Ack& operator=(const INF_OneCancel_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_OneCancel_Ack& default_instance();
  
  void Swap(INF_OneCancel_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_OneCancel_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_OneCancel_Ack& from);
  void MergeFrom(const INF_OneCancel_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Valid = 1;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 1;
  inline const ::std::string& valid() const;
  inline void set_valid(const ::std::string& value);
  inline void set_valid(const char* value);
  inline void set_valid(const char* value, size_t size);
  inline ::std::string* mutable_valid();
  inline ::std::string* release_valid();
  
  // optional string RespFlag = 2;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 2;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string IsSuccess = 3;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 3;
  inline const ::std::string& issuccess() const;
  inline void set_issuccess(const ::std::string& value);
  inline void set_issuccess(const char* value);
  inline void set_issuccess(const char* value, size_t size);
  inline ::std::string* mutable_issuccess();
  inline ::std::string* release_issuccess();
  
  // @@protoc_insertion_point(class_scope:INF_OneCancel_Ack)
 private:
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_issuccess();
  inline void clear_has_issuccess();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* valid_;
  ::std::string* respflag_;
  ::std::string* issuccess_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_OneCancel_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_BatchCancel_Ack : public ::google::protobuf::Message {
 public:
  INF_BatchCancel_Ack();
  virtual ~INF_BatchCancel_Ack();
  
  INF_BatchCancel_Ack(const INF_BatchCancel_Ack& from);
  
  inline INF_BatchCancel_Ack& operator=(const INF_BatchCancel_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_BatchCancel_Ack& default_instance();
  
  void Swap(INF_BatchCancel_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_BatchCancel_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_BatchCancel_Ack& from);
  void MergeFrom(const INF_BatchCancel_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Valid = 1;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 1;
  inline const ::std::string& valid() const;
  inline void set_valid(const ::std::string& value);
  inline void set_valid(const char* value);
  inline void set_valid(const char* value, size_t size);
  inline ::std::string* mutable_valid();
  inline ::std::string* release_valid();
  
  // optional string RespFlag = 2;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 2;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string IsSuccess = 3;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 3;
  inline const ::std::string& issuccess() const;
  inline void set_issuccess(const ::std::string& value);
  inline void set_issuccess(const char* value);
  inline void set_issuccess(const char* value, size_t size);
  inline ::std::string* mutable_issuccess();
  inline ::std::string* release_issuccess();
  
  // optional string CancelPenNum = 4;
  inline bool has_cancelpennum() const;
  inline void clear_cancelpennum();
  static const int kCancelPenNumFieldNumber = 4;
  inline const ::std::string& cancelpennum() const;
  inline void set_cancelpennum(const ::std::string& value);
  inline void set_cancelpennum(const char* value);
  inline void set_cancelpennum(const char* value, size_t size);
  inline ::std::string* mutable_cancelpennum();
  inline ::std::string* release_cancelpennum();
  
  // optional string CancelNum = 5;
  inline bool has_cancelnum() const;
  inline void clear_cancelnum();
  static const int kCancelNumFieldNumber = 5;
  inline const ::std::string& cancelnum() const;
  inline void set_cancelnum(const ::std::string& value);
  inline void set_cancelnum(const char* value);
  inline void set_cancelnum(const char* value, size_t size);
  inline ::std::string* mutable_cancelnum();
  inline ::std::string* release_cancelnum();
  
  // @@protoc_insertion_point(class_scope:INF_BatchCancel_Ack)
 private:
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_issuccess();
  inline void clear_has_issuccess();
  inline void set_has_cancelpennum();
  inline void clear_has_cancelpennum();
  inline void set_has_cancelnum();
  inline void clear_has_cancelnum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* valid_;
  ::std::string* respflag_;
  ::std::string* issuccess_;
  ::std::string* cancelpennum_;
  ::std::string* cancelnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_BatchCancel_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryETFbaseInfo_Ack : public ::google::protobuf::Message {
 public:
  INF_QueryETFbaseInfo_Ack();
  virtual ~INF_QueryETFbaseInfo_Ack();
  
  INF_QueryETFbaseInfo_Ack(const INF_QueryETFbaseInfo_Ack& from);
  
  inline INF_QueryETFbaseInfo_Ack& operator=(const INF_QueryETFbaseInfo_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryETFbaseInfo_Ack& default_instance();
  
  void Swap(INF_QueryETFbaseInfo_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryETFbaseInfo_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryETFbaseInfo_Ack& from);
  void MergeFrom(const INF_QueryETFbaseInfo_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ETFName = 1;
  inline bool has_etfname() const;
  inline void clear_etfname();
  static const int kETFNameFieldNumber = 1;
  inline const ::std::string& etfname() const;
  inline void set_etfname(const ::std::string& value);
  inline void set_etfname(const char* value);
  inline void set_etfname(const char* value, size_t size);
  inline ::std::string* mutable_etfname();
  inline ::std::string* release_etfname();
  
  // optional string OneMarketCode = 2;
  inline bool has_onemarketcode() const;
  inline void clear_onemarketcode();
  static const int kOneMarketCodeFieldNumber = 2;
  inline const ::std::string& onemarketcode() const;
  inline void set_onemarketcode(const ::std::string& value);
  inline void set_onemarketcode(const char* value);
  inline void set_onemarketcode(const char* value, size_t size);
  inline ::std::string* mutable_onemarketcode();
  inline ::std::string* release_onemarketcode();
  
  // optional string TwoMarketCode = 3;
  inline bool has_twomarketcode() const;
  inline void clear_twomarketcode();
  static const int kTwoMarketCodeFieldNumber = 3;
  inline const ::std::string& twomarketcode() const;
  inline void set_twomarketcode(const ::std::string& value);
  inline void set_twomarketcode(const char* value);
  inline void set_twomarketcode(const char* value, size_t size);
  inline ::std::string* mutable_twomarketcode();
  inline ::std::string* release_twomarketcode();
  
  // optional string ETFminPurRedemUnit = 4;
  inline bool has_etfminpurredemunit() const;
  inline void clear_etfminpurredemunit();
  static const int kETFminPurRedemUnitFieldNumber = 4;
  inline const ::std::string& etfminpurredemunit() const;
  inline void set_etfminpurredemunit(const ::std::string& value);
  inline void set_etfminpurredemunit(const char* value);
  inline void set_etfminpurredemunit(const char* value, size_t size);
  inline ::std::string* mutable_etfminpurredemunit();
  inline ::std::string* release_etfminpurredemunit();
  
  // optional string CashDiffer = 5;
  inline bool has_cashdiffer() const;
  inline void clear_cashdiffer();
  static const int kCashDifferFieldNumber = 5;
  inline const ::std::string& cashdiffer() const;
  inline void set_cashdiffer(const ::std::string& value);
  inline void set_cashdiffer(const char* value);
  inline void set_cashdiffer(const char* value, size_t size);
  inline ::std::string* mutable_cashdiffer();
  inline ::std::string* release_cashdiffer();
  
  // optional string CastReplaceRatio = 6;
  inline bool has_castreplaceratio() const;
  inline void clear_castreplaceratio();
  static const int kCastReplaceRatioFieldNumber = 6;
  inline const ::std::string& castreplaceratio() const;
  inline void set_castreplaceratio(const ::std::string& value);
  inline void set_castreplaceratio(const char* value);
  inline void set_castreplaceratio(const char* value, size_t size);
  inline ::std::string* mutable_castreplaceratio();
  inline ::std::string* release_castreplaceratio();
  
  // optional string PurRedemStatus = 7;
  inline bool has_purredemstatus() const;
  inline void clear_purredemstatus();
  static const int kPurRedemStatusFieldNumber = 7;
  inline const ::std::string& purredemstatus() const;
  inline void set_purredemstatus(const ::std::string& value);
  inline void set_purredemstatus(const char* value);
  inline void set_purredemstatus(const char* value, size_t size);
  inline ::std::string* mutable_purredemstatus();
  inline ::std::string* release_purredemstatus();
  
  // optional string EstimDiffer = 8;
  inline bool has_estimdiffer() const;
  inline void clear_estimdiffer();
  static const int kEstimDifferFieldNumber = 8;
  inline const ::std::string& estimdiffer() const;
  inline void set_estimdiffer(const ::std::string& value);
  inline void set_estimdiffer(const char* value);
  inline void set_estimdiffer(const char* value, size_t size);
  inline ::std::string* mutable_estimdiffer();
  inline ::std::string* release_estimdiffer();
  
  // optional string UnitNetValue = 9;
  inline bool has_unitnetvalue() const;
  inline void clear_unitnetvalue();
  static const int kUnitNetValueFieldNumber = 9;
  inline const ::std::string& unitnetvalue() const;
  inline void set_unitnetvalue(const ::std::string& value);
  inline void set_unitnetvalue(const char* value);
  inline void set_unitnetvalue(const char* value, size_t size);
  inline ::std::string* mutable_unitnetvalue();
  inline ::std::string* release_unitnetvalue();
  
  // optional string AllStocksNum = 10;
  inline bool has_allstocksnum() const;
  inline void clear_allstocksnum();
  static const int kAllStocksNumFieldNumber = 10;
  inline const ::std::string& allstocksnum() const;
  inline void set_allstocksnum(const ::std::string& value);
  inline void set_allstocksnum(const char* value);
  inline void set_allstocksnum(const char* value, size_t size);
  inline ::std::string* mutable_allstocksnum();
  inline ::std::string* release_allstocksnum();
  
  // optional string RespFlag = 11;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 11;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string IsSuccess = 12;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 12;
  inline const ::std::string& issuccess() const;
  inline void set_issuccess(const ::std::string& value);
  inline void set_issuccess(const char* value);
  inline void set_issuccess(const char* value, size_t size);
  inline ::std::string* mutable_issuccess();
  inline ::std::string* release_issuccess();
  
  // optional string RecordNum = 13;
  inline bool has_recordnum() const;
  inline void clear_recordnum();
  static const int kRecordNumFieldNumber = 13;
  inline const ::std::string& recordnum() const;
  inline void set_recordnum(const ::std::string& value);
  inline void set_recordnum(const char* value);
  inline void set_recordnum(const char* value, size_t size);
  inline ::std::string* mutable_recordnum();
  inline ::std::string* release_recordnum();
  
  // optional string subscriptCode = 14;
  inline bool has_subscriptcode() const;
  inline void clear_subscriptcode();
  static const int kSubscriptCodeFieldNumber = 14;
  inline const ::std::string& subscriptcode() const;
  inline void set_subscriptcode(const ::std::string& value);
  inline void set_subscriptcode(const char* value);
  inline void set_subscriptcode(const char* value, size_t size);
  inline ::std::string* mutable_subscriptcode();
  inline ::std::string* release_subscriptcode();
  
  // optional string ETFNum = 15;
  inline bool has_etfnum() const;
  inline void clear_etfnum();
  static const int kETFNumFieldNumber = 15;
  inline const ::std::string& etfnum() const;
  inline void set_etfnum(const ::std::string& value);
  inline void set_etfnum(const char* value);
  inline void set_etfnum(const char* value, size_t size);
  inline ::std::string* mutable_etfnum();
  inline ::std::string* release_etfnum();
  
  // optional string CashBalances = 16;
  inline bool has_cashbalances() const;
  inline void clear_cashbalances();
  static const int kCashBalancesFieldNumber = 16;
  inline const ::std::string& cashbalances() const;
  inline void set_cashbalances(const ::std::string& value);
  inline void set_cashbalances(const char* value);
  inline void set_cashbalances(const char* value, size_t size);
  inline ::std::string* mutable_cashbalances();
  inline ::std::string* release_cashbalances();
  
  // optional string IsPurRedeem = 17;
  inline bool has_ispurredeem() const;
  inline void clear_ispurredeem();
  static const int kIsPurRedeemFieldNumber = 17;
  inline const ::std::string& ispurredeem() const;
  inline void set_ispurredeem(const ::std::string& value);
  inline void set_ispurredeem(const char* value);
  inline void set_ispurredeem(const char* value, size_t size);
  inline ::std::string* mutable_ispurredeem();
  inline ::std::string* release_ispurredeem();
  
  // optional string TrailerDate = 18;
  inline bool has_trailerdate() const;
  inline void clear_trailerdate();
  static const int kTrailerDateFieldNumber = 18;
  inline const ::std::string& trailerdate() const;
  inline void set_trailerdate(const ::std::string& value);
  inline void set_trailerdate(const char* value);
  inline void set_trailerdate(const char* value, size_t size);
  inline ::std::string* mutable_trailerdate();
  inline ::std::string* release_trailerdate();
  
  // optional string PreCashDiffer = 19;
  inline bool has_precashdiffer() const;
  inline void clear_precashdiffer();
  static const int kPreCashDifferFieldNumber = 19;
  inline const ::std::string& precashdiffer() const;
  inline void set_precashdiffer(const ::std::string& value);
  inline void set_precashdiffer(const char* value);
  inline void set_precashdiffer(const char* value, size_t size);
  inline ::std::string* mutable_precashdiffer();
  inline ::std::string* release_precashdiffer();
  
  // optional string FundNet = 20;
  inline bool has_fundnet() const;
  inline void clear_fundnet();
  static const int kFundNetFieldNumber = 20;
  inline const ::std::string& fundnet() const;
  inline void set_fundnet(const ::std::string& value);
  inline void set_fundnet(const char* value);
  inline void set_fundnet(const char* value, size_t size);
  inline ::std::string* mutable_fundnet();
  inline ::std::string* release_fundnet();
  
  // optional string StockNum = 21;
  inline bool has_stocknum() const;
  inline void clear_stocknum();
  static const int kStockNumFieldNumber = 21;
  inline const ::std::string& stocknum() const;
  inline void set_stocknum(const ::std::string& value);
  inline void set_stocknum(const char* value);
  inline void set_stocknum(const char* value, size_t size);
  inline ::std::string* mutable_stocknum();
  inline ::std::string* release_stocknum();
  
  // optional string ETFAttr = 22;
  inline bool has_etfattr() const;
  inline void clear_etfattr();
  static const int kETFAttrFieldNumber = 22;
  inline const ::std::string& etfattr() const;
  inline void set_etfattr(const ::std::string& value);
  inline void set_etfattr(const char* value);
  inline void set_etfattr(const char* value, size_t size);
  inline ::std::string* mutable_etfattr();
  inline ::std::string* release_etfattr();
  
  // @@protoc_insertion_point(class_scope:INF_QueryETFbaseInfo_Ack)
 private:
  inline void set_has_etfname();
  inline void clear_has_etfname();
  inline void set_has_onemarketcode();
  inline void clear_has_onemarketcode();
  inline void set_has_twomarketcode();
  inline void clear_has_twomarketcode();
  inline void set_has_etfminpurredemunit();
  inline void clear_has_etfminpurredemunit();
  inline void set_has_cashdiffer();
  inline void clear_has_cashdiffer();
  inline void set_has_castreplaceratio();
  inline void clear_has_castreplaceratio();
  inline void set_has_purredemstatus();
  inline void clear_has_purredemstatus();
  inline void set_has_estimdiffer();
  inline void clear_has_estimdiffer();
  inline void set_has_unitnetvalue();
  inline void clear_has_unitnetvalue();
  inline void set_has_allstocksnum();
  inline void clear_has_allstocksnum();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_issuccess();
  inline void clear_has_issuccess();
  inline void set_has_recordnum();
  inline void clear_has_recordnum();
  inline void set_has_subscriptcode();
  inline void clear_has_subscriptcode();
  inline void set_has_etfnum();
  inline void clear_has_etfnum();
  inline void set_has_cashbalances();
  inline void clear_has_cashbalances();
  inline void set_has_ispurredeem();
  inline void clear_has_ispurredeem();
  inline void set_has_trailerdate();
  inline void clear_has_trailerdate();
  inline void set_has_precashdiffer();
  inline void clear_has_precashdiffer();
  inline void set_has_fundnet();
  inline void clear_has_fundnet();
  inline void set_has_stocknum();
  inline void clear_has_stocknum();
  inline void set_has_etfattr();
  inline void clear_has_etfattr();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* etfname_;
  ::std::string* onemarketcode_;
  ::std::string* twomarketcode_;
  ::std::string* etfminpurredemunit_;
  ::std::string* cashdiffer_;
  ::std::string* castreplaceratio_;
  ::std::string* purredemstatus_;
  ::std::string* estimdiffer_;
  ::std::string* unitnetvalue_;
  ::std::string* allstocksnum_;
  ::std::string* respflag_;
  ::std::string* issuccess_;
  ::std::string* recordnum_;
  ::std::string* subscriptcode_;
  ::std::string* etfnum_;
  ::std::string* cashbalances_;
  ::std::string* ispurredeem_;
  ::std::string* trailerdate_;
  ::std::string* precashdiffer_;
  ::std::string* fundnet_;
  ::std::string* stocknum_;
  ::std::string* etfattr_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryETFbaseInfo_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryETFlistInfo_Ack : public ::google::protobuf::Message {
 public:
  INF_QueryETFlistInfo_Ack();
  virtual ~INF_QueryETFlistInfo_Ack();
  
  INF_QueryETFlistInfo_Ack(const INF_QueryETFlistInfo_Ack& from);
  
  inline INF_QueryETFlistInfo_Ack& operator=(const INF_QueryETFlistInfo_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryETFlistInfo_Ack& default_instance();
  
  void Swap(INF_QueryETFlistInfo_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryETFlistInfo_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryETFlistInfo_Ack& from);
  void MergeFrom(const INF_QueryETFlistInfo_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string MarketID = 1;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 1;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string SecurityCode = 2;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 2;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string SecurityName = 3;
  inline bool has_securityname() const;
  inline void clear_securityname();
  static const int kSecurityNameFieldNumber = 3;
  inline const ::std::string& securityname() const;
  inline void set_securityname(const ::std::string& value);
  inline void set_securityname(const char* value);
  inline void set_securityname(const char* value, size_t size);
  inline ::std::string* mutable_securityname();
  inline ::std::string* release_securityname();
  
  // optional string SecurityNum = 4;
  inline bool has_securitynum() const;
  inline void clear_securitynum();
  static const int kSecurityNumFieldNumber = 4;
  inline const ::std::string& securitynum() const;
  inline void set_securitynum(const ::std::string& value);
  inline void set_securitynum(const char* value);
  inline void set_securitynum(const char* value, size_t size);
  inline ::std::string* mutable_securitynum();
  inline ::std::string* release_securitynum();
  
  // optional string CastReplaceFlag = 5;
  inline bool has_castreplaceflag() const;
  inline void clear_castreplaceflag();
  static const int kCastReplaceFlagFieldNumber = 5;
  inline const ::std::string& castreplaceflag() const;
  inline void set_castreplaceflag(const ::std::string& value);
  inline void set_castreplaceflag(const char* value);
  inline void set_castreplaceflag(const char* value, size_t size);
  inline ::std::string* mutable_castreplaceflag();
  inline ::std::string* release_castreplaceflag();
  
  // optional string CastReplaceRate = 6;
  inline bool has_castreplacerate() const;
  inline void clear_castreplacerate();
  static const int kCastReplaceRateFieldNumber = 6;
  inline const ::std::string& castreplacerate() const;
  inline void set_castreplacerate(const ::std::string& value);
  inline void set_castreplacerate(const char* value);
  inline void set_castreplacerate(const char* value, size_t size);
  inline ::std::string* mutable_castreplacerate();
  inline ::std::string* release_castreplacerate();
  
  // optional string FundReplaceSum = 7;
  inline bool has_fundreplacesum() const;
  inline void clear_fundreplacesum();
  static const int kFundReplaceSumFieldNumber = 7;
  inline const ::std::string& fundreplacesum() const;
  inline void set_fundreplacesum(const ::std::string& value);
  inline void set_fundreplacesum(const char* value);
  inline void set_fundreplacesum(const char* value, size_t size);
  inline ::std::string* mutable_fundreplacesum();
  inline ::std::string* release_fundreplacesum();
  
  // optional string RespFlag = 8;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 8;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string DisplayNo = 9;
  inline bool has_displayno() const;
  inline void clear_displayno();
  static const int kDisplayNoFieldNumber = 9;
  inline const ::std::string& displayno() const;
  inline void set_displayno(const ::std::string& value);
  inline void set_displayno(const char* value);
  inline void set_displayno(const char* value, size_t size);
  inline ::std::string* mutable_displayno();
  inline ::std::string* release_displayno();
  
  // optional string StockOfMarket = 10;
  inline bool has_stockofmarket() const;
  inline void clear_stockofmarket();
  static const int kStockOfMarketFieldNumber = 10;
  inline const ::std::string& stockofmarket() const;
  inline void set_stockofmarket(const ::std::string& value);
  inline void set_stockofmarket(const char* value);
  inline void set_stockofmarket(const char* value, size_t size);
  inline ::std::string* mutable_stockofmarket();
  inline ::std::string* release_stockofmarket();
  
  // @@protoc_insertion_point(class_scope:INF_QueryETFlistInfo_Ack)
 private:
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_securityname();
  inline void clear_has_securityname();
  inline void set_has_securitynum();
  inline void clear_has_securitynum();
  inline void set_has_castreplaceflag();
  inline void clear_has_castreplaceflag();
  inline void set_has_castreplacerate();
  inline void clear_has_castreplacerate();
  inline void set_has_fundreplacesum();
  inline void clear_has_fundreplacesum();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_displayno();
  inline void clear_has_displayno();
  inline void set_has_stockofmarket();
  inline void clear_has_stockofmarket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* marketid_;
  ::std::string* securitycode_;
  ::std::string* securityname_;
  ::std::string* securitynum_;
  ::std::string* castreplaceflag_;
  ::std::string* castreplacerate_;
  ::std::string* fundreplacesum_;
  ::std::string* respflag_;
  ::std::string* displayno_;
  ::std::string* stockofmarket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryETFlistInfo_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryETFdynamicInfo_Ack : public ::google::protobuf::Message {
 public:
  INF_QueryETFdynamicInfo_Ack();
  virtual ~INF_QueryETFdynamicInfo_Ack();
  
  INF_QueryETFdynamicInfo_Ack(const INF_QueryETFdynamicInfo_Ack& from);
  
  inline INF_QueryETFdynamicInfo_Ack& operator=(const INF_QueryETFdynamicInfo_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryETFdynamicInfo_Ack& default_instance();
  
  void Swap(INF_QueryETFdynamicInfo_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryETFdynamicInfo_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryETFdynamicInfo_Ack& from);
  void MergeFrom(const INF_QueryETFdynamicInfo_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string MarketID = 1;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 1;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string ETFCode = 2;
  inline bool has_etfcode() const;
  inline void clear_etfcode();
  static const int kETFCodeFieldNumber = 2;
  inline const ::std::string& etfcode() const;
  inline void set_etfcode(const ::std::string& value);
  inline void set_etfcode(const char* value);
  inline void set_etfcode(const char* value, size_t size);
  inline ::std::string* mutable_etfcode();
  inline ::std::string* release_etfcode();
  
  // optional string ValidPurRedemNum = 3;
  inline bool has_validpurredemnum() const;
  inline void clear_validpurredemnum();
  static const int kValidPurRedemNumFieldNumber = 3;
  inline const ::std::string& validpurredemnum() const;
  inline void set_validpurredemnum(const ::std::string& value);
  inline void set_validpurredemnum(const char* value);
  inline void set_validpurredemnum(const char* value, size_t size);
  inline ::std::string* mutable_validpurredemnum();
  inline ::std::string* release_validpurredemnum();
  
  // optional string RespFlag = 4;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 4;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string ETFName = 5;
  inline bool has_etfname() const;
  inline void clear_etfname();
  static const int kETFNameFieldNumber = 5;
  inline const ::std::string& etfname() const;
  inline void set_etfname(const ::std::string& value);
  inline void set_etfname(const char* value);
  inline void set_etfname(const char* value, size_t size);
  inline ::std::string* mutable_etfname();
  inline ::std::string* release_etfname();
  
  // optional string BaskeAskNum = 6;
  inline bool has_baskeasknum() const;
  inline void clear_baskeasknum();
  static const int kBaskeAskNumFieldNumber = 6;
  inline const ::std::string& baskeasknum() const;
  inline void set_baskeasknum(const ::std::string& value);
  inline void set_baskeasknum(const char* value);
  inline void set_baskeasknum(const char* value, size_t size);
  inline ::std::string* mutable_baskeasknum();
  inline ::std::string* release_baskeasknum();
  
  // optional string NeedBuyNum = 7;
  inline bool has_needbuynum() const;
  inline void clear_needbuynum();
  static const int kNeedBuyNumFieldNumber = 7;
  inline const ::std::string& needbuynum() const;
  inline void set_needbuynum(const ::std::string& value);
  inline void set_needbuynum(const char* value);
  inline void set_needbuynum(const char* value, size_t size);
  inline ::std::string* mutable_needbuynum();
  inline ::std::string* release_needbuynum();
  
  // optional string CanReplaceFund = 8;
  inline bool has_canreplacefund() const;
  inline void clear_canreplacefund();
  static const int kCanReplaceFundFieldNumber = 8;
  inline const ::std::string& canreplacefund() const;
  inline void set_canreplacefund(const ::std::string& value);
  inline void set_canreplacefund(const char* value);
  inline void set_canreplacefund(const char* value, size_t size);
  inline ::std::string* mutable_canreplacefund();
  inline ::std::string* release_canreplacefund();
  
  // optional string MustReplaceFund = 9;
  inline bool has_mustreplacefund() const;
  inline void clear_mustreplacefund();
  static const int kMustReplaceFundFieldNumber = 9;
  inline const ::std::string& mustreplacefund() const;
  inline void set_mustreplacefund(const ::std::string& value);
  inline void set_mustreplacefund(const char* value);
  inline void set_mustreplacefund(const char* value, size_t size);
  inline ::std::string* mutable_mustreplacefund();
  inline ::std::string* release_mustreplacefund();
  
  // optional string PositionOfUndeal = 10;
  inline bool has_positionofundeal() const;
  inline void clear_positionofundeal();
  static const int kPositionOfUndealFieldNumber = 10;
  inline const ::std::string& positionofundeal() const;
  inline void set_positionofundeal(const ::std::string& value);
  inline void set_positionofundeal(const char* value);
  inline void set_positionofundeal(const char* value, size_t size);
  inline ::std::string* mutable_positionofundeal();
  inline ::std::string* release_positionofundeal();
  
  // optional string MaxPurRedemNum = 11;
  inline bool has_maxpurredemnum() const;
  inline void clear_maxpurredemnum();
  static const int kMaxPurRedemNumFieldNumber = 11;
  inline const ::std::string& maxpurredemnum() const;
  inline void set_maxpurredemnum(const ::std::string& value);
  inline void set_maxpurredemnum(const char* value);
  inline void set_maxpurredemnum(const char* value, size_t size);
  inline ::std::string* mutable_maxpurredemnum();
  inline ::std::string* release_maxpurredemnum();
  
  // @@protoc_insertion_point(class_scope:INF_QueryETFdynamicInfo_Ack)
 private:
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_etfcode();
  inline void clear_has_etfcode();
  inline void set_has_validpurredemnum();
  inline void clear_has_validpurredemnum();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_etfname();
  inline void clear_has_etfname();
  inline void set_has_baskeasknum();
  inline void clear_has_baskeasknum();
  inline void set_has_needbuynum();
  inline void clear_has_needbuynum();
  inline void set_has_canreplacefund();
  inline void clear_has_canreplacefund();
  inline void set_has_mustreplacefund();
  inline void clear_has_mustreplacefund();
  inline void set_has_positionofundeal();
  inline void clear_has_positionofundeal();
  inline void set_has_maxpurredemnum();
  inline void clear_has_maxpurredemnum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* marketid_;
  ::std::string* etfcode_;
  ::std::string* validpurredemnum_;
  ::std::string* respflag_;
  ::std::string* etfname_;
  ::std::string* baskeasknum_;
  ::std::string* needbuynum_;
  ::std::string* canreplacefund_;
  ::std::string* mustreplacefund_;
  ::std::string* positionofundeal_;
  ::std::string* maxpurredemnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryETFdynamicInfo_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryFundCondition_Ack : public ::google::protobuf::Message {
 public:
  INF_QueryFundCondition_Ack();
  virtual ~INF_QueryFundCondition_Ack();
  
  INF_QueryFundCondition_Ack(const INF_QueryFundCondition_Ack& from);
  
  inline INF_QueryFundCondition_Ack& operator=(const INF_QueryFundCondition_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryFundCondition_Ack& default_instance();
  
  void Swap(INF_QueryFundCondition_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryFundCondition_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryFundCondition_Ack& from);
  void MergeFrom(const INF_QueryFundCondition_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Valid = 1;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 1;
  inline const ::std::string& valid() const;
  inline void set_valid(const ::std::string& value);
  inline void set_valid(const char* value);
  inline void set_valid(const char* value, size_t size);
  inline ::std::string* mutable_valid();
  inline ::std::string* release_valid();
  
  // optional string FundRemain = 2;
  inline bool has_fundremain() const;
  inline void clear_fundremain();
  static const int kFundRemainFieldNumber = 2;
  inline const ::std::string& fundremain() const;
  inline void set_fundremain(const ::std::string& value);
  inline void set_fundremain(const char* value);
  inline void set_fundremain(const char* value, size_t size);
  inline ::std::string* mutable_fundremain();
  inline ::std::string* release_fundremain();
  
  // optional string Validfund = 3;
  inline bool has_validfund() const;
  inline void clear_validfund();
  static const int kValidfundFieldNumber = 3;
  inline const ::std::string& validfund() const;
  inline void set_validfund(const ::std::string& value);
  inline void set_validfund(const char* value);
  inline void set_validfund(const char* value, size_t size);
  inline ::std::string* mutable_validfund();
  inline ::std::string* release_validfund();
  
  // optional string MarketValue = 4;
  inline bool has_marketvalue() const;
  inline void clear_marketvalue();
  static const int kMarketValueFieldNumber = 4;
  inline const ::std::string& marketvalue() const;
  inline void set_marketvalue(const ::std::string& value);
  inline void set_marketvalue(const char* value);
  inline void set_marketvalue(const char* value, size_t size);
  inline ::std::string* mutable_marketvalue();
  inline ::std::string* release_marketvalue();
  
  // optional string RespFlag = 5;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 5;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string IsSuccess = 6;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 6;
  inline const ::std::string& issuccess() const;
  inline void set_issuccess(const ::std::string& value);
  inline void set_issuccess(const char* value);
  inline void set_issuccess(const char* value, size_t size);
  inline ::std::string* mutable_issuccess();
  inline ::std::string* release_issuccess();
  
  // optional string FundSum = 7;
  inline bool has_fundsum() const;
  inline void clear_fundsum();
  static const int kFundSumFieldNumber = 7;
  inline const ::std::string& fundsum() const;
  inline void set_fundsum(const ::std::string& value);
  inline void set_fundsum(const char* value);
  inline void set_fundsum(const char* value, size_t size);
  inline ::std::string* mutable_fundsum();
  inline ::std::string* release_fundsum();
  
  // optional string TodayBuyCj = 8;
  inline bool has_todaybuycj() const;
  inline void clear_todaybuycj();
  static const int kTodayBuyCjFieldNumber = 8;
  inline const ::std::string& todaybuycj() const;
  inline void set_todaybuycj(const ::std::string& value);
  inline void set_todaybuycj(const char* value);
  inline void set_todaybuycj(const char* value, size_t size);
  inline ::std::string* mutable_todaybuycj();
  inline ::std::string* release_todaybuycj();
  
  // optional string TodaySellCj = 9;
  inline bool has_todaysellcj() const;
  inline void clear_todaysellcj();
  static const int kTodaySellCjFieldNumber = 9;
  inline const ::std::string& todaysellcj() const;
  inline void set_todaysellcj(const ::std::string& value);
  inline void set_todaysellcj(const char* value);
  inline void set_todaysellcj(const char* value, size_t size);
  inline ::std::string* mutable_todaysellcj();
  inline ::std::string* release_todaysellcj();
  
  // optional string SumFloatProfitLoss = 10;
  inline bool has_sumfloatprofitloss() const;
  inline void clear_sumfloatprofitloss();
  static const int kSumFloatProfitLossFieldNumber = 10;
  inline const ::std::string& sumfloatprofitloss() const;
  inline void set_sumfloatprofitloss(const ::std::string& value);
  inline void set_sumfloatprofitloss(const char* value);
  inline void set_sumfloatprofitloss(const char* value, size_t size);
  inline ::std::string* mutable_sumfloatprofitloss();
  inline ::std::string* release_sumfloatprofitloss();
  
  // optional string FundOfTodayBuyUndeal = 11;
  inline bool has_fundoftodaybuyundeal() const;
  inline void clear_fundoftodaybuyundeal();
  static const int kFundOfTodayBuyUndealFieldNumber = 11;
  inline const ::std::string& fundoftodaybuyundeal() const;
  inline void set_fundoftodaybuyundeal(const ::std::string& value);
  inline void set_fundoftodaybuyundeal(const char* value);
  inline void set_fundoftodaybuyundeal(const char* value, size_t size);
  inline ::std::string* mutable_fundoftodaybuyundeal();
  inline ::std::string* release_fundoftodaybuyundeal();
  
  // optional string FundOfBuyUnsettled = 12;
  inline bool has_fundofbuyunsettled() const;
  inline void clear_fundofbuyunsettled();
  static const int kFundOfBuyUnsettledFieldNumber = 12;
  inline const ::std::string& fundofbuyunsettled() const;
  inline void set_fundofbuyunsettled(const ::std::string& value);
  inline void set_fundofbuyunsettled(const char* value);
  inline void set_fundofbuyunsettled(const char* value, size_t size);
  inline ::std::string* mutable_fundofbuyunsettled();
  inline ::std::string* release_fundofbuyunsettled();
  
  // optional string FundOfSellUnsettled = 13;
  inline bool has_fundofsellunsettled() const;
  inline void clear_fundofsellunsettled();
  static const int kFundOfSellUnsettledFieldNumber = 13;
  inline const ::std::string& fundofsellunsettled() const;
  inline void set_fundofsellunsettled(const ::std::string& value);
  inline void set_fundofsellunsettled(const char* value);
  inline void set_fundofsellunsettled(const char* value, size_t size);
  inline ::std::string* mutable_fundofsellunsettled();
  inline ::std::string* release_fundofsellunsettled();
  
  // optional string MoneyName = 14;
  inline bool has_moneyname() const;
  inline void clear_moneyname();
  static const int kMoneyNameFieldNumber = 14;
  inline const ::std::string& moneyname() const;
  inline void set_moneyname(const ::std::string& value);
  inline void set_moneyname(const char* value);
  inline void set_moneyname(const char* value, size_t size);
  inline ::std::string* mutable_moneyname();
  inline ::std::string* release_moneyname();
  
  // optional string FundOfExceptLock = 15;
  inline bool has_fundofexceptlock() const;
  inline void clear_fundofexceptlock();
  static const int kFundOfExceptLockFieldNumber = 15;
  inline const ::std::string& fundofexceptlock() const;
  inline void set_fundofexceptlock(const ::std::string& value);
  inline void set_fundofexceptlock(const char* value);
  inline void set_fundofexceptlock(const char* value, size_t size);
  inline ::std::string* mutable_fundofexceptlock();
  inline ::std::string* release_fundofexceptlock();
  
  // optional string MoneyID = 16;
  inline bool has_moneyid() const;
  inline void clear_moneyid();
  static const int kMoneyIDFieldNumber = 16;
  inline const ::std::string& moneyid() const;
  inline void set_moneyid(const ::std::string& value);
  inline void set_moneyid(const char* value);
  inline void set_moneyid(const char* value, size_t size);
  inline ::std::string* mutable_moneyid();
  inline ::std::string* release_moneyid();
  
  // optional string PositionRate = 17;
  inline bool has_positionrate() const;
  inline void clear_positionrate();
  static const int kPositionRateFieldNumber = 17;
  inline const ::std::string& positionrate() const;
  inline void set_positionrate(const ::std::string& value);
  inline void set_positionrate(const char* value);
  inline void set_positionrate(const char* value, size_t size);
  inline ::std::string* mutable_positionrate();
  inline ::std::string* release_positionrate();
  
  // optional string NetAssets = 18;
  inline bool has_netassets() const;
  inline void clear_netassets();
  static const int kNetAssetsFieldNumber = 18;
  inline const ::std::string& netassets() const;
  inline void set_netassets(const ::std::string& value);
  inline void set_netassets(const char* value);
  inline void set_netassets(const char* value, size_t size);
  inline ::std::string* mutable_netassets();
  inline ::std::string* release_netassets();
  
  // @@protoc_insertion_point(class_scope:INF_QueryFundCondition_Ack)
 private:
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_fundremain();
  inline void clear_has_fundremain();
  inline void set_has_validfund();
  inline void clear_has_validfund();
  inline void set_has_marketvalue();
  inline void clear_has_marketvalue();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_issuccess();
  inline void clear_has_issuccess();
  inline void set_has_fundsum();
  inline void clear_has_fundsum();
  inline void set_has_todaybuycj();
  inline void clear_has_todaybuycj();
  inline void set_has_todaysellcj();
  inline void clear_has_todaysellcj();
  inline void set_has_sumfloatprofitloss();
  inline void clear_has_sumfloatprofitloss();
  inline void set_has_fundoftodaybuyundeal();
  inline void clear_has_fundoftodaybuyundeal();
  inline void set_has_fundofbuyunsettled();
  inline void clear_has_fundofbuyunsettled();
  inline void set_has_fundofsellunsettled();
  inline void clear_has_fundofsellunsettled();
  inline void set_has_moneyname();
  inline void clear_has_moneyname();
  inline void set_has_fundofexceptlock();
  inline void clear_has_fundofexceptlock();
  inline void set_has_moneyid();
  inline void clear_has_moneyid();
  inline void set_has_positionrate();
  inline void clear_has_positionrate();
  inline void set_has_netassets();
  inline void clear_has_netassets();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* valid_;
  ::std::string* fundremain_;
  ::std::string* validfund_;
  ::std::string* marketvalue_;
  ::std::string* respflag_;
  ::std::string* issuccess_;
  ::std::string* fundsum_;
  ::std::string* todaybuycj_;
  ::std::string* todaysellcj_;
  ::std::string* sumfloatprofitloss_;
  ::std::string* fundoftodaybuyundeal_;
  ::std::string* fundofbuyunsettled_;
  ::std::string* fundofsellunsettled_;
  ::std::string* moneyname_;
  ::std::string* fundofexceptlock_;
  ::std::string* moneyid_;
  ::std::string* positionrate_;
  ::std::string* netassets_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryFundCondition_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryPosition_Ack : public ::google::protobuf::Message {
 public:
  INF_QueryPosition_Ack();
  virtual ~INF_QueryPosition_Ack();
  
  INF_QueryPosition_Ack(const INF_QueryPosition_Ack& from);
  
  inline INF_QueryPosition_Ack& operator=(const INF_QueryPosition_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryPosition_Ack& default_instance();
  
  void Swap(INF_QueryPosition_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryPosition_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryPosition_Ack& from);
  void MergeFrom(const INF_QueryPosition_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string MarketID = 1;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 1;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string SecurityCode = 2;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 2;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string SecurityName = 3;
  inline bool has_securityname() const;
  inline void clear_securityname();
  static const int kSecurityNameFieldNumber = 3;
  inline const ::std::string& securityname() const;
  inline void set_securityname(const ::std::string& value);
  inline void set_securityname(const char* value);
  inline void set_securityname(const char* value, size_t size);
  inline ::std::string* mutable_securityname();
  inline ::std::string* release_securityname();
  
  // optional string SecurityNum = 4;
  inline bool has_securitynum() const;
  inline void clear_securitynum();
  static const int kSecurityNumFieldNumber = 4;
  inline const ::std::string& securitynum() const;
  inline void set_securitynum(const ::std::string& value);
  inline void set_securitynum(const char* value);
  inline void set_securitynum(const char* value, size_t size);
  inline ::std::string* mutable_securitynum();
  inline ::std::string* release_securitynum();
  
  // optional string MarketValue = 5;
  inline bool has_marketvalue() const;
  inline void clear_marketvalue();
  static const int kMarketValueFieldNumber = 5;
  inline const ::std::string& marketvalue() const;
  inline void set_marketvalue(const ::std::string& value);
  inline void set_marketvalue(const char* value);
  inline void set_marketvalue(const char* value, size_t size);
  inline ::std::string* mutable_marketvalue();
  inline ::std::string* release_marketvalue();
  
  // optional string CostPrice = 6;
  inline bool has_costprice() const;
  inline void clear_costprice();
  static const int kCostPriceFieldNumber = 6;
  inline const ::std::string& costprice() const;
  inline void set_costprice(const ::std::string& value);
  inline void set_costprice(const char* value);
  inline void set_costprice(const char* value, size_t size);
  inline ::std::string* mutable_costprice();
  inline ::std::string* release_costprice();
  
  // optional string YesterdayPosition = 7;
  inline bool has_yesterdayposition() const;
  inline void clear_yesterdayposition();
  static const int kYesterdayPositionFieldNumber = 7;
  inline const ::std::string& yesterdayposition() const;
  inline void set_yesterdayposition(const ::std::string& value);
  inline void set_yesterdayposition(const char* value);
  inline void set_yesterdayposition(const char* value, size_t size);
  inline ::std::string* mutable_yesterdayposition();
  inline ::std::string* release_yesterdayposition();
  
  // optional string ValidSecurityNum = 8;
  inline bool has_validsecuritynum() const;
  inline void clear_validsecuritynum();
  static const int kValidSecurityNumFieldNumber = 8;
  inline const ::std::string& validsecuritynum() const;
  inline void set_validsecuritynum(const ::std::string& value);
  inline void set_validsecuritynum(const char* value);
  inline void set_validsecuritynum(const char* value, size_t size);
  inline ::std::string* mutable_validsecuritynum();
  inline ::std::string* release_validsecuritynum();
  
  // optional string RespFlag = 9;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 9;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string StockholderAccount = 10;
  inline bool has_stockholderaccount() const;
  inline void clear_stockholderaccount();
  static const int kStockholderAccountFieldNumber = 10;
  inline const ::std::string& stockholderaccount() const;
  inline void set_stockholderaccount(const ::std::string& value);
  inline void set_stockholderaccount(const char* value);
  inline void set_stockholderaccount(const char* value, size_t size);
  inline ::std::string* mutable_stockholderaccount();
  inline ::std::string* release_stockholderaccount();
  
  // optional string FloatProfitLoss = 11;
  inline bool has_floatprofitloss() const;
  inline void clear_floatprofitloss();
  static const int kFloatProfitLossFieldNumber = 11;
  inline const ::std::string& floatprofitloss() const;
  inline void set_floatprofitloss(const ::std::string& value);
  inline void set_floatprofitloss(const char* value);
  inline void set_floatprofitloss(const char* value, size_t size);
  inline ::std::string* mutable_floatprofitloss();
  inline ::std::string* release_floatprofitloss();
  
  // optional string LastestPrice = 12;
  inline bool has_lastestprice() const;
  inline void clear_lastestprice();
  static const int kLastestPriceFieldNumber = 12;
  inline const ::std::string& lastestprice() const;
  inline void set_lastestprice(const ::std::string& value);
  inline void set_lastestprice(const char* value);
  inline void set_lastestprice(const char* value, size_t size);
  inline ::std::string* mutable_lastestprice();
  inline ::std::string* release_lastestprice();
  
  // optional string StockMarketValue = 13;
  inline bool has_stockmarketvalue() const;
  inline void clear_stockmarketvalue();
  static const int kStockMarketValueFieldNumber = 13;
  inline const ::std::string& stockmarketvalue() const;
  inline void set_stockmarketvalue(const ::std::string& value);
  inline void set_stockmarketvalue(const char* value);
  inline void set_stockmarketvalue(const char* value, size_t size);
  inline ::std::string* mutable_stockmarketvalue();
  inline ::std::string* release_stockmarketvalue();
  
  // optional string CommentDate = 14;
  inline bool has_commentdate() const;
  inline void clear_commentdate();
  static const int kCommentDateFieldNumber = 14;
  inline const ::std::string& commentdate() const;
  inline void set_commentdate(const ::std::string& value);
  inline void set_commentdate(const char* value);
  inline void set_commentdate(const char* value, size_t size);
  inline ::std::string* mutable_commentdate();
  inline ::std::string* release_commentdate();
  
  // optional string SentenceCommentMsg = 15;
  inline bool has_sentencecommentmsg() const;
  inline void clear_sentencecommentmsg();
  static const int kSentenceCommentMsgFieldNumber = 15;
  inline const ::std::string& sentencecommentmsg() const;
  inline void set_sentencecommentmsg(const ::std::string& value);
  inline void set_sentencecommentmsg(const char* value);
  inline void set_sentencecommentmsg(const char* value, size_t size);
  inline ::std::string* mutable_sentencecommentmsg();
  inline ::std::string* release_sentencecommentmsg();
  
  // optional string NationalDebtNetPrice = 16;
  inline bool has_nationaldebtnetprice() const;
  inline void clear_nationaldebtnetprice();
  static const int kNationalDebtNetPriceFieldNumber = 16;
  inline const ::std::string& nationaldebtnetprice() const;
  inline void set_nationaldebtnetprice(const ::std::string& value);
  inline void set_nationaldebtnetprice(const char* value);
  inline void set_nationaldebtnetprice(const char* value, size_t size);
  inline ::std::string* mutable_nationaldebtnetprice();
  inline ::std::string* release_nationaldebtnetprice();
  
  // optional string Interest = 17;
  inline bool has_interest() const;
  inline void clear_interest();
  static const int kInterestFieldNumber = 17;
  inline const ::std::string& interest() const;
  inline void set_interest(const ::std::string& value);
  inline void set_interest(const char* value);
  inline void set_interest(const char* value, size_t size);
  inline ::std::string* mutable_interest();
  inline ::std::string* release_interest();
  
  // optional string AverageBuyPrice = 18;
  inline bool has_averagebuyprice() const;
  inline void clear_averagebuyprice();
  static const int kAverageBuyPriceFieldNumber = 18;
  inline const ::std::string& averagebuyprice() const;
  inline void set_averagebuyprice(const ::std::string& value);
  inline void set_averagebuyprice(const char* value);
  inline void set_averagebuyprice(const char* value, size_t size);
  inline ::std::string* mutable_averagebuyprice();
  inline ::std::string* release_averagebuyprice();
  
  // optional string LiquidCostPrice = 19;
  inline bool has_liquidcostprice() const;
  inline void clear_liquidcostprice();
  static const int kLiquidCostPriceFieldNumber = 19;
  inline const ::std::string& liquidcostprice() const;
  inline void set_liquidcostprice(const ::std::string& value);
  inline void set_liquidcostprice(const char* value);
  inline void set_liquidcostprice(const char* value, size_t size);
  inline ::std::string* mutable_liquidcostprice();
  inline ::std::string* release_liquidcostprice();
  
  // optional string BeginStock = 20;
  inline bool has_beginstock() const;
  inline void clear_beginstock();
  static const int kBeginStockFieldNumber = 20;
  inline const ::std::string& beginstock() const;
  inline void set_beginstock(const ::std::string& value);
  inline void set_beginstock(const char* value);
  inline void set_beginstock(const char* value, size_t size);
  inline ::std::string* mutable_beginstock();
  inline ::std::string* release_beginstock();
  
  // optional string OverPositionBalances = 21;
  inline bool has_overpositionbalances() const;
  inline void clear_overpositionbalances();
  static const int kOverPositionBalancesFieldNumber = 21;
  inline const ::std::string& overpositionbalances() const;
  inline void set_overpositionbalances(const ::std::string& value);
  inline void set_overpositionbalances(const char* value);
  inline void set_overpositionbalances(const char* value, size_t size);
  inline ::std::string* mutable_overpositionbalances();
  inline ::std::string* release_overpositionbalances();
  
  // @@protoc_insertion_point(class_scope:INF_QueryPosition_Ack)
 private:
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_securityname();
  inline void clear_has_securityname();
  inline void set_has_securitynum();
  inline void clear_has_securitynum();
  inline void set_has_marketvalue();
  inline void clear_has_marketvalue();
  inline void set_has_costprice();
  inline void clear_has_costprice();
  inline void set_has_yesterdayposition();
  inline void clear_has_yesterdayposition();
  inline void set_has_validsecuritynum();
  inline void clear_has_validsecuritynum();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_stockholderaccount();
  inline void clear_has_stockholderaccount();
  inline void set_has_floatprofitloss();
  inline void clear_has_floatprofitloss();
  inline void set_has_lastestprice();
  inline void clear_has_lastestprice();
  inline void set_has_stockmarketvalue();
  inline void clear_has_stockmarketvalue();
  inline void set_has_commentdate();
  inline void clear_has_commentdate();
  inline void set_has_sentencecommentmsg();
  inline void clear_has_sentencecommentmsg();
  inline void set_has_nationaldebtnetprice();
  inline void clear_has_nationaldebtnetprice();
  inline void set_has_interest();
  inline void clear_has_interest();
  inline void set_has_averagebuyprice();
  inline void clear_has_averagebuyprice();
  inline void set_has_liquidcostprice();
  inline void clear_has_liquidcostprice();
  inline void set_has_beginstock();
  inline void clear_has_beginstock();
  inline void set_has_overpositionbalances();
  inline void clear_has_overpositionbalances();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* marketid_;
  ::std::string* securitycode_;
  ::std::string* securityname_;
  ::std::string* securitynum_;
  ::std::string* marketvalue_;
  ::std::string* costprice_;
  ::std::string* yesterdayposition_;
  ::std::string* validsecuritynum_;
  ::std::string* respflag_;
  ::std::string* stockholderaccount_;
  ::std::string* floatprofitloss_;
  ::std::string* lastestprice_;
  ::std::string* stockmarketvalue_;
  ::std::string* commentdate_;
  ::std::string* sentencecommentmsg_;
  ::std::string* nationaldebtnetprice_;
  ::std::string* interest_;
  ::std::string* averagebuyprice_;
  ::std::string* liquidcostprice_;
  ::std::string* beginstock_;
  ::std::string* overpositionbalances_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryPosition_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_QueryCJMX_Ack : public ::google::protobuf::Message {
 public:
  INF_QueryCJMX_Ack();
  virtual ~INF_QueryCJMX_Ack();
  
  INF_QueryCJMX_Ack(const INF_QueryCJMX_Ack& from);
  
  inline INF_QueryCJMX_Ack& operator=(const INF_QueryCJMX_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_QueryCJMX_Ack& default_instance();
  
  void Swap(INF_QueryCJMX_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_QueryCJMX_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_QueryCJMX_Ack& from);
  void MergeFrom(const INF_QueryCJMX_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string MarketID = 1;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 1;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string BSflag = 2;
  inline bool has_bsflag() const;
  inline void clear_bsflag();
  static const int kBSflagFieldNumber = 2;
  inline const ::std::string& bsflag() const;
  inline void set_bsflag(const ::std::string& value);
  inline void set_bsflag(const char* value);
  inline void set_bsflag(const char* value, size_t size);
  inline ::std::string* mutable_bsflag();
  inline ::std::string* release_bsflag();
  
  // optional string CjType = 3;
  inline bool has_cjtype() const;
  inline void clear_cjtype();
  static const int kCjTypeFieldNumber = 3;
  inline const ::std::string& cjtype() const;
  inline void set_cjtype(const ::std::string& value);
  inline void set_cjtype(const char* value);
  inline void set_cjtype(const char* value, size_t size);
  inline ::std::string* mutable_cjtype();
  inline ::std::string* release_cjtype();
  
  // optional string SecurityCode = 4;
  inline bool has_securitycode() const;
  inline void clear_securitycode();
  static const int kSecurityCodeFieldNumber = 4;
  inline const ::std::string& securitycode() const;
  inline void set_securitycode(const ::std::string& value);
  inline void set_securitycode(const char* value);
  inline void set_securitycode(const char* value, size_t size);
  inline ::std::string* mutable_securitycode();
  inline ::std::string* release_securitycode();
  
  // optional string SecurityName = 5;
  inline bool has_securityname() const;
  inline void clear_securityname();
  static const int kSecurityNameFieldNumber = 5;
  inline const ::std::string& securityname() const;
  inline void set_securityname(const ::std::string& value);
  inline void set_securityname(const char* value);
  inline void set_securityname(const char* value, size_t size);
  inline ::std::string* mutable_securityname();
  inline ::std::string* release_securityname();
  
  // optional string CjNum = 6;
  inline bool has_cjnum() const;
  inline void clear_cjnum();
  static const int kCjNumFieldNumber = 6;
  inline const ::std::string& cjnum() const;
  inline void set_cjnum(const ::std::string& value);
  inline void set_cjnum(const char* value);
  inline void set_cjnum(const char* value, size_t size);
  inline ::std::string* mutable_cjnum();
  inline ::std::string* release_cjnum();
  
  // optional string CjPrice = 7;
  inline bool has_cjprice() const;
  inline void clear_cjprice();
  static const int kCjPriceFieldNumber = 7;
  inline const ::std::string& cjprice() const;
  inline void set_cjprice(const ::std::string& value);
  inline void set_cjprice(const char* value);
  inline void set_cjprice(const char* value, size_t size);
  inline ::std::string* mutable_cjprice();
  inline ::std::string* release_cjprice();
  
  // optional string CjFund = 8;
  inline bool has_cjfund() const;
  inline void clear_cjfund();
  static const int kCjFundFieldNumber = 8;
  inline const ::std::string& cjfund() const;
  inline void set_cjfund(const ::std::string& value);
  inline void set_cjfund(const char* value);
  inline void set_cjfund(const char* value, size_t size);
  inline ::std::string* mutable_cjfund();
  inline ::std::string* release_cjfund();
  
  // optional string EntrustSerial = 9;
  inline bool has_entrustserial() const;
  inline void clear_entrustserial();
  static const int kEntrustSerialFieldNumber = 9;
  inline const ::std::string& entrustserial() const;
  inline void set_entrustserial(const ::std::string& value);
  inline void set_entrustserial(const char* value);
  inline void set_entrustserial(const char* value, size_t size);
  inline ::std::string* mutable_entrustserial();
  inline ::std::string* release_entrustserial();
  
  // optional string CjDate = 10;
  inline bool has_cjdate() const;
  inline void clear_cjdate();
  static const int kCjDateFieldNumber = 10;
  inline const ::std::string& cjdate() const;
  inline void set_cjdate(const ::std::string& value);
  inline void set_cjdate(const char* value);
  inline void set_cjdate(const char* value, size_t size);
  inline ::std::string* mutable_cjdate();
  inline ::std::string* release_cjdate();
  
  // optional string PageStartPos = 11;
  inline bool has_pagestartpos() const;
  inline void clear_pagestartpos();
  static const int kPageStartPosFieldNumber = 11;
  inline const ::std::string& pagestartpos() const;
  inline void set_pagestartpos(const ::std::string& value);
  inline void set_pagestartpos(const char* value);
  inline void set_pagestartpos(const char* value, size_t size);
  inline ::std::string* mutable_pagestartpos();
  inline ::std::string* release_pagestartpos();
  
  // optional string CjSerial = 12;
  inline bool has_cjserial() const;
  inline void clear_cjserial();
  static const int kCjSerialFieldNumber = 12;
  inline const ::std::string& cjserial() const;
  inline void set_cjserial(const ::std::string& value);
  inline void set_cjserial(const char* value);
  inline void set_cjserial(const char* value, size_t size);
  inline ::std::string* mutable_cjserial();
  inline ::std::string* release_cjserial();
  
  // optional string Valid = 13;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 13;
  inline const ::std::string& valid() const;
  inline void set_valid(const ::std::string& value);
  inline void set_valid(const char* value);
  inline void set_valid(const char* value, size_t size);
  inline ::std::string* mutable_valid();
  inline ::std::string* release_valid();
  
  // optional string RespFlag = 14;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 14;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string Date = 15;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 15;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  
  // optional string SerialNo = 16;
  inline bool has_serialno() const;
  inline void clear_serialno();
  static const int kSerialNoFieldNumber = 16;
  inline const ::std::string& serialno() const;
  inline void set_serialno(const ::std::string& value);
  inline void set_serialno(const char* value);
  inline void set_serialno(const char* value, size_t size);
  inline ::std::string* mutable_serialno();
  inline ::std::string* release_serialno();
  
  // optional string StockholderAccount = 17;
  inline bool has_stockholderaccount() const;
  inline void clear_stockholderaccount();
  static const int kStockholderAccountFieldNumber = 17;
  inline const ::std::string& stockholderaccount() const;
  inline void set_stockholderaccount(const ::std::string& value);
  inline void set_stockholderaccount(const char* value);
  inline void set_stockholderaccount(const char* value, size_t size);
  inline ::std::string* mutable_stockholderaccount();
  inline ::std::string* release_stockholderaccount();
  
  // optional string BSName = 18;
  inline bool has_bsname() const;
  inline void clear_bsname();
  static const int kBSNameFieldNumber = 18;
  inline const ::std::string& bsname() const;
  inline void set_bsname(const ::std::string& value);
  inline void set_bsname(const char* value);
  inline void set_bsname(const char* value, size_t size);
  inline ::std::string* mutable_bsname();
  inline ::std::string* release_bsname();
  
  // optional string CjTypeName = 19;
  inline bool has_cjtypename() const;
  inline void clear_cjtypename();
  static const int kCjTypeNameFieldNumber = 19;
  inline const ::std::string& cjtypename() const;
  inline void set_cjtypename(const ::std::string& value);
  inline void set_cjtypename(const char* value);
  inline void set_cjtypename(const char* value, size_t size);
  inline ::std::string* mutable_cjtypename();
  inline ::std::string* release_cjtypename();
  
  // optional string CjPenNum = 20;
  inline bool has_cjpennum() const;
  inline void clear_cjpennum();
  static const int kCjPenNumFieldNumber = 20;
  inline const ::std::string& cjpennum() const;
  inline void set_cjpennum(const ::std::string& value);
  inline void set_cjpennum(const char* value);
  inline void set_cjpennum(const char* value, size_t size);
  inline ::std::string* mutable_cjpennum();
  inline ::std::string* release_cjpennum();
  
  // optional string EntrustType = 21;
  inline bool has_entrusttype() const;
  inline void clear_entrusttype();
  static const int kEntrustTypeFieldNumber = 21;
  inline const ::std::string& entrusttype() const;
  inline void set_entrusttype(const ::std::string& value);
  inline void set_entrusttype(const char* value);
  inline void set_entrusttype(const char* value, size_t size);
  inline ::std::string* mutable_entrusttype();
  inline ::std::string* release_entrusttype();
  
  // optional string DeclareNo = 22;
  inline bool has_declareno() const;
  inline void clear_declareno();
  static const int kDeclareNoFieldNumber = 22;
  inline const ::std::string& declareno() const;
  inline void set_declareno(const ::std::string& value);
  inline void set_declareno(const char* value);
  inline void set_declareno(const char* value, size_t size);
  inline ::std::string* mutable_declareno();
  inline ::std::string* release_declareno();
  
  // @@protoc_insertion_point(class_scope:INF_QueryCJMX_Ack)
 private:
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_bsflag();
  inline void clear_has_bsflag();
  inline void set_has_cjtype();
  inline void clear_has_cjtype();
  inline void set_has_securitycode();
  inline void clear_has_securitycode();
  inline void set_has_securityname();
  inline void clear_has_securityname();
  inline void set_has_cjnum();
  inline void clear_has_cjnum();
  inline void set_has_cjprice();
  inline void clear_has_cjprice();
  inline void set_has_cjfund();
  inline void clear_has_cjfund();
  inline void set_has_entrustserial();
  inline void clear_has_entrustserial();
  inline void set_has_cjdate();
  inline void clear_has_cjdate();
  inline void set_has_pagestartpos();
  inline void clear_has_pagestartpos();
  inline void set_has_cjserial();
  inline void clear_has_cjserial();
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_serialno();
  inline void clear_has_serialno();
  inline void set_has_stockholderaccount();
  inline void clear_has_stockholderaccount();
  inline void set_has_bsname();
  inline void clear_has_bsname();
  inline void set_has_cjtypename();
  inline void clear_has_cjtypename();
  inline void set_has_cjpennum();
  inline void clear_has_cjpennum();
  inline void set_has_entrusttype();
  inline void clear_has_entrusttype();
  inline void set_has_declareno();
  inline void clear_has_declareno();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* marketid_;
  ::std::string* bsflag_;
  ::std::string* cjtype_;
  ::std::string* securitycode_;
  ::std::string* securityname_;
  ::std::string* cjnum_;
  ::std::string* cjprice_;
  ::std::string* cjfund_;
  ::std::string* entrustserial_;
  ::std::string* cjdate_;
  ::std::string* pagestartpos_;
  ::std::string* cjserial_;
  ::std::string* valid_;
  ::std::string* respflag_;
  ::std::string* date_;
  ::std::string* serialno_;
  ::std::string* stockholderaccount_;
  ::std::string* bsname_;
  ::std::string* cjtypename_;
  ::std::string* cjpennum_;
  ::std::string* entrusttype_;
  ::std::string* declareno_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_QueryCJMX_Ack* default_instance_;
};
// -------------------------------------------------------------------

class INF_ETFPurRedem_Ack : public ::google::protobuf::Message {
 public:
  INF_ETFPurRedem_Ack();
  virtual ~INF_ETFPurRedem_Ack();
  
  INF_ETFPurRedem_Ack(const INF_ETFPurRedem_Ack& from);
  
  inline INF_ETFPurRedem_Ack& operator=(const INF_ETFPurRedem_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_ETFPurRedem_Ack& default_instance();
  
  void Swap(INF_ETFPurRedem_Ack* other);
  
  // implements Message ----------------------------------------------
  
  INF_ETFPurRedem_Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_ETFPurRedem_Ack& from);
  void MergeFrom(const INF_ETFPurRedem_Ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string EntrustSerial = 1;
  inline bool has_entrustserial() const;
  inline void clear_entrustserial();
  static const int kEntrustSerialFieldNumber = 1;
  inline const ::std::string& entrustserial() const;
  inline void set_entrustserial(const ::std::string& value);
  inline void set_entrustserial(const char* value);
  inline void set_entrustserial(const char* value, size_t size);
  inline ::std::string* mutable_entrustserial();
  inline ::std::string* release_entrustserial();
  
  // optional string Valid = 2;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 2;
  inline const ::std::string& valid() const;
  inline void set_valid(const ::std::string& value);
  inline void set_valid(const char* value);
  inline void set_valid(const char* value, size_t size);
  inline ::std::string* mutable_valid();
  inline ::std::string* release_valid();
  
  // optional string RespFlag = 3;
  inline bool has_respflag() const;
  inline void clear_respflag();
  static const int kRespFlagFieldNumber = 3;
  inline const ::std::string& respflag() const;
  inline void set_respflag(const ::std::string& value);
  inline void set_respflag(const char* value);
  inline void set_respflag(const char* value, size_t size);
  inline ::std::string* mutable_respflag();
  inline ::std::string* release_respflag();
  
  // optional string IsSuccess = 4;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 4;
  inline const ::std::string& issuccess() const;
  inline void set_issuccess(const ::std::string& value);
  inline void set_issuccess(const char* value);
  inline void set_issuccess(const char* value, size_t size);
  inline ::std::string* mutable_issuccess();
  inline ::std::string* release_issuccess();
  
  // @@protoc_insertion_point(class_scope:INF_ETFPurRedem_Ack)
 private:
  inline void set_has_entrustserial();
  inline void clear_has_entrustserial();
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_respflag();
  inline void clear_has_respflag();
  inline void set_has_issuccess();
  inline void clear_has_issuccess();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* entrustserial_;
  ::std::string* valid_;
  ::std::string* respflag_;
  ::std::string* issuccess_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_ETFPurRedem_Ack* default_instance_;
};
// -------------------------------------------------------------------

class StockLoginResp : public ::google::protobuf::Message {
 public:
  StockLoginResp();
  virtual ~StockLoginResp();
  
  StockLoginResp(const StockLoginResp& from);
  
  inline StockLoginResp& operator=(const StockLoginResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StockLoginResp& default_instance();
  
  void Swap(StockLoginResp* other);
  
  // implements Message ----------------------------------------------
  
  StockLoginResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StockLoginResp& from);
  void MergeFrom(const StockLoginResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 funcid = 1 [default = 11100001];
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncidFieldNumber = 1;
  inline ::google::protobuf::int32 funcid() const;
  inline void set_funcid(::google::protobuf::int32 value);
  
  // required string fund_account = 2;
  inline bool has_fund_account() const;
  inline void clear_fund_account();
  static const int kFundAccountFieldNumber = 2;
  inline const ::std::string& fund_account() const;
  inline void set_fund_account(const ::std::string& value);
  inline void set_fund_account(const char* value);
  inline void set_fund_account(const char* value, size_t size);
  inline ::std::string* mutable_fund_account();
  inline ::std::string* release_fund_account();
  
  // @@protoc_insertion_point(class_scope:StockLoginResp)
 private:
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_fund_account();
  inline void clear_has_fund_account();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* fund_account_;
  ::google::protobuf::int32 funcid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static StockLoginResp* default_instance_;
};
// -------------------------------------------------------------------

class ACCOUNT_INFO : public ::google::protobuf::Message {
 public:
  ACCOUNT_INFO();
  virtual ~ACCOUNT_INFO();
  
  ACCOUNT_INFO(const ACCOUNT_INFO& from);
  
  inline ACCOUNT_INFO& operator=(const ACCOUNT_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ACCOUNT_INFO& default_instance();
  
  void Swap(ACCOUNT_INFO* other);
  
  // implements Message ----------------------------------------------
  
  ACCOUNT_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACCOUNT_INFO& from);
  void MergeFrom(const ACCOUNT_INFO& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double acc_ava = 1;
  inline bool has_acc_ava() const;
  inline void clear_acc_ava();
  static const int kAccAvaFieldNumber = 1;
  inline double acc_ava() const;
  inline void set_acc_ava(double value);
  
  // optional double acc_prelock = 2;
  inline bool has_acc_prelock() const;
  inline void clear_acc_prelock();
  static const int kAccPrelockFieldNumber = 2;
  inline double acc_prelock() const;
  inline void set_acc_prelock(double value);
  
  // optional double acc_lock = 3;
  inline bool has_acc_lock() const;
  inline void clear_acc_lock();
  static const int kAccLockFieldNumber = 3;
  inline double acc_lock() const;
  inline void set_acc_lock(double value);
  
  // @@protoc_insertion_point(class_scope:ACCOUNT_INFO)
 private:
  inline void set_has_acc_ava();
  inline void clear_has_acc_ava();
  inline void set_has_acc_prelock();
  inline void clear_has_acc_prelock();
  inline void set_has_acc_lock();
  inline void clear_has_acc_lock();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double acc_ava_;
  double acc_prelock_;
  double acc_lock_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static ACCOUNT_INFO* default_instance_;
};
// -------------------------------------------------------------------

class STOCK_INFO : public ::google::protobuf::Message {
 public:
  STOCK_INFO();
  virtual ~STOCK_INFO();
  
  STOCK_INFO(const STOCK_INFO& from);
  
  inline STOCK_INFO& operator=(const STOCK_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const STOCK_INFO& default_instance();
  
  void Swap(STOCK_INFO* other);
  
  // implements Message ----------------------------------------------
  
  STOCK_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const STOCK_INFO& from);
  void MergeFrom(const STOCK_INFO& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string stk_code = 1;
  inline bool has_stk_code() const;
  inline void clear_stk_code();
  static const int kStkCodeFieldNumber = 1;
  inline const ::std::string& stk_code() const;
  inline void set_stk_code(const ::std::string& value);
  inline void set_stk_code(const char* value);
  inline void set_stk_code(const char* value, size_t size);
  inline ::std::string* mutable_stk_code();
  inline ::std::string* release_stk_code();
  
  // optional int64 stk_ava = 2;
  inline bool has_stk_ava() const;
  inline void clear_stk_ava();
  static const int kStkAvaFieldNumber = 2;
  inline ::google::protobuf::int64 stk_ava() const;
  inline void set_stk_ava(::google::protobuf::int64 value);
  
  // optional int64 stk_prelock = 3;
  inline bool has_stk_prelock() const;
  inline void clear_stk_prelock();
  static const int kStkPrelockFieldNumber = 3;
  inline ::google::protobuf::int64 stk_prelock() const;
  inline void set_stk_prelock(::google::protobuf::int64 value);
  
  // optional int64 stk_lock = 4;
  inline bool has_stk_lock() const;
  inline void clear_stk_lock();
  static const int kStkLockFieldNumber = 4;
  inline ::google::protobuf::int64 stk_lock() const;
  inline void set_stk_lock(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:STOCK_INFO)
 private:
  inline void set_has_stk_code();
  inline void clear_has_stk_code();
  inline void set_has_stk_ava();
  inline void clear_has_stk_ava();
  inline void set_has_stk_prelock();
  inline void clear_has_stk_prelock();
  inline void set_has_stk_lock();
  inline void clear_has_stk_lock();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* stk_code_;
  ::google::protobuf::int64 stk_ava_;
  ::google::protobuf::int64 stk_prelock_;
  ::google::protobuf::int64 stk_lock_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static STOCK_INFO* default_instance_;
};
// -------------------------------------------------------------------

class ETF_INFO : public ::google::protobuf::Message {
 public:
  ETF_INFO();
  virtual ~ETF_INFO();
  
  ETF_INFO(const ETF_INFO& from);
  
  inline ETF_INFO& operator=(const ETF_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ETF_INFO& default_instance();
  
  void Swap(ETF_INFO* other);
  
  // implements Message ----------------------------------------------
  
  ETF_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ETF_INFO& from);
  void MergeFrom(const ETF_INFO& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string etf_code = 1;
  inline bool has_etf_code() const;
  inline void clear_etf_code();
  static const int kEtfCodeFieldNumber = 1;
  inline const ::std::string& etf_code() const;
  inline void set_etf_code(const ::std::string& value);
  inline void set_etf_code(const char* value);
  inline void set_etf_code(const char* value, size_t size);
  inline ::std::string* mutable_etf_code();
  inline ::std::string* release_etf_code();
  
  // optional int64 etf_ava = 2;
  inline bool has_etf_ava() const;
  inline void clear_etf_ava();
  static const int kEtfAvaFieldNumber = 2;
  inline ::google::protobuf::int64 etf_ava() const;
  inline void set_etf_ava(::google::protobuf::int64 value);
  
  // optional int64 etf_prelock = 3;
  inline bool has_etf_prelock() const;
  inline void clear_etf_prelock();
  static const int kEtfPrelockFieldNumber = 3;
  inline ::google::protobuf::int64 etf_prelock() const;
  inline void set_etf_prelock(::google::protobuf::int64 value);
  
  // optional int64 etf_lock = 4;
  inline bool has_etf_lock() const;
  inline void clear_etf_lock();
  static const int kEtfLockFieldNumber = 4;
  inline ::google::protobuf::int64 etf_lock() const;
  inline void set_etf_lock(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:ETF_INFO)
 private:
  inline void set_has_etf_code();
  inline void clear_has_etf_code();
  inline void set_has_etf_ava();
  inline void clear_has_etf_ava();
  inline void set_has_etf_prelock();
  inline void clear_has_etf_prelock();
  inline void set_has_etf_lock();
  inline void clear_has_etf_lock();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* etf_code_;
  ::google::protobuf::int64 etf_ava_;
  ::google::protobuf::int64 etf_prelock_;
  ::google::protobuf::int64 etf_lock_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static ETF_INFO* default_instance_;
};
// -------------------------------------------------------------------

class LOGIN_REQ : public ::google::protobuf::Message {
 public:
  LOGIN_REQ();
  virtual ~LOGIN_REQ();
  
  LOGIN_REQ(const LOGIN_REQ& from);
  
  inline LOGIN_REQ& operator=(const LOGIN_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LOGIN_REQ& default_instance();
  
  void Swap(LOGIN_REQ* other);
  
  // implements Message ----------------------------------------------
  
  LOGIN_REQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LOGIN_REQ& from);
  void MergeFrom(const LOGIN_REQ& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 funcid = 1 [default = 13000001];
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncidFieldNumber = 1;
  inline ::google::protobuf::int32 funcid() const;
  inline void set_funcid(::google::protobuf::int32 value);
  
  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:LOGIN_REQ)
 private:
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* password_;
  ::google::protobuf::int32 funcid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static LOGIN_REQ* default_instance_;
};
// -------------------------------------------------------------------

class LOGIN_ACK : public ::google::protobuf::Message {
 public:
  LOGIN_ACK();
  virtual ~LOGIN_ACK();
  
  LOGIN_ACK(const LOGIN_ACK& from);
  
  inline LOGIN_ACK& operator=(const LOGIN_ACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LOGIN_ACK& default_instance();
  
  void Swap(LOGIN_ACK* other);
  
  // implements Message ----------------------------------------------
  
  LOGIN_ACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LOGIN_ACK& from);
  void MergeFrom(const LOGIN_ACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 funcid = 1 [default = 13100001];
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncidFieldNumber = 1;
  inline ::google::protobuf::int32 funcid() const;
  inline void set_funcid(::google::protobuf::int32 value);
  
  // required string fund_account = 2;
  inline bool has_fund_account() const;
  inline void clear_fund_account();
  static const int kFundAccountFieldNumber = 2;
  inline const ::std::string& fund_account() const;
  inline void set_fund_account(const ::std::string& value);
  inline void set_fund_account(const char* value);
  inline void set_fund_account(const char* value, size_t size);
  inline ::std::string* mutable_fund_account();
  inline ::std::string* release_fund_account();
  
  // optional string sesstion_id = 3;
  inline bool has_sesstion_id() const;
  inline void clear_sesstion_id();
  static const int kSesstionIdFieldNumber = 3;
  inline const ::std::string& sesstion_id() const;
  inline void set_sesstion_id(const ::std::string& value);
  inline void set_sesstion_id(const char* value);
  inline void set_sesstion_id(const char* value, size_t size);
  inline ::std::string* mutable_sesstion_id();
  inline ::std::string* release_sesstion_id();
  
  // @@protoc_insertion_point(class_scope:LOGIN_ACK)
 private:
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_fund_account();
  inline void clear_has_fund_account();
  inline void set_has_sesstion_id();
  inline void clear_has_sesstion_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* fund_account_;
  ::std::string* sesstion_id_;
  ::google::protobuf::int32 funcid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static LOGIN_ACK* default_instance_;
};
// -------------------------------------------------------------------

class INF_Account : public ::google::protobuf::Message {
 public:
  INF_Account();
  virtual ~INF_Account();
  
  INF_Account(const INF_Account& from);
  
  inline INF_Account& operator=(const INF_Account& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_Account& default_instance();
  
  void Swap(INF_Account* other);
  
  // implements Message ----------------------------------------------
  
  INF_Account* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_Account& from);
  void MergeFrom(const INF_Account& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  
  // optional int32 query_update_flg = 2;
  inline bool has_query_update_flg() const;
  inline void clear_query_update_flg();
  static const int kQueryUpdateFlgFieldNumber = 2;
  inline ::google::protobuf::int32 query_update_flg() const;
  inline void set_query_update_flg(::google::protobuf::int32 value);
  
  // optional .ACCOUNT_INFO acc = 3;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 3;
  inline const ::ACCOUNT_INFO& acc() const;
  inline ::ACCOUNT_INFO* mutable_acc();
  inline ::ACCOUNT_INFO* release_acc();
  
  // optional .STOCK_INFO stk = 4;
  inline bool has_stk() const;
  inline void clear_stk();
  static const int kStkFieldNumber = 4;
  inline const ::STOCK_INFO& stk() const;
  inline ::STOCK_INFO* mutable_stk();
  inline ::STOCK_INFO* release_stk();
  
  // optional .ETF_INFO etf = 5;
  inline bool has_etf() const;
  inline void clear_etf();
  static const int kEtfFieldNumber = 5;
  inline const ::ETF_INFO& etf() const;
  inline ::ETF_INFO* mutable_etf();
  inline ::ETF_INFO* release_etf();
  
  // optional .LOGIN_ACK login_ack = 6;
  inline bool has_login_ack() const;
  inline void clear_login_ack();
  static const int kLoginAckFieldNumber = 6;
  inline const ::LOGIN_ACK& login_ack() const;
  inline ::LOGIN_ACK* mutable_login_ack();
  inline ::LOGIN_ACK* release_login_ack();
  
  // optional .LOGIN_REQ login_req = 7;
  inline bool has_login_req() const;
  inline void clear_login_req();
  static const int kLoginReqFieldNumber = 7;
  inline const ::LOGIN_REQ& login_req() const;
  inline ::LOGIN_REQ* mutable_login_req();
  inline ::LOGIN_REQ* release_login_req();
  
  // @@protoc_insertion_point(class_scope:INF_Account)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_query_update_flg();
  inline void clear_has_query_update_flg();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_stk();
  inline void clear_has_stk();
  inline void set_has_etf();
  inline void clear_has_etf();
  inline void set_has_login_ack();
  inline void clear_has_login_ack();
  inline void set_has_login_req();
  inline void clear_has_login_req();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* account_id_;
  ::ACCOUNT_INFO* acc_;
  ::STOCK_INFO* stk_;
  ::ETF_INFO* etf_;
  ::LOGIN_ACK* login_ack_;
  ::LOGIN_REQ* login_req_;
  ::google::protobuf::int32 query_update_flg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_Account* default_instance_;
};
// -------------------------------------------------------------------

class INF_ETF_Message : public ::google::protobuf::Message {
 public:
  INF_ETF_Message();
  virtual ~INF_ETF_Message();
  
  INF_ETF_Message(const INF_ETF_Message& from);
  
  inline INF_ETF_Message& operator=(const INF_ETF_Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const INF_ETF_Message& default_instance();
  
  void Swap(INF_ETF_Message* other);
  
  // implements Message ----------------------------------------------
  
  INF_ETF_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const INF_ETF_Message& from);
  void MergeFrom(const INF_ETF_Message& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ETF_Message_req Etf_req = 1;
  inline bool has_etf_req() const;
  inline void clear_etf_req();
  static const int kEtfReqFieldNumber = 1;
  inline const ::ETF_Message_req& etf_req() const;
  inline ::ETF_Message_req* mutable_etf_req();
  inline ::ETF_Message_req* release_etf_req();
  
  // optional .ETF_Message_ack Etf_ack = 2;
  inline bool has_etf_ack() const;
  inline void clear_etf_ack();
  static const int kEtfAckFieldNumber = 2;
  inline const ::ETF_Message_ack& etf_ack() const;
  inline ::ETF_Message_ack* mutable_etf_ack();
  inline ::ETF_Message_ack* release_etf_ack();
  
  // @@protoc_insertion_point(class_scope:INF_ETF_Message)
 private:
  inline void set_has_etf_req();
  inline void clear_has_etf_req();
  inline void set_has_etf_ack();
  inline void clear_has_etf_ack();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ETF_Message_req* etf_req_;
  ::ETF_Message_ack* etf_ack_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static INF_ETF_Message* default_instance_;
};
// -------------------------------------------------------------------

class ETF_Message_req : public ::google::protobuf::Message {
 public:
  ETF_Message_req();
  virtual ~ETF_Message_req();
  
  ETF_Message_req(const ETF_Message_req& from);
  
  inline ETF_Message_req& operator=(const ETF_Message_req& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ETF_Message_req& default_instance();
  
  void Swap(ETF_Message_req* other);
  
  // implements Message ----------------------------------------------
  
  ETF_Message_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ETF_Message_req& from);
  void MergeFrom(const ETF_Message_req& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ETF_WT_NO = 1;
  inline bool has_etf_wt_no() const;
  inline void clear_etf_wt_no();
  static const int kETFWTNOFieldNumber = 1;
  inline const ::std::string& etf_wt_no() const;
  inline void set_etf_wt_no(const ::std::string& value);
  inline void set_etf_wt_no(const char* value);
  inline void set_etf_wt_no(const char* value, size_t size);
  inline ::std::string* mutable_etf_wt_no();
  inline ::std::string* release_etf_wt_no();
  
  // @@protoc_insertion_point(class_scope:ETF_Message_req)
 private:
  inline void set_has_etf_wt_no();
  inline void clear_has_etf_wt_no();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* etf_wt_no_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static ETF_Message_req* default_instance_;
};
// -------------------------------------------------------------------

class ETF_Message_ack : public ::google::protobuf::Message {
 public:
  ETF_Message_ack();
  virtual ~ETF_Message_ack();
  
  ETF_Message_ack(const ETF_Message_ack& from);
  
  inline ETF_Message_ack& operator=(const ETF_Message_ack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ETF_Message_ack& default_instance();
  
  void Swap(ETF_Message_ack* other);
  
  // implements Message ----------------------------------------------
  
  ETF_Message_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ETF_Message_ack& from);
  void MergeFrom(const ETF_Message_ack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Valid = 1;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 1;
  inline const ::std::string& valid() const;
  inline void set_valid(const ::std::string& value);
  inline void set_valid(const char* value);
  inline void set_valid(const char* value, size_t size);
  inline ::std::string* mutable_valid();
  inline ::std::string* release_valid();
  
  // optional string ETFCode = 2;
  inline bool has_etfcode() const;
  inline void clear_etfcode();
  static const int kETFCodeFieldNumber = 2;
  inline const ::std::string& etfcode() const;
  inline void set_etfcode(const ::std::string& value);
  inline void set_etfcode(const char* value);
  inline void set_etfcode(const char* value, size_t size);
  inline ::std::string* mutable_etfcode();
  inline ::std::string* release_etfcode();
  
  // optional string ETFName = 3;
  inline bool has_etfname() const;
  inline void clear_etfname();
  static const int kETFNameFieldNumber = 3;
  inline const ::std::string& etfname() const;
  inline void set_etfname(const ::std::string& value);
  inline void set_etfname(const char* value);
  inline void set_etfname(const char* value, size_t size);
  inline ::std::string* mutable_etfname();
  inline ::std::string* release_etfname();
  
  // optional string ETF_WT_Num = 4;
  inline bool has_etf_wt_num() const;
  inline void clear_etf_wt_num();
  static const int kETFWTNumFieldNumber = 4;
  inline const ::std::string& etf_wt_num() const;
  inline void set_etf_wt_num(const ::std::string& value);
  inline void set_etf_wt_num(const char* value);
  inline void set_etf_wt_num(const char* value, size_t size);
  inline ::std::string* mutable_etf_wt_num();
  inline ::std::string* release_etf_wt_num();
  
  // optional string ETF_WT_Price = 5;
  inline bool has_etf_wt_price() const;
  inline void clear_etf_wt_price();
  static const int kETFWTPriceFieldNumber = 5;
  inline const ::std::string& etf_wt_price() const;
  inline void set_etf_wt_price(const ::std::string& value);
  inline void set_etf_wt_price(const char* value);
  inline void set_etf_wt_price(const char* value, size_t size);
  inline ::std::string* mutable_etf_wt_price();
  inline ::std::string* release_etf_wt_price();
  
  // optional string ETF_WT_Serial = 6;
  inline bool has_etf_wt_serial() const;
  inline void clear_etf_wt_serial();
  static const int kETFWTSerialFieldNumber = 6;
  inline const ::std::string& etf_wt_serial() const;
  inline void set_etf_wt_serial(const ::std::string& value);
  inline void set_etf_wt_serial(const char* value);
  inline void set_etf_wt_serial(const char* value, size_t size);
  inline ::std::string* mutable_etf_wt_serial();
  inline ::std::string* release_etf_wt_serial();
  
  // optional string ETF_CJ_Num = 7;
  inline bool has_etf_cj_num() const;
  inline void clear_etf_cj_num();
  static const int kETFCJNumFieldNumber = 7;
  inline const ::std::string& etf_cj_num() const;
  inline void set_etf_cj_num(const ::std::string& value);
  inline void set_etf_cj_num(const char* value);
  inline void set_etf_cj_num(const char* value, size_t size);
  inline ::std::string* mutable_etf_cj_num();
  inline ::std::string* release_etf_cj_num();
  
  // optional string ETF_WT_Time = 8;
  inline bool has_etf_wt_time() const;
  inline void clear_etf_wt_time();
  static const int kETFWTTimeFieldNumber = 8;
  inline const ::std::string& etf_wt_time() const;
  inline void set_etf_wt_time(const ::std::string& value);
  inline void set_etf_wt_time(const char* value);
  inline void set_etf_wt_time(const char* value, size_t size);
  inline ::std::string* mutable_etf_wt_time();
  inline ::std::string* release_etf_wt_time();
  
  // optional string MarketID = 9;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIDFieldNumber = 9;
  inline const ::std::string& marketid() const;
  inline void set_marketid(const ::std::string& value);
  inline void set_marketid(const char* value);
  inline void set_marketid(const char* value, size_t size);
  inline ::std::string* mutable_marketid();
  inline ::std::string* release_marketid();
  
  // optional string BSflag = 10;
  inline bool has_bsflag() const;
  inline void clear_bsflag();
  static const int kBSflagFieldNumber = 10;
  inline const ::std::string& bsflag() const;
  inline void set_bsflag(const ::std::string& value);
  inline void set_bsflag(const char* value);
  inline void set_bsflag(const char* value, size_t size);
  inline ::std::string* mutable_bsflag();
  inline ::std::string* release_bsflag();
  
  // optional string ETF_WT_Status = 11;
  inline bool has_etf_wt_status() const;
  inline void clear_etf_wt_status();
  static const int kETFWTStatusFieldNumber = 11;
  inline const ::std::string& etf_wt_status() const;
  inline void set_etf_wt_status(const ::std::string& value);
  inline void set_etf_wt_status(const char* value);
  inline void set_etf_wt_status(const char* value, size_t size);
  inline ::std::string* mutable_etf_wt_status();
  inline ::std::string* release_etf_wt_status();
  
  // optional string CjPriceSum = 12;
  inline bool has_cjpricesum() const;
  inline void clear_cjpricesum();
  static const int kCjPriceSumFieldNumber = 12;
  inline const ::std::string& cjpricesum() const;
  inline void set_cjpricesum(const ::std::string& value);
  inline void set_cjpricesum(const char* value);
  inline void set_cjpricesum(const char* value, size_t size);
  inline ::std::string* mutable_cjpricesum();
  inline ::std::string* release_cjpricesum();
  
  // @@protoc_insertion_point(class_scope:ETF_Message_ack)
 private:
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_etfcode();
  inline void clear_has_etfcode();
  inline void set_has_etfname();
  inline void clear_has_etfname();
  inline void set_has_etf_wt_num();
  inline void clear_has_etf_wt_num();
  inline void set_has_etf_wt_price();
  inline void clear_has_etf_wt_price();
  inline void set_has_etf_wt_serial();
  inline void clear_has_etf_wt_serial();
  inline void set_has_etf_cj_num();
  inline void clear_has_etf_cj_num();
  inline void set_has_etf_wt_time();
  inline void clear_has_etf_wt_time();
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_bsflag();
  inline void clear_has_bsflag();
  inline void set_has_etf_wt_status();
  inline void clear_has_etf_wt_status();
  inline void set_has_cjpricesum();
  inline void clear_has_cjpricesum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* valid_;
  ::std::string* etfcode_;
  ::std::string* etfname_;
  ::std::string* etf_wt_num_;
  ::std::string* etf_wt_price_;
  ::std::string* etf_wt_serial_;
  ::std::string* etf_cj_num_;
  ::std::string* etf_wt_time_;
  ::std::string* marketid_;
  ::std::string* bsflag_;
  ::std::string* etf_wt_status_;
  ::std::string* cjpricesum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static ETF_Message_ack* default_instance_;
};
// -------------------------------------------------------------------

class StockServer : public ::google::protobuf::Message {
 public:
  StockServer();
  virtual ~StockServer();
  
  StockServer(const StockServer& from);
  
  inline StockServer& operator=(const StockServer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StockServer& default_instance();
  
  void Swap(StockServer* other);
  
  // implements Message ----------------------------------------------
  
  StockServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StockServer& from);
  void MergeFrom(const StockServer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string FuncID = 1;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncIDFieldNumber = 1;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // required string IsAckFlag = 2;
  inline bool has_isackflag() const;
  inline void clear_isackflag();
  static const int kIsAckFlagFieldNumber = 2;
  inline const ::std::string& isackflag() const;
  inline void set_isackflag(const ::std::string& value);
  inline void set_isackflag(const char* value);
  inline void set_isackflag(const char* value, size_t size);
  inline ::std::string* mutable_isackflag();
  inline ::std::string* release_isackflag();
  
  // required string DestModule = 3;
  inline bool has_destmodule() const;
  inline void clear_destmodule();
  static const int kDestModuleFieldNumber = 3;
  inline const ::std::string& destmodule() const;
  inline void set_destmodule(const ::std::string& value);
  inline void set_destmodule(const char* value);
  inline void set_destmodule(const char* value, size_t size);
  inline ::std::string* mutable_destmodule();
  inline ::std::string* release_destmodule();
  
  // required string SrcModule = 4;
  inline bool has_srcmodule() const;
  inline void clear_srcmodule();
  static const int kSrcModuleFieldNumber = 4;
  inline const ::std::string& srcmodule() const;
  inline void set_srcmodule(const ::std::string& value);
  inline void set_srcmodule(const char* value);
  inline void set_srcmodule(const char* value, size_t size);
  inline ::std::string* mutable_srcmodule();
  inline ::std::string* release_srcmodule();
  
  // required string RequestID = 5;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 5;
  inline const ::std::string& requestid() const;
  inline void set_requestid(const ::std::string& value);
  inline void set_requestid(const char* value);
  inline void set_requestid(const char* value, size_t size);
  inline ::std::string* mutable_requestid();
  inline ::std::string* release_requestid();
  
  // required string PackSum = 36;
  inline bool has_packsum() const;
  inline void clear_packsum();
  static const int kPackSumFieldNumber = 36;
  inline const ::std::string& packsum() const;
  inline void set_packsum(const ::std::string& value);
  inline void set_packsum(const char* value);
  inline void set_packsum(const char* value, size_t size);
  inline ::std::string* mutable_packsum();
  inline ::std::string* release_packsum();
  
  // required string PackSeq = 37;
  inline bool has_packseq() const;
  inline void clear_packseq();
  static const int kPackSeqFieldNumber = 37;
  inline const ::std::string& packseq() const;
  inline void set_packseq(const ::std::string& value);
  inline void set_packseq(const char* value);
  inline void set_packseq(const char* value, size_t size);
  inline ::std::string* mutable_packseq();
  inline ::std::string* release_packseq();
  
  // optional .INF_OneEntrust_Req OneEntrust_Req = 6;
  inline bool has_oneentrust_req() const;
  inline void clear_oneentrust_req();
  static const int kOneEntrustReqFieldNumber = 6;
  inline const ::INF_OneEntrust_Req& oneentrust_req() const;
  inline ::INF_OneEntrust_Req* mutable_oneentrust_req();
  inline ::INF_OneEntrust_Req* release_oneentrust_req();
  
  // optional .INF_OneCancel_Req OneCancel_Req = 7;
  inline bool has_onecancel_req() const;
  inline void clear_onecancel_req();
  static const int kOneCancelReqFieldNumber = 7;
  inline const ::INF_OneCancel_Req& onecancel_req() const;
  inline ::INF_OneCancel_Req* mutable_onecancel_req();
  inline ::INF_OneCancel_Req* release_onecancel_req();
  
  // optional .INF_QueryOneEntrust_Req QueryOneEntrust_Req = 8;
  inline bool has_queryoneentrust_req() const;
  inline void clear_queryoneentrust_req();
  static const int kQueryOneEntrustReqFieldNumber = 8;
  inline const ::INF_QueryOneEntrust_Req& queryoneentrust_req() const;
  inline ::INF_QueryOneEntrust_Req* mutable_queryoneentrust_req();
  inline ::INF_QueryOneEntrust_Req* release_queryoneentrust_req();
  
  // optional .INF_QueryCJMX_Req QueryCJMX_Req = 9;
  inline bool has_querycjmx_req() const;
  inline void clear_querycjmx_req();
  static const int kQueryCJMXReqFieldNumber = 9;
  inline const ::INF_QueryCJMX_Req& querycjmx_req() const;
  inline ::INF_QueryCJMX_Req* mutable_querycjmx_req();
  inline ::INF_QueryCJMX_Req* release_querycjmx_req();
  
  // optional .INF_QueryPosition_Req QueryPosition_Req = 10;
  inline bool has_queryposition_req() const;
  inline void clear_queryposition_req();
  static const int kQueryPositionReqFieldNumber = 10;
  inline const ::INF_QueryPosition_Req& queryposition_req() const;
  inline ::INF_QueryPosition_Req* mutable_queryposition_req();
  inline ::INF_QueryPosition_Req* release_queryposition_req();
  
  // optional .INF_QueryETFbaseInfo_Req QueryETFbaseInfo_Req = 11;
  inline bool has_queryetfbaseinfo_req() const;
  inline void clear_queryetfbaseinfo_req();
  static const int kQueryETFbaseInfoReqFieldNumber = 11;
  inline const ::INF_QueryETFbaseInfo_Req& queryetfbaseinfo_req() const;
  inline ::INF_QueryETFbaseInfo_Req* mutable_queryetfbaseinfo_req();
  inline ::INF_QueryETFbaseInfo_Req* release_queryetfbaseinfo_req();
  
  // optional .INF_QueryETFlistInfo_Req QueryETFlistInfo_Req = 12;
  inline bool has_queryetflistinfo_req() const;
  inline void clear_queryetflistinfo_req();
  static const int kQueryETFlistInfoReqFieldNumber = 12;
  inline const ::INF_QueryETFlistInfo_Req& queryetflistinfo_req() const;
  inline ::INF_QueryETFlistInfo_Req* mutable_queryetflistinfo_req();
  inline ::INF_QueryETFlistInfo_Req* release_queryetflistinfo_req();
  
  // optional .INF_QueryETFdynamicInfo_Req QueryETFdynamicInfo_Req = 13;
  inline bool has_queryetfdynamicinfo_req() const;
  inline void clear_queryetfdynamicinfo_req();
  static const int kQueryETFdynamicInfoReqFieldNumber = 13;
  inline const ::INF_QueryETFdynamicInfo_Req& queryetfdynamicinfo_req() const;
  inline ::INF_QueryETFdynamicInfo_Req* mutable_queryetfdynamicinfo_req();
  inline ::INF_QueryETFdynamicInfo_Req* release_queryetfdynamicinfo_req();
  
  // optional .INF_QueryFundCondition_Req QueryFundCondition_Req = 14;
  inline bool has_queryfundcondition_req() const;
  inline void clear_queryfundcondition_req();
  static const int kQueryFundConditionReqFieldNumber = 14;
  inline const ::INF_QueryFundCondition_Req& queryfundcondition_req() const;
  inline ::INF_QueryFundCondition_Req* mutable_queryfundcondition_req();
  inline ::INF_QueryFundCondition_Req* release_queryfundcondition_req();
  
  // optional .INF_ETFPurRedem_Req ETFPurRedem_Req = 15;
  inline bool has_etfpurredem_req() const;
  inline void clear_etfpurredem_req();
  static const int kETFPurRedemReqFieldNumber = 15;
  inline const ::INF_ETFPurRedem_Req& etfpurredem_req() const;
  inline ::INF_ETFPurRedem_Req* mutable_etfpurredem_req();
  inline ::INF_ETFPurRedem_Req* release_etfpurredem_req();
  
  // optional .INF_QueryBatchEntrust_Req QueryBatchEntrust_Req = 16;
  inline bool has_querybatchentrust_req() const;
  inline void clear_querybatchentrust_req();
  static const int kQueryBatchEntrustReqFieldNumber = 16;
  inline const ::INF_QueryBatchEntrust_Req& querybatchentrust_req() const;
  inline ::INF_QueryBatchEntrust_Req* mutable_querybatchentrust_req();
  inline ::INF_QueryBatchEntrust_Req* release_querybatchentrust_req();
  
  // optional .INF_BatchEntrust_Req BatchEntrust_Req = 17;
  inline bool has_batchentrust_req() const;
  inline void clear_batchentrust_req();
  static const int kBatchEntrustReqFieldNumber = 17;
  inline const ::INF_BatchEntrust_Req& batchentrust_req() const;
  inline ::INF_BatchEntrust_Req* mutable_batchentrust_req();
  inline ::INF_BatchEntrust_Req* release_batchentrust_req();
  
  // optional .INF_BatchCancel_Req BatchCancel_Req = 18;
  inline bool has_batchcancel_req() const;
  inline void clear_batchcancel_req();
  static const int kBatchCancelReqFieldNumber = 18;
  inline const ::INF_BatchCancel_Req& batchcancel_req() const;
  inline ::INF_BatchCancel_Req* mutable_batchcancel_req();
  inline ::INF_BatchCancel_Req* release_batchcancel_req();
  
  // optional .INF_QueryVaildRedemNum_Req QueryVaildRedemNum_Req = 19;
  inline bool has_queryvaildredemnum_req() const;
  inline void clear_queryvaildredemnum_req();
  static const int kQueryVaildRedemNumReqFieldNumber = 19;
  inline const ::INF_QueryVaildRedemNum_Req& queryvaildredemnum_req() const;
  inline ::INF_QueryVaildRedemNum_Req* mutable_queryvaildredemnum_req();
  inline ::INF_QueryVaildRedemNum_Req* release_queryvaildredemnum_req();
  
  // optional .INF_OneEntrust_Ack OneEntrust_Ack = 20;
  inline bool has_oneentrust_ack() const;
  inline void clear_oneentrust_ack();
  static const int kOneEntrustAckFieldNumber = 20;
  inline const ::INF_OneEntrust_Ack& oneentrust_ack() const;
  inline ::INF_OneEntrust_Ack* mutable_oneentrust_ack();
  inline ::INF_OneEntrust_Ack* release_oneentrust_ack();
  
  // optional .INF_OneCancel_Ack OneCancel_Ack = 21;
  inline bool has_onecancel_ack() const;
  inline void clear_onecancel_ack();
  static const int kOneCancelAckFieldNumber = 21;
  inline const ::INF_OneCancel_Ack& onecancel_ack() const;
  inline ::INF_OneCancel_Ack* mutable_onecancel_ack();
  inline ::INF_OneCancel_Ack* release_onecancel_ack();
  
  // optional .INF_QueryOneEntrust_Ack QueryOneEntrust_Ack = 22;
  inline bool has_queryoneentrust_ack() const;
  inline void clear_queryoneentrust_ack();
  static const int kQueryOneEntrustAckFieldNumber = 22;
  inline const ::INF_QueryOneEntrust_Ack& queryoneentrust_ack() const;
  inline ::INF_QueryOneEntrust_Ack* mutable_queryoneentrust_ack();
  inline ::INF_QueryOneEntrust_Ack* release_queryoneentrust_ack();
  
  // optional .INF_QueryCJMX_Ack QueryCJMX_Ack = 23;
  inline bool has_querycjmx_ack() const;
  inline void clear_querycjmx_ack();
  static const int kQueryCJMXAckFieldNumber = 23;
  inline const ::INF_QueryCJMX_Ack& querycjmx_ack() const;
  inline ::INF_QueryCJMX_Ack* mutable_querycjmx_ack();
  inline ::INF_QueryCJMX_Ack* release_querycjmx_ack();
  
  // optional .INF_QueryPosition_Ack QueryPosition_Ack = 24;
  inline bool has_queryposition_ack() const;
  inline void clear_queryposition_ack();
  static const int kQueryPositionAckFieldNumber = 24;
  inline const ::INF_QueryPosition_Ack& queryposition_ack() const;
  inline ::INF_QueryPosition_Ack* mutable_queryposition_ack();
  inline ::INF_QueryPosition_Ack* release_queryposition_ack();
  
  // optional .INF_QueryETFbaseInfo_Ack QueryETFbaseInfo_Ack = 25;
  inline bool has_queryetfbaseinfo_ack() const;
  inline void clear_queryetfbaseinfo_ack();
  static const int kQueryETFbaseInfoAckFieldNumber = 25;
  inline const ::INF_QueryETFbaseInfo_Ack& queryetfbaseinfo_ack() const;
  inline ::INF_QueryETFbaseInfo_Ack* mutable_queryetfbaseinfo_ack();
  inline ::INF_QueryETFbaseInfo_Ack* release_queryetfbaseinfo_ack();
  
  // optional .INF_QueryETFlistInfo_Ack QueryETFlistInfo_Ack = 26;
  inline bool has_queryetflistinfo_ack() const;
  inline void clear_queryetflistinfo_ack();
  static const int kQueryETFlistInfoAckFieldNumber = 26;
  inline const ::INF_QueryETFlistInfo_Ack& queryetflistinfo_ack() const;
  inline ::INF_QueryETFlistInfo_Ack* mutable_queryetflistinfo_ack();
  inline ::INF_QueryETFlistInfo_Ack* release_queryetflistinfo_ack();
  
  // optional .INF_QueryETFdynamicInfo_Ack QueryETFdynamicInfo_Ack = 27;
  inline bool has_queryetfdynamicinfo_ack() const;
  inline void clear_queryetfdynamicinfo_ack();
  static const int kQueryETFdynamicInfoAckFieldNumber = 27;
  inline const ::INF_QueryETFdynamicInfo_Ack& queryetfdynamicinfo_ack() const;
  inline ::INF_QueryETFdynamicInfo_Ack* mutable_queryetfdynamicinfo_ack();
  inline ::INF_QueryETFdynamicInfo_Ack* release_queryetfdynamicinfo_ack();
  
  // optional .INF_QueryFundCondition_Ack QueryFundCondition_Ack = 28;
  inline bool has_queryfundcondition_ack() const;
  inline void clear_queryfundcondition_ack();
  static const int kQueryFundConditionAckFieldNumber = 28;
  inline const ::INF_QueryFundCondition_Ack& queryfundcondition_ack() const;
  inline ::INF_QueryFundCondition_Ack* mutable_queryfundcondition_ack();
  inline ::INF_QueryFundCondition_Ack* release_queryfundcondition_ack();
  
  // optional .INF_ETFPurRedem_Ack ETFPurRedem_Ack = 29;
  inline bool has_etfpurredem_ack() const;
  inline void clear_etfpurredem_ack();
  static const int kETFPurRedemAckFieldNumber = 29;
  inline const ::INF_ETFPurRedem_Ack& etfpurredem_ack() const;
  inline ::INF_ETFPurRedem_Ack* mutable_etfpurredem_ack();
  inline ::INF_ETFPurRedem_Ack* release_etfpurredem_ack();
  
  // optional .INF_QueryBatchEntrust_Ack QueryBatchEntrust_Ack = 30;
  inline bool has_querybatchentrust_ack() const;
  inline void clear_querybatchentrust_ack();
  static const int kQueryBatchEntrustAckFieldNumber = 30;
  inline const ::INF_QueryBatchEntrust_Ack& querybatchentrust_ack() const;
  inline ::INF_QueryBatchEntrust_Ack* mutable_querybatchentrust_ack();
  inline ::INF_QueryBatchEntrust_Ack* release_querybatchentrust_ack();
  
  // optional .INF_BatchEntrust_Ack BatchEntrust_Ack = 31;
  inline bool has_batchentrust_ack() const;
  inline void clear_batchentrust_ack();
  static const int kBatchEntrustAckFieldNumber = 31;
  inline const ::INF_BatchEntrust_Ack& batchentrust_ack() const;
  inline ::INF_BatchEntrust_Ack* mutable_batchentrust_ack();
  inline ::INF_BatchEntrust_Ack* release_batchentrust_ack();
  
  // optional .INF_BatchCancel_Ack BatchCancel_Ack = 32;
  inline bool has_batchcancel_ack() const;
  inline void clear_batchcancel_ack();
  static const int kBatchCancelAckFieldNumber = 32;
  inline const ::INF_BatchCancel_Ack& batchcancel_ack() const;
  inline ::INF_BatchCancel_Ack* mutable_batchcancel_ack();
  inline ::INF_BatchCancel_Ack* release_batchcancel_ack();
  
  // optional .INF_Account Account = 34;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 34;
  inline const ::INF_Account& account() const;
  inline ::INF_Account* mutable_account();
  inline ::INF_Account* release_account();
  
  // optional .INF_ETF_Message ETF_Message = 35;
  inline bool has_etf_message() const;
  inline void clear_etf_message();
  static const int kETFMessageFieldNumber = 35;
  inline const ::INF_ETF_Message& etf_message() const;
  inline ::INF_ETF_Message* mutable_etf_message();
  inline ::INF_ETF_Message* release_etf_message();
  
  // @@protoc_insertion_point(class_scope:StockServer)
 private:
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_isackflag();
  inline void clear_has_isackflag();
  inline void set_has_destmodule();
  inline void clear_has_destmodule();
  inline void set_has_srcmodule();
  inline void clear_has_srcmodule();
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_packsum();
  inline void clear_has_packsum();
  inline void set_has_packseq();
  inline void clear_has_packseq();
  inline void set_has_oneentrust_req();
  inline void clear_has_oneentrust_req();
  inline void set_has_onecancel_req();
  inline void clear_has_onecancel_req();
  inline void set_has_queryoneentrust_req();
  inline void clear_has_queryoneentrust_req();
  inline void set_has_querycjmx_req();
  inline void clear_has_querycjmx_req();
  inline void set_has_queryposition_req();
  inline void clear_has_queryposition_req();
  inline void set_has_queryetfbaseinfo_req();
  inline void clear_has_queryetfbaseinfo_req();
  inline void set_has_queryetflistinfo_req();
  inline void clear_has_queryetflistinfo_req();
  inline void set_has_queryetfdynamicinfo_req();
  inline void clear_has_queryetfdynamicinfo_req();
  inline void set_has_queryfundcondition_req();
  inline void clear_has_queryfundcondition_req();
  inline void set_has_etfpurredem_req();
  inline void clear_has_etfpurredem_req();
  inline void set_has_querybatchentrust_req();
  inline void clear_has_querybatchentrust_req();
  inline void set_has_batchentrust_req();
  inline void clear_has_batchentrust_req();
  inline void set_has_batchcancel_req();
  inline void clear_has_batchcancel_req();
  inline void set_has_queryvaildredemnum_req();
  inline void clear_has_queryvaildredemnum_req();
  inline void set_has_oneentrust_ack();
  inline void clear_has_oneentrust_ack();
  inline void set_has_onecancel_ack();
  inline void clear_has_onecancel_ack();
  inline void set_has_queryoneentrust_ack();
  inline void clear_has_queryoneentrust_ack();
  inline void set_has_querycjmx_ack();
  inline void clear_has_querycjmx_ack();
  inline void set_has_queryposition_ack();
  inline void clear_has_queryposition_ack();
  inline void set_has_queryetfbaseinfo_ack();
  inline void clear_has_queryetfbaseinfo_ack();
  inline void set_has_queryetflistinfo_ack();
  inline void clear_has_queryetflistinfo_ack();
  inline void set_has_queryetfdynamicinfo_ack();
  inline void clear_has_queryetfdynamicinfo_ack();
  inline void set_has_queryfundcondition_ack();
  inline void clear_has_queryfundcondition_ack();
  inline void set_has_etfpurredem_ack();
  inline void clear_has_etfpurredem_ack();
  inline void set_has_querybatchentrust_ack();
  inline void clear_has_querybatchentrust_ack();
  inline void set_has_batchentrust_ack();
  inline void clear_has_batchentrust_ack();
  inline void set_has_batchcancel_ack();
  inline void clear_has_batchcancel_ack();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_etf_message();
  inline void clear_has_etf_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* funcid_;
  ::std::string* isackflag_;
  ::std::string* destmodule_;
  ::std::string* srcmodule_;
  ::std::string* requestid_;
  ::std::string* packsum_;
  ::std::string* packseq_;
  ::INF_OneEntrust_Req* oneentrust_req_;
  ::INF_OneCancel_Req* onecancel_req_;
  ::INF_QueryOneEntrust_Req* queryoneentrust_req_;
  ::INF_QueryCJMX_Req* querycjmx_req_;
  ::INF_QueryPosition_Req* queryposition_req_;
  ::INF_QueryETFbaseInfo_Req* queryetfbaseinfo_req_;
  ::INF_QueryETFlistInfo_Req* queryetflistinfo_req_;
  ::INF_QueryETFdynamicInfo_Req* queryetfdynamicinfo_req_;
  ::INF_QueryFundCondition_Req* queryfundcondition_req_;
  ::INF_ETFPurRedem_Req* etfpurredem_req_;
  ::INF_QueryBatchEntrust_Req* querybatchentrust_req_;
  ::INF_BatchEntrust_Req* batchentrust_req_;
  ::INF_BatchCancel_Req* batchcancel_req_;
  ::INF_QueryVaildRedemNum_Req* queryvaildredemnum_req_;
  ::INF_OneEntrust_Ack* oneentrust_ack_;
  ::INF_OneCancel_Ack* onecancel_ack_;
  ::INF_QueryOneEntrust_Ack* queryoneentrust_ack_;
  ::INF_QueryCJMX_Ack* querycjmx_ack_;
  ::INF_QueryPosition_Ack* queryposition_ack_;
  ::INF_QueryETFbaseInfo_Ack* queryetfbaseinfo_ack_;
  ::INF_QueryETFlistInfo_Ack* queryetflistinfo_ack_;
  ::INF_QueryETFdynamicInfo_Ack* queryetfdynamicinfo_ack_;
  ::INF_QueryFundCondition_Ack* queryfundcondition_ack_;
  ::INF_ETFPurRedem_Ack* etfpurredem_ack_;
  ::INF_QueryBatchEntrust_Ack* querybatchentrust_ack_;
  ::INF_BatchEntrust_Ack* batchentrust_ack_;
  ::INF_BatchCancel_Ack* batchcancel_ack_;
  ::INF_Account* account_;
  ::INF_ETF_Message* etf_message_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(36 + 31) / 32];
  
  friend void  protobuf_AddDesc_CQconnection_2eprotoc();
  friend void protobuf_AssignDesc_CQconnection_2eprotoc();
  friend void protobuf_ShutdownFile_CQconnection_2eprotoc();
  
  void InitAsDefaultInstance();
  static StockServer* default_instance_;
};
// ===================================================================


// ===================================================================

// INF_OneEntrust_Req

// optional string RT0 = 1;
inline bool INF_OneEntrust_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_OneEntrust_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_OneEntrust_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_OneEntrust_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_OneEntrust_Req::rt0() const {
  return *rt0_;
}
inline void INF_OneEntrust_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_OneEntrust_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_OneEntrust_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_OneEntrust_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_OneEntrust_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_OneEntrust_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_OneEntrust_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_OneEntrust_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_OneEntrust_Req::localhost() const {
  return *localhost_;
}
inline void INF_OneEntrust_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_OneEntrust_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_OneEntrust_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_OneEntrust_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_OneEntrust_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_OneEntrust_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_OneEntrust_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_OneEntrust_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_OneEntrust_Req::reqid() const {
  return *reqid_;
}
inline void INF_OneEntrust_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_OneEntrust_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_OneEntrust_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_OneEntrust_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_OneEntrust_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_OneEntrust_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_OneEntrust_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_OneEntrust_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_OneEntrust_Req::funcid() const {
  return *funcid_;
}
inline void INF_OneEntrust_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_OneEntrust_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_OneEntrust_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_OneEntrust_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_OneEntrust_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_OneEntrust_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_OneEntrust_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_OneEntrust_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_OneEntrust_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_OneEntrust_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_OneEntrust_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_OneEntrust_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_OneEntrust_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MarketID = 6;
inline bool INF_OneEntrust_Req::has_marketid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_OneEntrust_Req::set_has_marketid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_OneEntrust_Req::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_OneEntrust_Req::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_OneEntrust_Req::marketid() const {
  return *marketid_;
}
inline void INF_OneEntrust_Req::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_OneEntrust_Req::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_OneEntrust_Req::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_OneEntrust_Req::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_OneEntrust_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_OneEntrust_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_OneEntrust_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_OneEntrust_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_OneEntrust_Req::rt6() const {
  return *rt6_;
}
inline void INF_OneEntrust_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_OneEntrust_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_OneEntrust_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_OneEntrust_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFserialNO = 8;
inline bool INF_OneEntrust_Req::has_etfserialno() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_OneEntrust_Req::set_has_etfserialno() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_OneEntrust_Req::clear_has_etfserialno() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_OneEntrust_Req::clear_etfserialno() {
  if (etfserialno_ != &::google::protobuf::internal::kEmptyString) {
    etfserialno_->clear();
  }
  clear_has_etfserialno();
}
inline const ::std::string& INF_OneEntrust_Req::etfserialno() const {
  return *etfserialno_;
}
inline void INF_OneEntrust_Req::set_etfserialno(const ::std::string& value) {
  set_has_etfserialno();
  if (etfserialno_ == &::google::protobuf::internal::kEmptyString) {
    etfserialno_ = new ::std::string;
  }
  etfserialno_->assign(value);
}
inline void INF_OneEntrust_Req::set_etfserialno(const char* value) {
  set_has_etfserialno();
  if (etfserialno_ == &::google::protobuf::internal::kEmptyString) {
    etfserialno_ = new ::std::string;
  }
  etfserialno_->assign(value);
}
inline void INF_OneEntrust_Req::set_etfserialno(const char* value, size_t size) {
  set_has_etfserialno();
  if (etfserialno_ == &::google::protobuf::internal::kEmptyString) {
    etfserialno_ = new ::std::string;
  }
  etfserialno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_etfserialno() {
  set_has_etfserialno();
  if (etfserialno_ == &::google::protobuf::internal::kEmptyString) {
    etfserialno_ = new ::std::string;
  }
  return etfserialno_;
}
inline ::std::string* INF_OneEntrust_Req::release_etfserialno() {
  clear_has_etfserialno();
  if (etfserialno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfserialno_;
    etfserialno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 9;
inline bool INF_OneEntrust_Req::has_securitycode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_OneEntrust_Req::set_has_securitycode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_OneEntrust_Req::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_OneEntrust_Req::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_OneEntrust_Req::securitycode() const {
  return *securitycode_;
}
inline void INF_OneEntrust_Req::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_OneEntrust_Req::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_OneEntrust_Req::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_OneEntrust_Req::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BSflag = 10;
inline bool INF_OneEntrust_Req::has_bsflag() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_OneEntrust_Req::set_has_bsflag() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_OneEntrust_Req::clear_has_bsflag() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_OneEntrust_Req::clear_bsflag() {
  if (bsflag_ != &::google::protobuf::internal::kEmptyString) {
    bsflag_->clear();
  }
  clear_has_bsflag();
}
inline const ::std::string& INF_OneEntrust_Req::bsflag() const {
  return *bsflag_;
}
inline void INF_OneEntrust_Req::set_bsflag(const ::std::string& value) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(value);
}
inline void INF_OneEntrust_Req::set_bsflag(const char* value) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(value);
}
inline void INF_OneEntrust_Req::set_bsflag(const char* value, size_t size) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_bsflag() {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  return bsflag_;
}
inline ::std::string* INF_OneEntrust_Req::release_bsflag() {
  clear_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bsflag_;
    bsflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustNum = 11;
inline bool INF_OneEntrust_Req::has_entrustnum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_OneEntrust_Req::set_has_entrustnum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_OneEntrust_Req::clear_has_entrustnum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_OneEntrust_Req::clear_entrustnum() {
  if (entrustnum_ != &::google::protobuf::internal::kEmptyString) {
    entrustnum_->clear();
  }
  clear_has_entrustnum();
}
inline const ::std::string& INF_OneEntrust_Req::entrustnum() const {
  return *entrustnum_;
}
inline void INF_OneEntrust_Req::set_entrustnum(const ::std::string& value) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrustnum(const char* value) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrustnum(const char* value, size_t size) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_entrustnum() {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  return entrustnum_;
}
inline ::std::string* INF_OneEntrust_Req::release_entrustnum() {
  clear_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustnum_;
    entrustnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustPrice = 12;
inline bool INF_OneEntrust_Req::has_entrustprice() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_OneEntrust_Req::set_has_entrustprice() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_OneEntrust_Req::clear_has_entrustprice() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_OneEntrust_Req::clear_entrustprice() {
  if (entrustprice_ != &::google::protobuf::internal::kEmptyString) {
    entrustprice_->clear();
  }
  clear_has_entrustprice();
}
inline const ::std::string& INF_OneEntrust_Req::entrustprice() const {
  return *entrustprice_;
}
inline void INF_OneEntrust_Req::set_entrustprice(const ::std::string& value) {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  entrustprice_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrustprice(const char* value) {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  entrustprice_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrustprice(const char* value, size_t size) {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  entrustprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_entrustprice() {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  return entrustprice_;
}
inline ::std::string* INF_OneEntrust_Req::release_entrustprice() {
  clear_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustprice_;
    entrustprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 13;
inline bool INF_OneEntrust_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_OneEntrust_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_OneEntrust_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_OneEntrust_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_OneEntrust_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_OneEntrust_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BandCode = 14;
inline bool INF_OneEntrust_Req::has_bandcode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_bandcode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_OneEntrust_Req::clear_has_bandcode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_OneEntrust_Req::clear_bandcode() {
  if (bandcode_ != &::google::protobuf::internal::kEmptyString) {
    bandcode_->clear();
  }
  clear_has_bandcode();
}
inline const ::std::string& INF_OneEntrust_Req::bandcode() const {
  return *bandcode_;
}
inline void INF_OneEntrust_Req::set_bandcode(const ::std::string& value) {
  set_has_bandcode();
  if (bandcode_ == &::google::protobuf::internal::kEmptyString) {
    bandcode_ = new ::std::string;
  }
  bandcode_->assign(value);
}
inline void INF_OneEntrust_Req::set_bandcode(const char* value) {
  set_has_bandcode();
  if (bandcode_ == &::google::protobuf::internal::kEmptyString) {
    bandcode_ = new ::std::string;
  }
  bandcode_->assign(value);
}
inline void INF_OneEntrust_Req::set_bandcode(const char* value, size_t size) {
  set_has_bandcode();
  if (bandcode_ == &::google::protobuf::internal::kEmptyString) {
    bandcode_ = new ::std::string;
  }
  bandcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_bandcode() {
  set_has_bandcode();
  if (bandcode_ == &::google::protobuf::internal::kEmptyString) {
    bandcode_ = new ::std::string;
  }
  return bandcode_;
}
inline ::std::string* INF_OneEntrust_Req::release_bandcode() {
  clear_has_bandcode();
  if (bandcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bandcode_;
    bandcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BandAccount = 15;
inline bool INF_OneEntrust_Req::has_bandaccount() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_bandaccount() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_OneEntrust_Req::clear_has_bandaccount() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_OneEntrust_Req::clear_bandaccount() {
  if (bandaccount_ != &::google::protobuf::internal::kEmptyString) {
    bandaccount_->clear();
  }
  clear_has_bandaccount();
}
inline const ::std::string& INF_OneEntrust_Req::bandaccount() const {
  return *bandaccount_;
}
inline void INF_OneEntrust_Req::set_bandaccount(const ::std::string& value) {
  set_has_bandaccount();
  if (bandaccount_ == &::google::protobuf::internal::kEmptyString) {
    bandaccount_ = new ::std::string;
  }
  bandaccount_->assign(value);
}
inline void INF_OneEntrust_Req::set_bandaccount(const char* value) {
  set_has_bandaccount();
  if (bandaccount_ == &::google::protobuf::internal::kEmptyString) {
    bandaccount_ = new ::std::string;
  }
  bandaccount_->assign(value);
}
inline void INF_OneEntrust_Req::set_bandaccount(const char* value, size_t size) {
  set_has_bandaccount();
  if (bandaccount_ == &::google::protobuf::internal::kEmptyString) {
    bandaccount_ = new ::std::string;
  }
  bandaccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_bandaccount() {
  set_has_bandaccount();
  if (bandaccount_ == &::google::protobuf::internal::kEmptyString) {
    bandaccount_ = new ::std::string;
  }
  return bandaccount_;
}
inline ::std::string* INF_OneEntrust_Req::release_bandaccount() {
  clear_has_bandaccount();
  if (bandaccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bandaccount_;
    bandaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FinancingSecurityMode = 16;
inline bool INF_OneEntrust_Req::has_financingsecuritymode() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_financingsecuritymode() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_OneEntrust_Req::clear_has_financingsecuritymode() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_OneEntrust_Req::clear_financingsecuritymode() {
  if (financingsecuritymode_ != &::google::protobuf::internal::kEmptyString) {
    financingsecuritymode_->clear();
  }
  clear_has_financingsecuritymode();
}
inline const ::std::string& INF_OneEntrust_Req::financingsecuritymode() const {
  return *financingsecuritymode_;
}
inline void INF_OneEntrust_Req::set_financingsecuritymode(const ::std::string& value) {
  set_has_financingsecuritymode();
  if (financingsecuritymode_ == &::google::protobuf::internal::kEmptyString) {
    financingsecuritymode_ = new ::std::string;
  }
  financingsecuritymode_->assign(value);
}
inline void INF_OneEntrust_Req::set_financingsecuritymode(const char* value) {
  set_has_financingsecuritymode();
  if (financingsecuritymode_ == &::google::protobuf::internal::kEmptyString) {
    financingsecuritymode_ = new ::std::string;
  }
  financingsecuritymode_->assign(value);
}
inline void INF_OneEntrust_Req::set_financingsecuritymode(const char* value, size_t size) {
  set_has_financingsecuritymode();
  if (financingsecuritymode_ == &::google::protobuf::internal::kEmptyString) {
    financingsecuritymode_ = new ::std::string;
  }
  financingsecuritymode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_financingsecuritymode() {
  set_has_financingsecuritymode();
  if (financingsecuritymode_ == &::google::protobuf::internal::kEmptyString) {
    financingsecuritymode_ = new ::std::string;
  }
  return financingsecuritymode_;
}
inline ::std::string* INF_OneEntrust_Req::release_financingsecuritymode() {
  clear_has_financingsecuritymode();
  if (financingsecuritymode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = financingsecuritymode_;
    financingsecuritymode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustBatchNO = 17;
inline bool INF_OneEntrust_Req::has_entrustbatchno() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_entrustbatchno() {
  _has_bits_[0] |= 0x00010000u;
}
inline void INF_OneEntrust_Req::clear_has_entrustbatchno() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void INF_OneEntrust_Req::clear_entrustbatchno() {
  if (entrustbatchno_ != &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_->clear();
  }
  clear_has_entrustbatchno();
}
inline const ::std::string& INF_OneEntrust_Req::entrustbatchno() const {
  return *entrustbatchno_;
}
inline void INF_OneEntrust_Req::set_entrustbatchno(const ::std::string& value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrustbatchno(const char* value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrustbatchno(const char* value, size_t size) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_entrustbatchno() {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  return entrustbatchno_;
}
inline ::std::string* INF_OneEntrust_Req::release_entrustbatchno() {
  clear_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustbatchno_;
    entrustbatchno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustRiskAssessFlag = 18;
inline bool INF_OneEntrust_Req::has_entrustriskassessflag() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_entrustriskassessflag() {
  _has_bits_[0] |= 0x00020000u;
}
inline void INF_OneEntrust_Req::clear_has_entrustriskassessflag() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void INF_OneEntrust_Req::clear_entrustriskassessflag() {
  if (entrustriskassessflag_ != &::google::protobuf::internal::kEmptyString) {
    entrustriskassessflag_->clear();
  }
  clear_has_entrustriskassessflag();
}
inline const ::std::string& INF_OneEntrust_Req::entrustriskassessflag() const {
  return *entrustriskassessflag_;
}
inline void INF_OneEntrust_Req::set_entrustriskassessflag(const ::std::string& value) {
  set_has_entrustriskassessflag();
  if (entrustriskassessflag_ == &::google::protobuf::internal::kEmptyString) {
    entrustriskassessflag_ = new ::std::string;
  }
  entrustriskassessflag_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrustriskassessflag(const char* value) {
  set_has_entrustriskassessflag();
  if (entrustriskassessflag_ == &::google::protobuf::internal::kEmptyString) {
    entrustriskassessflag_ = new ::std::string;
  }
  entrustriskassessflag_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrustriskassessflag(const char* value, size_t size) {
  set_has_entrustriskassessflag();
  if (entrustriskassessflag_ == &::google::protobuf::internal::kEmptyString) {
    entrustriskassessflag_ = new ::std::string;
  }
  entrustriskassessflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_entrustriskassessflag() {
  set_has_entrustriskassessflag();
  if (entrustriskassessflag_ == &::google::protobuf::internal::kEmptyString) {
    entrustriskassessflag_ = new ::std::string;
  }
  return entrustriskassessflag_;
}
inline ::std::string* INF_OneEntrust_Req::release_entrustriskassessflag() {
  clear_has_entrustriskassessflag();
  if (entrustriskassessflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustriskassessflag_;
    entrustriskassessflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustToBusiness = 19;
inline bool INF_OneEntrust_Req::has_entrusttobusiness() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_entrusttobusiness() {
  _has_bits_[0] |= 0x00040000u;
}
inline void INF_OneEntrust_Req::clear_has_entrusttobusiness() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void INF_OneEntrust_Req::clear_entrusttobusiness() {
  if (entrusttobusiness_ != &::google::protobuf::internal::kEmptyString) {
    entrusttobusiness_->clear();
  }
  clear_has_entrusttobusiness();
}
inline const ::std::string& INF_OneEntrust_Req::entrusttobusiness() const {
  return *entrusttobusiness_;
}
inline void INF_OneEntrust_Req::set_entrusttobusiness(const ::std::string& value) {
  set_has_entrusttobusiness();
  if (entrusttobusiness_ == &::google::protobuf::internal::kEmptyString) {
    entrusttobusiness_ = new ::std::string;
  }
  entrusttobusiness_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrusttobusiness(const char* value) {
  set_has_entrusttobusiness();
  if (entrusttobusiness_ == &::google::protobuf::internal::kEmptyString) {
    entrusttobusiness_ = new ::std::string;
  }
  entrusttobusiness_->assign(value);
}
inline void INF_OneEntrust_Req::set_entrusttobusiness(const char* value, size_t size) {
  set_has_entrusttobusiness();
  if (entrusttobusiness_ == &::google::protobuf::internal::kEmptyString) {
    entrusttobusiness_ = new ::std::string;
  }
  entrusttobusiness_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_entrusttobusiness() {
  set_has_entrusttobusiness();
  if (entrusttobusiness_ == &::google::protobuf::internal::kEmptyString) {
    entrusttobusiness_ = new ::std::string;
  }
  return entrusttobusiness_;
}
inline ::std::string* INF_OneEntrust_Req::release_entrusttobusiness() {
  clear_has_entrusttobusiness();
  if (entrusttobusiness_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttobusiness_;
    entrusttobusiness_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string AgreementNO = 20;
inline bool INF_OneEntrust_Req::has_agreementno() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_agreementno() {
  _has_bits_[0] |= 0x00080000u;
}
inline void INF_OneEntrust_Req::clear_has_agreementno() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void INF_OneEntrust_Req::clear_agreementno() {
  if (agreementno_ != &::google::protobuf::internal::kEmptyString) {
    agreementno_->clear();
  }
  clear_has_agreementno();
}
inline const ::std::string& INF_OneEntrust_Req::agreementno() const {
  return *agreementno_;
}
inline void INF_OneEntrust_Req::set_agreementno(const ::std::string& value) {
  set_has_agreementno();
  if (agreementno_ == &::google::protobuf::internal::kEmptyString) {
    agreementno_ = new ::std::string;
  }
  agreementno_->assign(value);
}
inline void INF_OneEntrust_Req::set_agreementno(const char* value) {
  set_has_agreementno();
  if (agreementno_ == &::google::protobuf::internal::kEmptyString) {
    agreementno_ = new ::std::string;
  }
  agreementno_->assign(value);
}
inline void INF_OneEntrust_Req::set_agreementno(const char* value, size_t size) {
  set_has_agreementno();
  if (agreementno_ == &::google::protobuf::internal::kEmptyString) {
    agreementno_ = new ::std::string;
  }
  agreementno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_agreementno() {
  set_has_agreementno();
  if (agreementno_ == &::google::protobuf::internal::kEmptyString) {
    agreementno_ = new ::std::string;
  }
  return agreementno_;
}
inline ::std::string* INF_OneEntrust_Req::release_agreementno() {
  clear_has_agreementno();
  if (agreementno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agreementno_;
    agreementno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OppositeTradeUnit = 21;
inline bool INF_OneEntrust_Req::has_oppositetradeunit() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_oppositetradeunit() {
  _has_bits_[0] |= 0x00100000u;
}
inline void INF_OneEntrust_Req::clear_has_oppositetradeunit() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void INF_OneEntrust_Req::clear_oppositetradeunit() {
  if (oppositetradeunit_ != &::google::protobuf::internal::kEmptyString) {
    oppositetradeunit_->clear();
  }
  clear_has_oppositetradeunit();
}
inline const ::std::string& INF_OneEntrust_Req::oppositetradeunit() const {
  return *oppositetradeunit_;
}
inline void INF_OneEntrust_Req::set_oppositetradeunit(const ::std::string& value) {
  set_has_oppositetradeunit();
  if (oppositetradeunit_ == &::google::protobuf::internal::kEmptyString) {
    oppositetradeunit_ = new ::std::string;
  }
  oppositetradeunit_->assign(value);
}
inline void INF_OneEntrust_Req::set_oppositetradeunit(const char* value) {
  set_has_oppositetradeunit();
  if (oppositetradeunit_ == &::google::protobuf::internal::kEmptyString) {
    oppositetradeunit_ = new ::std::string;
  }
  oppositetradeunit_->assign(value);
}
inline void INF_OneEntrust_Req::set_oppositetradeunit(const char* value, size_t size) {
  set_has_oppositetradeunit();
  if (oppositetradeunit_ == &::google::protobuf::internal::kEmptyString) {
    oppositetradeunit_ = new ::std::string;
  }
  oppositetradeunit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_oppositetradeunit() {
  set_has_oppositetradeunit();
  if (oppositetradeunit_ == &::google::protobuf::internal::kEmptyString) {
    oppositetradeunit_ = new ::std::string;
  }
  return oppositetradeunit_;
}
inline ::std::string* INF_OneEntrust_Req::release_oppositetradeunit() {
  clear_has_oppositetradeunit();
  if (oppositetradeunit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oppositetradeunit_;
    oppositetradeunit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BargainNO = 22;
inline bool INF_OneEntrust_Req::has_bargainno() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_bargainno() {
  _has_bits_[0] |= 0x00200000u;
}
inline void INF_OneEntrust_Req::clear_has_bargainno() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void INF_OneEntrust_Req::clear_bargainno() {
  if (bargainno_ != &::google::protobuf::internal::kEmptyString) {
    bargainno_->clear();
  }
  clear_has_bargainno();
}
inline const ::std::string& INF_OneEntrust_Req::bargainno() const {
  return *bargainno_;
}
inline void INF_OneEntrust_Req::set_bargainno(const ::std::string& value) {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  bargainno_->assign(value);
}
inline void INF_OneEntrust_Req::set_bargainno(const char* value) {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  bargainno_->assign(value);
}
inline void INF_OneEntrust_Req::set_bargainno(const char* value, size_t size) {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  bargainno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_bargainno() {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  return bargainno_;
}
inline ::std::string* INF_OneEntrust_Req::release_bargainno() {
  clear_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bargainno_;
    bargainno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BsettleVipNO = 23;
inline bool INF_OneEntrust_Req::has_bsettlevipno() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_bsettlevipno() {
  _has_bits_[0] |= 0x00400000u;
}
inline void INF_OneEntrust_Req::clear_has_bsettlevipno() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void INF_OneEntrust_Req::clear_bsettlevipno() {
  if (bsettlevipno_ != &::google::protobuf::internal::kEmptyString) {
    bsettlevipno_->clear();
  }
  clear_has_bsettlevipno();
}
inline const ::std::string& INF_OneEntrust_Req::bsettlevipno() const {
  return *bsettlevipno_;
}
inline void INF_OneEntrust_Req::set_bsettlevipno(const ::std::string& value) {
  set_has_bsettlevipno();
  if (bsettlevipno_ == &::google::protobuf::internal::kEmptyString) {
    bsettlevipno_ = new ::std::string;
  }
  bsettlevipno_->assign(value);
}
inline void INF_OneEntrust_Req::set_bsettlevipno(const char* value) {
  set_has_bsettlevipno();
  if (bsettlevipno_ == &::google::protobuf::internal::kEmptyString) {
    bsettlevipno_ = new ::std::string;
  }
  bsettlevipno_->assign(value);
}
inline void INF_OneEntrust_Req::set_bsettlevipno(const char* value, size_t size) {
  set_has_bsettlevipno();
  if (bsettlevipno_ == &::google::protobuf::internal::kEmptyString) {
    bsettlevipno_ = new ::std::string;
  }
  bsettlevipno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_bsettlevipno() {
  set_has_bsettlevipno();
  if (bsettlevipno_ == &::google::protobuf::internal::kEmptyString) {
    bsettlevipno_ = new ::std::string;
  }
  return bsettlevipno_;
}
inline ::std::string* INF_OneEntrust_Req::release_bsettlevipno() {
  clear_has_bsettlevipno();
  if (bsettlevipno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bsettlevipno_;
    bsettlevipno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsLowPriceEntrust = 24;
inline bool INF_OneEntrust_Req::has_islowpriceentrust() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void INF_OneEntrust_Req::set_has_islowpriceentrust() {
  _has_bits_[0] |= 0x00800000u;
}
inline void INF_OneEntrust_Req::clear_has_islowpriceentrust() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void INF_OneEntrust_Req::clear_islowpriceentrust() {
  if (islowpriceentrust_ != &::google::protobuf::internal::kEmptyString) {
    islowpriceentrust_->clear();
  }
  clear_has_islowpriceentrust();
}
inline const ::std::string& INF_OneEntrust_Req::islowpriceentrust() const {
  return *islowpriceentrust_;
}
inline void INF_OneEntrust_Req::set_islowpriceentrust(const ::std::string& value) {
  set_has_islowpriceentrust();
  if (islowpriceentrust_ == &::google::protobuf::internal::kEmptyString) {
    islowpriceentrust_ = new ::std::string;
  }
  islowpriceentrust_->assign(value);
}
inline void INF_OneEntrust_Req::set_islowpriceentrust(const char* value) {
  set_has_islowpriceentrust();
  if (islowpriceentrust_ == &::google::protobuf::internal::kEmptyString) {
    islowpriceentrust_ = new ::std::string;
  }
  islowpriceentrust_->assign(value);
}
inline void INF_OneEntrust_Req::set_islowpriceentrust(const char* value, size_t size) {
  set_has_islowpriceentrust();
  if (islowpriceentrust_ == &::google::protobuf::internal::kEmptyString) {
    islowpriceentrust_ = new ::std::string;
  }
  islowpriceentrust_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Req::mutable_islowpriceentrust() {
  set_has_islowpriceentrust();
  if (islowpriceentrust_ == &::google::protobuf::internal::kEmptyString) {
    islowpriceentrust_ = new ::std::string;
  }
  return islowpriceentrust_;
}
inline ::std::string* INF_OneEntrust_Req::release_islowpriceentrust() {
  clear_has_islowpriceentrust();
  if (islowpriceentrust_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = islowpriceentrust_;
    islowpriceentrust_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_OneCancel_Req

// optional string RT0 = 1;
inline bool INF_OneCancel_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_OneCancel_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_OneCancel_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_OneCancel_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_OneCancel_Req::rt0() const {
  return *rt0_;
}
inline void INF_OneCancel_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_OneCancel_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_OneCancel_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_OneCancel_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_OneCancel_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_OneCancel_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_OneCancel_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_OneCancel_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_OneCancel_Req::localhost() const {
  return *localhost_;
}
inline void INF_OneCancel_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_OneCancel_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_OneCancel_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_OneCancel_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_OneCancel_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_OneCancel_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_OneCancel_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_OneCancel_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_OneCancel_Req::reqid() const {
  return *reqid_;
}
inline void INF_OneCancel_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_OneCancel_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_OneCancel_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_OneCancel_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_OneCancel_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_OneCancel_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_OneCancel_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_OneCancel_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_OneCancel_Req::funcid() const {
  return *funcid_;
}
inline void INF_OneCancel_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_OneCancel_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_OneCancel_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_OneCancel_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_OneCancel_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_OneCancel_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_OneCancel_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_OneCancel_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_OneCancel_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_OneCancel_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_OneCancel_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_OneCancel_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_OneCancel_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MarketID = 6;
inline bool INF_OneCancel_Req::has_marketid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_OneCancel_Req::set_has_marketid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_OneCancel_Req::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_OneCancel_Req::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_OneCancel_Req::marketid() const {
  return *marketid_;
}
inline void INF_OneCancel_Req::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_OneCancel_Req::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_OneCancel_Req::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Req::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_OneCancel_Req::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_OneCancel_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_OneCancel_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_OneCancel_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_OneCancel_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_OneCancel_Req::rt6() const {
  return *rt6_;
}
inline void INF_OneCancel_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_OneCancel_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_OneCancel_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_OneCancel_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_OneCancel_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_OneCancel_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_OneCancel_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_OneCancel_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_OneCancel_Req::customid() const {
  return *customid_;
}
inline void INF_OneCancel_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_OneCancel_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_OneCancel_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_OneCancel_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustSerial = 9;
inline bool INF_OneCancel_Req::has_entrustserial() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_OneCancel_Req::set_has_entrustserial() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_OneCancel_Req::clear_has_entrustserial() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_OneCancel_Req::clear_entrustserial() {
  if (entrustserial_ != &::google::protobuf::internal::kEmptyString) {
    entrustserial_->clear();
  }
  clear_has_entrustserial();
}
inline const ::std::string& INF_OneCancel_Req::entrustserial() const {
  return *entrustserial_;
}
inline void INF_OneCancel_Req::set_entrustserial(const ::std::string& value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_OneCancel_Req::set_entrustserial(const char* value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_OneCancel_Req::set_entrustserial(const char* value, size_t size) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Req::mutable_entrustserial() {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  return entrustserial_;
}
inline ::std::string* INF_OneCancel_Req::release_entrustserial() {
  clear_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustserial_;
    entrustserial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 10;
inline bool INF_OneCancel_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_OneCancel_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_OneCancel_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_OneCancel_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_OneCancel_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_OneCancel_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_OneCancel_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_OneCancel_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_OneCancel_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryOneEntrust_Req

// optional string RT0 = 1;
inline bool INF_QueryOneEntrust_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryOneEntrust_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt0() const {
  return *rt0_;
}
inline void INF_QueryOneEntrust_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_QueryOneEntrust_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryOneEntrust_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryOneEntrust_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_QueryOneEntrust_Req::localhost() const {
  return *localhost_;
}
inline void INF_QueryOneEntrust_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_QueryOneEntrust_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryOneEntrust_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryOneEntrust_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_QueryOneEntrust_Req::reqid() const {
  return *reqid_;
}
inline void INF_QueryOneEntrust_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_QueryOneEntrust_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryOneEntrust_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryOneEntrust_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_QueryOneEntrust_Req::funcid() const {
  return *funcid_;
}
inline void INF_QueryOneEntrust_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_QueryOneEntrust_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryOneEntrust_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryOneEntrust_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_QueryOneEntrust_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_QueryOneEntrust_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT5 = 6;
inline bool INF_QueryOneEntrust_Req::has_rt5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryOneEntrust_Req::clear_rt5() {
  if (rt5_ != &::google::protobuf::internal::kEmptyString) {
    rt5_->clear();
  }
  clear_has_rt5();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt5() const {
  return *rt5_;
}
inline void INF_QueryOneEntrust_Req::set_rt5(const ::std::string& value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt5(const char* value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt5(const char* value, size_t size) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt5() {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  return rt5_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt5() {
  clear_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt5_;
    rt5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_QueryOneEntrust_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryOneEntrust_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt6() const {
  return *rt6_;
}
inline void INF_QueryOneEntrust_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_QueryOneEntrust_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryOneEntrust_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryOneEntrust_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_QueryOneEntrust_Req::customid() const {
  return *customid_;
}
inline void INF_QueryOneEntrust_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT8 = 9;
inline bool INF_QueryOneEntrust_Req::has_rt8() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt8() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt8() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryOneEntrust_Req::clear_rt8() {
  if (rt8_ != &::google::protobuf::internal::kEmptyString) {
    rt8_->clear();
  }
  clear_has_rt8();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt8() const {
  return *rt8_;
}
inline void INF_QueryOneEntrust_Req::set_rt8(const ::std::string& value) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt8(const char* value) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt8(const char* value, size_t size) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt8() {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  return rt8_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt8() {
  clear_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt8_;
    rt8_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT9 = 10;
inline bool INF_QueryOneEntrust_Req::has_rt9() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt9() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt9() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryOneEntrust_Req::clear_rt9() {
  if (rt9_ != &::google::protobuf::internal::kEmptyString) {
    rt9_->clear();
  }
  clear_has_rt9();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt9() const {
  return *rt9_;
}
inline void INF_QueryOneEntrust_Req::set_rt9(const ::std::string& value) {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  rt9_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt9(const char* value) {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  rt9_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt9(const char* value, size_t size) {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  rt9_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt9() {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  return rt9_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt9() {
  clear_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt9_;
    rt9_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustSerial = 11;
inline bool INF_QueryOneEntrust_Req::has_entrustserial() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_entrustserial() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryOneEntrust_Req::clear_has_entrustserial() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryOneEntrust_Req::clear_entrustserial() {
  if (entrustserial_ != &::google::protobuf::internal::kEmptyString) {
    entrustserial_->clear();
  }
  clear_has_entrustserial();
}
inline const ::std::string& INF_QueryOneEntrust_Req::entrustserial() const {
  return *entrustserial_;
}
inline void INF_QueryOneEntrust_Req::set_entrustserial(const ::std::string& value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_entrustserial(const char* value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_entrustserial(const char* value, size_t size) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_entrustserial() {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  return entrustserial_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_entrustserial() {
  clear_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustserial_;
    entrustserial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT11 = 12;
inline bool INF_QueryOneEntrust_Req::has_rt11() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt11() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt11() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryOneEntrust_Req::clear_rt11() {
  if (rt11_ != &::google::protobuf::internal::kEmptyString) {
    rt11_->clear();
  }
  clear_has_rt11();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt11() const {
  return *rt11_;
}
inline void INF_QueryOneEntrust_Req::set_rt11(const ::std::string& value) {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  rt11_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt11(const char* value) {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  rt11_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt11(const char* value, size_t size) {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  rt11_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt11() {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  return rt11_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt11() {
  clear_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt11_;
    rt11_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT12 = 13;
inline bool INF_QueryOneEntrust_Req::has_rt12() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt12() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt12() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_QueryOneEntrust_Req::clear_rt12() {
  if (rt12_ != &::google::protobuf::internal::kEmptyString) {
    rt12_->clear();
  }
  clear_has_rt12();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt12() const {
  return *rt12_;
}
inline void INF_QueryOneEntrust_Req::set_rt12(const ::std::string& value) {
  set_has_rt12();
  if (rt12_ == &::google::protobuf::internal::kEmptyString) {
    rt12_ = new ::std::string;
  }
  rt12_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt12(const char* value) {
  set_has_rt12();
  if (rt12_ == &::google::protobuf::internal::kEmptyString) {
    rt12_ = new ::std::string;
  }
  rt12_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt12(const char* value, size_t size) {
  set_has_rt12();
  if (rt12_ == &::google::protobuf::internal::kEmptyString) {
    rt12_ = new ::std::string;
  }
  rt12_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt12() {
  set_has_rt12();
  if (rt12_ == &::google::protobuf::internal::kEmptyString) {
    rt12_ = new ::std::string;
  }
  return rt12_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt12() {
  clear_has_rt12();
  if (rt12_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt12_;
    rt12_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT13 = 14;
inline bool INF_QueryOneEntrust_Req::has_rt13() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt13() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt13() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_QueryOneEntrust_Req::clear_rt13() {
  if (rt13_ != &::google::protobuf::internal::kEmptyString) {
    rt13_->clear();
  }
  clear_has_rt13();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt13() const {
  return *rt13_;
}
inline void INF_QueryOneEntrust_Req::set_rt13(const ::std::string& value) {
  set_has_rt13();
  if (rt13_ == &::google::protobuf::internal::kEmptyString) {
    rt13_ = new ::std::string;
  }
  rt13_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt13(const char* value) {
  set_has_rt13();
  if (rt13_ == &::google::protobuf::internal::kEmptyString) {
    rt13_ = new ::std::string;
  }
  rt13_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt13(const char* value, size_t size) {
  set_has_rt13();
  if (rt13_ == &::google::protobuf::internal::kEmptyString) {
    rt13_ = new ::std::string;
  }
  rt13_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt13() {
  set_has_rt13();
  if (rt13_ == &::google::protobuf::internal::kEmptyString) {
    rt13_ = new ::std::string;
  }
  return rt13_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt13() {
  clear_has_rt13();
  if (rt13_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt13_;
    rt13_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT14 = 15;
inline bool INF_QueryOneEntrust_Req::has_rt14() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt14() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt14() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_QueryOneEntrust_Req::clear_rt14() {
  if (rt14_ != &::google::protobuf::internal::kEmptyString) {
    rt14_->clear();
  }
  clear_has_rt14();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt14() const {
  return *rt14_;
}
inline void INF_QueryOneEntrust_Req::set_rt14(const ::std::string& value) {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  rt14_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt14(const char* value) {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  rt14_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt14(const char* value, size_t size) {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  rt14_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt14() {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  return rt14_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt14() {
  clear_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt14_;
    rt14_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 16;
inline bool INF_QueryOneEntrust_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_QueryOneEntrust_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryOneEntrust_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryOneEntrust_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT16 = 17;
inline bool INF_QueryOneEntrust_Req::has_rt16() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt16() {
  _has_bits_[0] |= 0x00010000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt16() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void INF_QueryOneEntrust_Req::clear_rt16() {
  if (rt16_ != &::google::protobuf::internal::kEmptyString) {
    rt16_->clear();
  }
  clear_has_rt16();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt16() const {
  return *rt16_;
}
inline void INF_QueryOneEntrust_Req::set_rt16(const ::std::string& value) {
  set_has_rt16();
  if (rt16_ == &::google::protobuf::internal::kEmptyString) {
    rt16_ = new ::std::string;
  }
  rt16_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt16(const char* value) {
  set_has_rt16();
  if (rt16_ == &::google::protobuf::internal::kEmptyString) {
    rt16_ = new ::std::string;
  }
  rt16_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt16(const char* value, size_t size) {
  set_has_rt16();
  if (rt16_ == &::google::protobuf::internal::kEmptyString) {
    rt16_ = new ::std::string;
  }
  rt16_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt16() {
  set_has_rt16();
  if (rt16_ == &::google::protobuf::internal::kEmptyString) {
    rt16_ = new ::std::string;
  }
  return rt16_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt16() {
  clear_has_rt16();
  if (rt16_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt16_;
    rt16_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT17 = 18;
inline bool INF_QueryOneEntrust_Req::has_rt17() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt17() {
  _has_bits_[0] |= 0x00020000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt17() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void INF_QueryOneEntrust_Req::clear_rt17() {
  if (rt17_ != &::google::protobuf::internal::kEmptyString) {
    rt17_->clear();
  }
  clear_has_rt17();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt17() const {
  return *rt17_;
}
inline void INF_QueryOneEntrust_Req::set_rt17(const ::std::string& value) {
  set_has_rt17();
  if (rt17_ == &::google::protobuf::internal::kEmptyString) {
    rt17_ = new ::std::string;
  }
  rt17_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt17(const char* value) {
  set_has_rt17();
  if (rt17_ == &::google::protobuf::internal::kEmptyString) {
    rt17_ = new ::std::string;
  }
  rt17_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt17(const char* value, size_t size) {
  set_has_rt17();
  if (rt17_ == &::google::protobuf::internal::kEmptyString) {
    rt17_ = new ::std::string;
  }
  rt17_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt17() {
  set_has_rt17();
  if (rt17_ == &::google::protobuf::internal::kEmptyString) {
    rt17_ = new ::std::string;
  }
  return rt17_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt17() {
  clear_has_rt17();
  if (rt17_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt17_;
    rt17_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT18 = 19;
inline bool INF_QueryOneEntrust_Req::has_rt18() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt18() {
  _has_bits_[0] |= 0x00040000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt18() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void INF_QueryOneEntrust_Req::clear_rt18() {
  if (rt18_ != &::google::protobuf::internal::kEmptyString) {
    rt18_->clear();
  }
  clear_has_rt18();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt18() const {
  return *rt18_;
}
inline void INF_QueryOneEntrust_Req::set_rt18(const ::std::string& value) {
  set_has_rt18();
  if (rt18_ == &::google::protobuf::internal::kEmptyString) {
    rt18_ = new ::std::string;
  }
  rt18_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt18(const char* value) {
  set_has_rt18();
  if (rt18_ == &::google::protobuf::internal::kEmptyString) {
    rt18_ = new ::std::string;
  }
  rt18_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt18(const char* value, size_t size) {
  set_has_rt18();
  if (rt18_ == &::google::protobuf::internal::kEmptyString) {
    rt18_ = new ::std::string;
  }
  rt18_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt18() {
  set_has_rt18();
  if (rt18_ == &::google::protobuf::internal::kEmptyString) {
    rt18_ = new ::std::string;
  }
  return rt18_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt18() {
  clear_has_rt18();
  if (rt18_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt18_;
    rt18_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT19 = 20;
inline bool INF_QueryOneEntrust_Req::has_rt19() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt19() {
  _has_bits_[0] |= 0x00080000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt19() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void INF_QueryOneEntrust_Req::clear_rt19() {
  if (rt19_ != &::google::protobuf::internal::kEmptyString) {
    rt19_->clear();
  }
  clear_has_rt19();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt19() const {
  return *rt19_;
}
inline void INF_QueryOneEntrust_Req::set_rt19(const ::std::string& value) {
  set_has_rt19();
  if (rt19_ == &::google::protobuf::internal::kEmptyString) {
    rt19_ = new ::std::string;
  }
  rt19_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt19(const char* value) {
  set_has_rt19();
  if (rt19_ == &::google::protobuf::internal::kEmptyString) {
    rt19_ = new ::std::string;
  }
  rt19_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt19(const char* value, size_t size) {
  set_has_rt19();
  if (rt19_ == &::google::protobuf::internal::kEmptyString) {
    rt19_ = new ::std::string;
  }
  rt19_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt19() {
  set_has_rt19();
  if (rt19_ == &::google::protobuf::internal::kEmptyString) {
    rt19_ = new ::std::string;
  }
  return rt19_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt19() {
  clear_has_rt19();
  if (rt19_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt19_;
    rt19_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT20 = 21;
inline bool INF_QueryOneEntrust_Req::has_rt20() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt20() {
  _has_bits_[0] |= 0x00100000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt20() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void INF_QueryOneEntrust_Req::clear_rt20() {
  if (rt20_ != &::google::protobuf::internal::kEmptyString) {
    rt20_->clear();
  }
  clear_has_rt20();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt20() const {
  return *rt20_;
}
inline void INF_QueryOneEntrust_Req::set_rt20(const ::std::string& value) {
  set_has_rt20();
  if (rt20_ == &::google::protobuf::internal::kEmptyString) {
    rt20_ = new ::std::string;
  }
  rt20_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt20(const char* value) {
  set_has_rt20();
  if (rt20_ == &::google::protobuf::internal::kEmptyString) {
    rt20_ = new ::std::string;
  }
  rt20_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt20(const char* value, size_t size) {
  set_has_rt20();
  if (rt20_ == &::google::protobuf::internal::kEmptyString) {
    rt20_ = new ::std::string;
  }
  rt20_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt20() {
  set_has_rt20();
  if (rt20_ == &::google::protobuf::internal::kEmptyString) {
    rt20_ = new ::std::string;
  }
  return rt20_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt20() {
  clear_has_rt20();
  if (rt20_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt20_;
    rt20_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT21 = 22;
inline bool INF_QueryOneEntrust_Req::has_rt21() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_rt21() {
  _has_bits_[0] |= 0x00200000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_rt21() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void INF_QueryOneEntrust_Req::clear_rt21() {
  if (rt21_ != &::google::protobuf::internal::kEmptyString) {
    rt21_->clear();
  }
  clear_has_rt21();
}
inline const ::std::string& INF_QueryOneEntrust_Req::rt21() const {
  return *rt21_;
}
inline void INF_QueryOneEntrust_Req::set_rt21(const ::std::string& value) {
  set_has_rt21();
  if (rt21_ == &::google::protobuf::internal::kEmptyString) {
    rt21_ = new ::std::string;
  }
  rt21_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt21(const char* value) {
  set_has_rt21();
  if (rt21_ == &::google::protobuf::internal::kEmptyString) {
    rt21_ = new ::std::string;
  }
  rt21_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_rt21(const char* value, size_t size) {
  set_has_rt21();
  if (rt21_ == &::google::protobuf::internal::kEmptyString) {
    rt21_ = new ::std::string;
  }
  rt21_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_rt21() {
  set_has_rt21();
  if (rt21_ == &::google::protobuf::internal::kEmptyString) {
    rt21_ = new ::std::string;
  }
  return rt21_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_rt21() {
  clear_has_rt21();
  if (rt21_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt21_;
    rt21_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsCancel = 23;
inline bool INF_QueryOneEntrust_Req::has_iscancel() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void INF_QueryOneEntrust_Req::set_has_iscancel() {
  _has_bits_[0] |= 0x00400000u;
}
inline void INF_QueryOneEntrust_Req::clear_has_iscancel() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void INF_QueryOneEntrust_Req::clear_iscancel() {
  if (iscancel_ != &::google::protobuf::internal::kEmptyString) {
    iscancel_->clear();
  }
  clear_has_iscancel();
}
inline const ::std::string& INF_QueryOneEntrust_Req::iscancel() const {
  return *iscancel_;
}
inline void INF_QueryOneEntrust_Req::set_iscancel(const ::std::string& value) {
  set_has_iscancel();
  if (iscancel_ == &::google::protobuf::internal::kEmptyString) {
    iscancel_ = new ::std::string;
  }
  iscancel_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_iscancel(const char* value) {
  set_has_iscancel();
  if (iscancel_ == &::google::protobuf::internal::kEmptyString) {
    iscancel_ = new ::std::string;
  }
  iscancel_->assign(value);
}
inline void INF_QueryOneEntrust_Req::set_iscancel(const char* value, size_t size) {
  set_has_iscancel();
  if (iscancel_ == &::google::protobuf::internal::kEmptyString) {
    iscancel_ = new ::std::string;
  }
  iscancel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Req::mutable_iscancel() {
  set_has_iscancel();
  if (iscancel_ == &::google::protobuf::internal::kEmptyString) {
    iscancel_ = new ::std::string;
  }
  return iscancel_;
}
inline ::std::string* INF_QueryOneEntrust_Req::release_iscancel() {
  clear_has_iscancel();
  if (iscancel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iscancel_;
    iscancel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryCJMX_Req

// optional string RT0 = 1;
inline bool INF_QueryCJMX_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryCJMX_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryCJMX_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_QueryCJMX_Req::rt0() const {
  return *rt0_;
}
inline void INF_QueryCJMX_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryCJMX_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryCJMX_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_QueryCJMX_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_QueryCJMX_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryCJMX_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryCJMX_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_QueryCJMX_Req::localhost() const {
  return *localhost_;
}
inline void INF_QueryCJMX_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryCJMX_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryCJMX_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_QueryCJMX_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_QueryCJMX_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryCJMX_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryCJMX_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_QueryCJMX_Req::reqid() const {
  return *reqid_;
}
inline void INF_QueryCJMX_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryCJMX_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryCJMX_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_QueryCJMX_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_QueryCJMX_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryCJMX_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryCJMX_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_QueryCJMX_Req::funcid() const {
  return *funcid_;
}
inline void INF_QueryCJMX_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryCJMX_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryCJMX_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_QueryCJMX_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_QueryCJMX_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryCJMX_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryCJMX_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_QueryCJMX_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_QueryCJMX_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryCJMX_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryCJMX_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_QueryCJMX_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT5 = 6;
inline bool INF_QueryCJMX_Req::has_rt5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_rt5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryCJMX_Req::clear_has_rt5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryCJMX_Req::clear_rt5() {
  if (rt5_ != &::google::protobuf::internal::kEmptyString) {
    rt5_->clear();
  }
  clear_has_rt5();
}
inline const ::std::string& INF_QueryCJMX_Req::rt5() const {
  return *rt5_;
}
inline void INF_QueryCJMX_Req::set_rt5(const ::std::string& value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_QueryCJMX_Req::set_rt5(const char* value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_QueryCJMX_Req::set_rt5(const char* value, size_t size) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_rt5() {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  return rt5_;
}
inline ::std::string* INF_QueryCJMX_Req::release_rt5() {
  clear_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt5_;
    rt5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_QueryCJMX_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryCJMX_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryCJMX_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_QueryCJMX_Req::rt6() const {
  return *rt6_;
}
inline void INF_QueryCJMX_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryCJMX_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryCJMX_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_QueryCJMX_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_QueryCJMX_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryCJMX_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryCJMX_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_QueryCJMX_Req::customid() const {
  return *customid_;
}
inline void INF_QueryCJMX_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryCJMX_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryCJMX_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_QueryCJMX_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT8 = 9;
inline bool INF_QueryCJMX_Req::has_rt8() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_rt8() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryCJMX_Req::clear_has_rt8() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryCJMX_Req::clear_rt8() {
  if (rt8_ != &::google::protobuf::internal::kEmptyString) {
    rt8_->clear();
  }
  clear_has_rt8();
}
inline const ::std::string& INF_QueryCJMX_Req::rt8() const {
  return *rt8_;
}
inline void INF_QueryCJMX_Req::set_rt8(const ::std::string& value) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(value);
}
inline void INF_QueryCJMX_Req::set_rt8(const char* value) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(value);
}
inline void INF_QueryCJMX_Req::set_rt8(const char* value, size_t size) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_rt8() {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  return rt8_;
}
inline ::std::string* INF_QueryCJMX_Req::release_rt8() {
  clear_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt8_;
    rt8_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT9 = 10;
inline bool INF_QueryCJMX_Req::has_rt9() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_rt9() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryCJMX_Req::clear_has_rt9() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryCJMX_Req::clear_rt9() {
  if (rt9_ != &::google::protobuf::internal::kEmptyString) {
    rt9_->clear();
  }
  clear_has_rt9();
}
inline const ::std::string& INF_QueryCJMX_Req::rt9() const {
  return *rt9_;
}
inline void INF_QueryCJMX_Req::set_rt9(const ::std::string& value) {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  rt9_->assign(value);
}
inline void INF_QueryCJMX_Req::set_rt9(const char* value) {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  rt9_->assign(value);
}
inline void INF_QueryCJMX_Req::set_rt9(const char* value, size_t size) {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  rt9_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_rt9() {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  return rt9_;
}
inline ::std::string* INF_QueryCJMX_Req::release_rt9() {
  clear_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt9_;
    rt9_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DIRECTION = 11;
inline bool INF_QueryCJMX_Req::has_direction() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_direction() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryCJMX_Req::clear_has_direction() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryCJMX_Req::clear_direction() {
  if (direction_ != &::google::protobuf::internal::kEmptyString) {
    direction_->clear();
  }
  clear_has_direction();
}
inline const ::std::string& INF_QueryCJMX_Req::direction() const {
  return *direction_;
}
inline void INF_QueryCJMX_Req::set_direction(const ::std::string& value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void INF_QueryCJMX_Req::set_direction(const char* value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void INF_QueryCJMX_Req::set_direction(const char* value, size_t size) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_direction() {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  return direction_;
}
inline ::std::string* INF_QueryCJMX_Req::release_direction() {
  clear_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = direction_;
    direction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CJMXmax = 12;
inline bool INF_QueryCJMX_Req::has_cjmxmax() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_cjmxmax() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryCJMX_Req::clear_has_cjmxmax() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryCJMX_Req::clear_cjmxmax() {
  if (cjmxmax_ != &::google::protobuf::internal::kEmptyString) {
    cjmxmax_->clear();
  }
  clear_has_cjmxmax();
}
inline const ::std::string& INF_QueryCJMX_Req::cjmxmax() const {
  return *cjmxmax_;
}
inline void INF_QueryCJMX_Req::set_cjmxmax(const ::std::string& value) {
  set_has_cjmxmax();
  if (cjmxmax_ == &::google::protobuf::internal::kEmptyString) {
    cjmxmax_ = new ::std::string;
  }
  cjmxmax_->assign(value);
}
inline void INF_QueryCJMX_Req::set_cjmxmax(const char* value) {
  set_has_cjmxmax();
  if (cjmxmax_ == &::google::protobuf::internal::kEmptyString) {
    cjmxmax_ = new ::std::string;
  }
  cjmxmax_->assign(value);
}
inline void INF_QueryCJMX_Req::set_cjmxmax(const char* value, size_t size) {
  set_has_cjmxmax();
  if (cjmxmax_ == &::google::protobuf::internal::kEmptyString) {
    cjmxmax_ = new ::std::string;
  }
  cjmxmax_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_cjmxmax() {
  set_has_cjmxmax();
  if (cjmxmax_ == &::google::protobuf::internal::kEmptyString) {
    cjmxmax_ = new ::std::string;
  }
  return cjmxmax_;
}
inline ::std::string* INF_QueryCJMX_Req::release_cjmxmax() {
  clear_has_cjmxmax();
  if (cjmxmax_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjmxmax_;
    cjmxmax_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CJMXmode = 13;
inline bool INF_QueryCJMX_Req::has_cjmxmode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_cjmxmode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_QueryCJMX_Req::clear_has_cjmxmode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_QueryCJMX_Req::clear_cjmxmode() {
  if (cjmxmode_ != &::google::protobuf::internal::kEmptyString) {
    cjmxmode_->clear();
  }
  clear_has_cjmxmode();
}
inline const ::std::string& INF_QueryCJMX_Req::cjmxmode() const {
  return *cjmxmode_;
}
inline void INF_QueryCJMX_Req::set_cjmxmode(const ::std::string& value) {
  set_has_cjmxmode();
  if (cjmxmode_ == &::google::protobuf::internal::kEmptyString) {
    cjmxmode_ = new ::std::string;
  }
  cjmxmode_->assign(value);
}
inline void INF_QueryCJMX_Req::set_cjmxmode(const char* value) {
  set_has_cjmxmode();
  if (cjmxmode_ == &::google::protobuf::internal::kEmptyString) {
    cjmxmode_ = new ::std::string;
  }
  cjmxmode_->assign(value);
}
inline void INF_QueryCJMX_Req::set_cjmxmode(const char* value, size_t size) {
  set_has_cjmxmode();
  if (cjmxmode_ == &::google::protobuf::internal::kEmptyString) {
    cjmxmode_ = new ::std::string;
  }
  cjmxmode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_cjmxmode() {
  set_has_cjmxmode();
  if (cjmxmode_ == &::google::protobuf::internal::kEmptyString) {
    cjmxmode_ = new ::std::string;
  }
  return cjmxmode_;
}
inline ::std::string* INF_QueryCJMX_Req::release_cjmxmode() {
  clear_has_cjmxmode();
  if (cjmxmode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjmxmode_;
    cjmxmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string QueryStartPos = 14;
inline bool INF_QueryCJMX_Req::has_querystartpos() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_querystartpos() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_QueryCJMX_Req::clear_has_querystartpos() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_QueryCJMX_Req::clear_querystartpos() {
  if (querystartpos_ != &::google::protobuf::internal::kEmptyString) {
    querystartpos_->clear();
  }
  clear_has_querystartpos();
}
inline const ::std::string& INF_QueryCJMX_Req::querystartpos() const {
  return *querystartpos_;
}
inline void INF_QueryCJMX_Req::set_querystartpos(const ::std::string& value) {
  set_has_querystartpos();
  if (querystartpos_ == &::google::protobuf::internal::kEmptyString) {
    querystartpos_ = new ::std::string;
  }
  querystartpos_->assign(value);
}
inline void INF_QueryCJMX_Req::set_querystartpos(const char* value) {
  set_has_querystartpos();
  if (querystartpos_ == &::google::protobuf::internal::kEmptyString) {
    querystartpos_ = new ::std::string;
  }
  querystartpos_->assign(value);
}
inline void INF_QueryCJMX_Req::set_querystartpos(const char* value, size_t size) {
  set_has_querystartpos();
  if (querystartpos_ == &::google::protobuf::internal::kEmptyString) {
    querystartpos_ = new ::std::string;
  }
  querystartpos_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_querystartpos() {
  set_has_querystartpos();
  if (querystartpos_ == &::google::protobuf::internal::kEmptyString) {
    querystartpos_ = new ::std::string;
  }
  return querystartpos_;
}
inline ::std::string* INF_QueryCJMX_Req::release_querystartpos() {
  clear_has_querystartpos();
  if (querystartpos_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = querystartpos_;
    querystartpos_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 15;
inline bool INF_QueryCJMX_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_QueryCJMX_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_QueryCJMX_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryCJMX_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryCJMX_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryCJMX_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryCJMX_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryCJMX_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string QueryType = 16;
inline bool INF_QueryCJMX_Req::has_querytype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_QueryCJMX_Req::set_has_querytype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_QueryCJMX_Req::clear_has_querytype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_QueryCJMX_Req::clear_querytype() {
  if (querytype_ != &::google::protobuf::internal::kEmptyString) {
    querytype_->clear();
  }
  clear_has_querytype();
}
inline const ::std::string& INF_QueryCJMX_Req::querytype() const {
  return *querytype_;
}
inline void INF_QueryCJMX_Req::set_querytype(const ::std::string& value) {
  set_has_querytype();
  if (querytype_ == &::google::protobuf::internal::kEmptyString) {
    querytype_ = new ::std::string;
  }
  querytype_->assign(value);
}
inline void INF_QueryCJMX_Req::set_querytype(const char* value) {
  set_has_querytype();
  if (querytype_ == &::google::protobuf::internal::kEmptyString) {
    querytype_ = new ::std::string;
  }
  querytype_->assign(value);
}
inline void INF_QueryCJMX_Req::set_querytype(const char* value, size_t size) {
  set_has_querytype();
  if (querytype_ == &::google::protobuf::internal::kEmptyString) {
    querytype_ = new ::std::string;
  }
  querytype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Req::mutable_querytype() {
  set_has_querytype();
  if (querytype_ == &::google::protobuf::internal::kEmptyString) {
    querytype_ = new ::std::string;
  }
  return querytype_;
}
inline ::std::string* INF_QueryCJMX_Req::release_querytype() {
  clear_has_querytype();
  if (querytype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = querytype_;
    querytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryPosition_Req

// optional string RT0 = 1;
inline bool INF_QueryPosition_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryPosition_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryPosition_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_QueryPosition_Req::rt0() const {
  return *rt0_;
}
inline void INF_QueryPosition_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_QueryPosition_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryPosition_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryPosition_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryPosition_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_QueryPosition_Req::localhost() const {
  return *localhost_;
}
inline void INF_QueryPosition_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryPosition_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryPosition_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_QueryPosition_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_QueryPosition_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryPosition_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryPosition_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryPosition_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_QueryPosition_Req::reqid() const {
  return *reqid_;
}
inline void INF_QueryPosition_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryPosition_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryPosition_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_QueryPosition_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_QueryPosition_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryPosition_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryPosition_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryPosition_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_QueryPosition_Req::funcid() const {
  return *funcid_;
}
inline void INF_QueryPosition_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryPosition_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryPosition_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_QueryPosition_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_QueryPosition_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryPosition_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryPosition_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryPosition_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_QueryPosition_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_QueryPosition_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryPosition_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryPosition_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_QueryPosition_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT5 = 6;
inline bool INF_QueryPosition_Req::has_rt5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryPosition_Req::clear_has_rt5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryPosition_Req::clear_rt5() {
  if (rt5_ != &::google::protobuf::internal::kEmptyString) {
    rt5_->clear();
  }
  clear_has_rt5();
}
inline const ::std::string& INF_QueryPosition_Req::rt5() const {
  return *rt5_;
}
inline void INF_QueryPosition_Req::set_rt5(const ::std::string& value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt5(const char* value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt5(const char* value, size_t size) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt5() {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  return rt5_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt5() {
  clear_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt5_;
    rt5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_QueryPosition_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryPosition_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryPosition_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_QueryPosition_Req::rt6() const {
  return *rt6_;
}
inline void INF_QueryPosition_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_QueryPosition_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryPosition_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryPosition_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryPosition_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_QueryPosition_Req::customid() const {
  return *customid_;
}
inline void INF_QueryPosition_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryPosition_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryPosition_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_QueryPosition_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT8 = 9;
inline bool INF_QueryPosition_Req::has_rt8() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt8() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryPosition_Req::clear_has_rt8() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryPosition_Req::clear_rt8() {
  if (rt8_ != &::google::protobuf::internal::kEmptyString) {
    rt8_->clear();
  }
  clear_has_rt8();
}
inline const ::std::string& INF_QueryPosition_Req::rt8() const {
  return *rt8_;
}
inline void INF_QueryPosition_Req::set_rt8(const ::std::string& value) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt8(const char* value) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt8(const char* value, size_t size) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt8() {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  return rt8_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt8() {
  clear_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt8_;
    rt8_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 10;
inline bool INF_QueryPosition_Req::has_securitycode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryPosition_Req::set_has_securitycode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryPosition_Req::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryPosition_Req::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_QueryPosition_Req::securitycode() const {
  return *securitycode_;
}
inline void INF_QueryPosition_Req::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryPosition_Req::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryPosition_Req::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_QueryPosition_Req::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT10 = 11;
inline bool INF_QueryPosition_Req::has_rt10() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt10() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryPosition_Req::clear_has_rt10() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryPosition_Req::clear_rt10() {
  if (rt10_ != &::google::protobuf::internal::kEmptyString) {
    rt10_->clear();
  }
  clear_has_rt10();
}
inline const ::std::string& INF_QueryPosition_Req::rt10() const {
  return *rt10_;
}
inline void INF_QueryPosition_Req::set_rt10(const ::std::string& value) {
  set_has_rt10();
  if (rt10_ == &::google::protobuf::internal::kEmptyString) {
    rt10_ = new ::std::string;
  }
  rt10_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt10(const char* value) {
  set_has_rt10();
  if (rt10_ == &::google::protobuf::internal::kEmptyString) {
    rt10_ = new ::std::string;
  }
  rt10_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt10(const char* value, size_t size) {
  set_has_rt10();
  if (rt10_ == &::google::protobuf::internal::kEmptyString) {
    rt10_ = new ::std::string;
  }
  rt10_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt10() {
  set_has_rt10();
  if (rt10_ == &::google::protobuf::internal::kEmptyString) {
    rt10_ = new ::std::string;
  }
  return rt10_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt10() {
  clear_has_rt10();
  if (rt10_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt10_;
    rt10_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT11 = 12;
inline bool INF_QueryPosition_Req::has_rt11() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt11() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryPosition_Req::clear_has_rt11() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryPosition_Req::clear_rt11() {
  if (rt11_ != &::google::protobuf::internal::kEmptyString) {
    rt11_->clear();
  }
  clear_has_rt11();
}
inline const ::std::string& INF_QueryPosition_Req::rt11() const {
  return *rt11_;
}
inline void INF_QueryPosition_Req::set_rt11(const ::std::string& value) {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  rt11_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt11(const char* value) {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  rt11_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt11(const char* value, size_t size) {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  rt11_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt11() {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  return rt11_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt11() {
  clear_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt11_;
    rt11_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT12 = 13;
inline bool INF_QueryPosition_Req::has_rt12() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt12() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_QueryPosition_Req::clear_has_rt12() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_QueryPosition_Req::clear_rt12() {
  if (rt12_ != &::google::protobuf::internal::kEmptyString) {
    rt12_->clear();
  }
  clear_has_rt12();
}
inline const ::std::string& INF_QueryPosition_Req::rt12() const {
  return *rt12_;
}
inline void INF_QueryPosition_Req::set_rt12(const ::std::string& value) {
  set_has_rt12();
  if (rt12_ == &::google::protobuf::internal::kEmptyString) {
    rt12_ = new ::std::string;
  }
  rt12_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt12(const char* value) {
  set_has_rt12();
  if (rt12_ == &::google::protobuf::internal::kEmptyString) {
    rt12_ = new ::std::string;
  }
  rt12_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt12(const char* value, size_t size) {
  set_has_rt12();
  if (rt12_ == &::google::protobuf::internal::kEmptyString) {
    rt12_ = new ::std::string;
  }
  rt12_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt12() {
  set_has_rt12();
  if (rt12_ == &::google::protobuf::internal::kEmptyString) {
    rt12_ = new ::std::string;
  }
  return rt12_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt12() {
  clear_has_rt12();
  if (rt12_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt12_;
    rt12_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT13 = 14;
inline bool INF_QueryPosition_Req::has_rt13() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt13() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_QueryPosition_Req::clear_has_rt13() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_QueryPosition_Req::clear_rt13() {
  if (rt13_ != &::google::protobuf::internal::kEmptyString) {
    rt13_->clear();
  }
  clear_has_rt13();
}
inline const ::std::string& INF_QueryPosition_Req::rt13() const {
  return *rt13_;
}
inline void INF_QueryPosition_Req::set_rt13(const ::std::string& value) {
  set_has_rt13();
  if (rt13_ == &::google::protobuf::internal::kEmptyString) {
    rt13_ = new ::std::string;
  }
  rt13_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt13(const char* value) {
  set_has_rt13();
  if (rt13_ == &::google::protobuf::internal::kEmptyString) {
    rt13_ = new ::std::string;
  }
  rt13_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt13(const char* value, size_t size) {
  set_has_rt13();
  if (rt13_ == &::google::protobuf::internal::kEmptyString) {
    rt13_ = new ::std::string;
  }
  rt13_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt13() {
  set_has_rt13();
  if (rt13_ == &::google::protobuf::internal::kEmptyString) {
    rt13_ = new ::std::string;
  }
  return rt13_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt13() {
  clear_has_rt13();
  if (rt13_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt13_;
    rt13_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT14 = 15;
inline bool INF_QueryPosition_Req::has_rt14() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt14() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_QueryPosition_Req::clear_has_rt14() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_QueryPosition_Req::clear_rt14() {
  if (rt14_ != &::google::protobuf::internal::kEmptyString) {
    rt14_->clear();
  }
  clear_has_rt14();
}
inline const ::std::string& INF_QueryPosition_Req::rt14() const {
  return *rt14_;
}
inline void INF_QueryPosition_Req::set_rt14(const ::std::string& value) {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  rt14_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt14(const char* value) {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  rt14_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt14(const char* value, size_t size) {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  rt14_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt14() {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  return rt14_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt14() {
  clear_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt14_;
    rt14_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OperateFunc = 16;
inline bool INF_QueryPosition_Req::has_operatefunc() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_QueryPosition_Req::set_has_operatefunc() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_QueryPosition_Req::clear_has_operatefunc() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_QueryPosition_Req::clear_operatefunc() {
  if (operatefunc_ != &::google::protobuf::internal::kEmptyString) {
    operatefunc_->clear();
  }
  clear_has_operatefunc();
}
inline const ::std::string& INF_QueryPosition_Req::operatefunc() const {
  return *operatefunc_;
}
inline void INF_QueryPosition_Req::set_operatefunc(const ::std::string& value) {
  set_has_operatefunc();
  if (operatefunc_ == &::google::protobuf::internal::kEmptyString) {
    operatefunc_ = new ::std::string;
  }
  operatefunc_->assign(value);
}
inline void INF_QueryPosition_Req::set_operatefunc(const char* value) {
  set_has_operatefunc();
  if (operatefunc_ == &::google::protobuf::internal::kEmptyString) {
    operatefunc_ = new ::std::string;
  }
  operatefunc_->assign(value);
}
inline void INF_QueryPosition_Req::set_operatefunc(const char* value, size_t size) {
  set_has_operatefunc();
  if (operatefunc_ == &::google::protobuf::internal::kEmptyString) {
    operatefunc_ = new ::std::string;
  }
  operatefunc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_operatefunc() {
  set_has_operatefunc();
  if (operatefunc_ == &::google::protobuf::internal::kEmptyString) {
    operatefunc_ = new ::std::string;
  }
  return operatefunc_;
}
inline ::std::string* INF_QueryPosition_Req::release_operatefunc() {
  clear_has_operatefunc();
  if (operatefunc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operatefunc_;
    operatefunc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 17;
inline bool INF_QueryPosition_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void INF_QueryPosition_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void INF_QueryPosition_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void INF_QueryPosition_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryPosition_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryPosition_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryPosition_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryPosition_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryPosition_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT17 = 18;
inline bool INF_QueryPosition_Req::has_rt17() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt17() {
  _has_bits_[0] |= 0x00020000u;
}
inline void INF_QueryPosition_Req::clear_has_rt17() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void INF_QueryPosition_Req::clear_rt17() {
  if (rt17_ != &::google::protobuf::internal::kEmptyString) {
    rt17_->clear();
  }
  clear_has_rt17();
}
inline const ::std::string& INF_QueryPosition_Req::rt17() const {
  return *rt17_;
}
inline void INF_QueryPosition_Req::set_rt17(const ::std::string& value) {
  set_has_rt17();
  if (rt17_ == &::google::protobuf::internal::kEmptyString) {
    rt17_ = new ::std::string;
  }
  rt17_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt17(const char* value) {
  set_has_rt17();
  if (rt17_ == &::google::protobuf::internal::kEmptyString) {
    rt17_ = new ::std::string;
  }
  rt17_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt17(const char* value, size_t size) {
  set_has_rt17();
  if (rt17_ == &::google::protobuf::internal::kEmptyString) {
    rt17_ = new ::std::string;
  }
  rt17_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt17() {
  set_has_rt17();
  if (rt17_ == &::google::protobuf::internal::kEmptyString) {
    rt17_ = new ::std::string;
  }
  return rt17_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt17() {
  clear_has_rt17();
  if (rt17_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt17_;
    rt17_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT18 = 19;
inline bool INF_QueryPosition_Req::has_rt18() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt18() {
  _has_bits_[0] |= 0x00040000u;
}
inline void INF_QueryPosition_Req::clear_has_rt18() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void INF_QueryPosition_Req::clear_rt18() {
  if (rt18_ != &::google::protobuf::internal::kEmptyString) {
    rt18_->clear();
  }
  clear_has_rt18();
}
inline const ::std::string& INF_QueryPosition_Req::rt18() const {
  return *rt18_;
}
inline void INF_QueryPosition_Req::set_rt18(const ::std::string& value) {
  set_has_rt18();
  if (rt18_ == &::google::protobuf::internal::kEmptyString) {
    rt18_ = new ::std::string;
  }
  rt18_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt18(const char* value) {
  set_has_rt18();
  if (rt18_ == &::google::protobuf::internal::kEmptyString) {
    rt18_ = new ::std::string;
  }
  rt18_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt18(const char* value, size_t size) {
  set_has_rt18();
  if (rt18_ == &::google::protobuf::internal::kEmptyString) {
    rt18_ = new ::std::string;
  }
  rt18_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt18() {
  set_has_rt18();
  if (rt18_ == &::google::protobuf::internal::kEmptyString) {
    rt18_ = new ::std::string;
  }
  return rt18_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt18() {
  clear_has_rt18();
  if (rt18_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt18_;
    rt18_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT19 = 20;
inline bool INF_QueryPosition_Req::has_rt19() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void INF_QueryPosition_Req::set_has_rt19() {
  _has_bits_[0] |= 0x00080000u;
}
inline void INF_QueryPosition_Req::clear_has_rt19() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void INF_QueryPosition_Req::clear_rt19() {
  if (rt19_ != &::google::protobuf::internal::kEmptyString) {
    rt19_->clear();
  }
  clear_has_rt19();
}
inline const ::std::string& INF_QueryPosition_Req::rt19() const {
  return *rt19_;
}
inline void INF_QueryPosition_Req::set_rt19(const ::std::string& value) {
  set_has_rt19();
  if (rt19_ == &::google::protobuf::internal::kEmptyString) {
    rt19_ = new ::std::string;
  }
  rt19_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt19(const char* value) {
  set_has_rt19();
  if (rt19_ == &::google::protobuf::internal::kEmptyString) {
    rt19_ = new ::std::string;
  }
  rt19_->assign(value);
}
inline void INF_QueryPosition_Req::set_rt19(const char* value, size_t size) {
  set_has_rt19();
  if (rt19_ == &::google::protobuf::internal::kEmptyString) {
    rt19_ = new ::std::string;
  }
  rt19_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Req::mutable_rt19() {
  set_has_rt19();
  if (rt19_ == &::google::protobuf::internal::kEmptyString) {
    rt19_ = new ::std::string;
  }
  return rt19_;
}
inline ::std::string* INF_QueryPosition_Req::release_rt19() {
  clear_has_rt19();
  if (rt19_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt19_;
    rt19_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryETFbaseInfo_Req

// optional string RT0 = 1;
inline bool INF_QueryETFbaseInfo_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryETFbaseInfo_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryETFbaseInfo_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryETFbaseInfo_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_QueryETFbaseInfo_Req::rt0() const {
  return *rt0_;
}
inline void INF_QueryETFbaseInfo_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_QueryETFbaseInfo_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_QueryETFbaseInfo_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryETFbaseInfo_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryETFbaseInfo_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryETFbaseInfo_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_QueryETFbaseInfo_Req::localhost() const {
  return *localhost_;
}
inline void INF_QueryETFbaseInfo_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_QueryETFbaseInfo_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_QueryETFbaseInfo_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryETFbaseInfo_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryETFbaseInfo_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryETFbaseInfo_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_QueryETFbaseInfo_Req::reqid() const {
  return *reqid_;
}
inline void INF_QueryETFbaseInfo_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_QueryETFbaseInfo_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_QueryETFbaseInfo_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryETFbaseInfo_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryETFbaseInfo_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryETFbaseInfo_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_QueryETFbaseInfo_Req::funcid() const {
  return *funcid_;
}
inline void INF_QueryETFbaseInfo_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_QueryETFbaseInfo_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_QueryETFbaseInfo_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryETFbaseInfo_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryETFbaseInfo_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryETFbaseInfo_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_QueryETFbaseInfo_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_QueryETFbaseInfo_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_QueryETFbaseInfo_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MarketID = 6;
inline bool INF_QueryETFbaseInfo_Req::has_marketid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryETFbaseInfo_Req::set_has_marketid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryETFbaseInfo_Req::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryETFbaseInfo_Req::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_QueryETFbaseInfo_Req::marketid() const {
  return *marketid_;
}
inline void INF_QueryETFbaseInfo_Req::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Req::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_QueryETFbaseInfo_Req::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_QueryETFbaseInfo_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryETFbaseInfo_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryETFbaseInfo_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryETFbaseInfo_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_QueryETFbaseInfo_Req::rt6() const {
  return *rt6_;
}
inline void INF_QueryETFbaseInfo_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_QueryETFbaseInfo_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_QueryETFbaseInfo_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryETFbaseInfo_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryETFbaseInfo_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryETFbaseInfo_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_QueryETFbaseInfo_Req::customid() const {
  return *customid_;
}
inline void INF_QueryETFbaseInfo_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_QueryETFbaseInfo_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 9;
inline bool INF_QueryETFbaseInfo_Req::has_securitycode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryETFbaseInfo_Req::set_has_securitycode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryETFbaseInfo_Req::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryETFbaseInfo_Req::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_QueryETFbaseInfo_Req::securitycode() const {
  return *securitycode_;
}
inline void INF_QueryETFbaseInfo_Req::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Req::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_QueryETFbaseInfo_Req::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 10;
inline bool INF_QueryETFbaseInfo_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryETFbaseInfo_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryETFbaseInfo_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryETFbaseInfo_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryETFbaseInfo_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryETFbaseInfo_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryETFbaseInfo_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryETFbaseInfo_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryETFlistInfo_Req

// optional string RT0 = 1;
inline bool INF_QueryETFlistInfo_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryETFlistInfo_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::rt0() const {
  return *rt0_;
}
inline void INF_QueryETFlistInfo_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_QueryETFlistInfo_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryETFlistInfo_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::localhost() const {
  return *localhost_;
}
inline void INF_QueryETFlistInfo_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_QueryETFlistInfo_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryETFlistInfo_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::reqid() const {
  return *reqid_;
}
inline void INF_QueryETFlistInfo_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_QueryETFlistInfo_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryETFlistInfo_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::funcid() const {
  return *funcid_;
}
inline void INF_QueryETFlistInfo_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_QueryETFlistInfo_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryETFlistInfo_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_QueryETFlistInfo_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MarketID = 6;
inline bool INF_QueryETFlistInfo_Req::has_marketid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_marketid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryETFlistInfo_Req::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::marketid() const {
  return *marketid_;
}
inline void INF_QueryETFlistInfo_Req::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_QueryETFlistInfo_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryETFlistInfo_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::rt6() const {
  return *rt6_;
}
inline void INF_QueryETFlistInfo_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_QueryETFlistInfo_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryETFlistInfo_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::customid() const {
  return *customid_;
}
inline void INF_QueryETFlistInfo_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 9;
inline bool INF_QueryETFlistInfo_Req::has_securitycode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_securitycode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryETFlistInfo_Req::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::securitycode() const {
  return *securitycode_;
}
inline void INF_QueryETFlistInfo_Req::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SortType = 10;
inline bool INF_QueryETFlistInfo_Req::has_sorttype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_sorttype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_sorttype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryETFlistInfo_Req::clear_sorttype() {
  if (sorttype_ != &::google::protobuf::internal::kEmptyString) {
    sorttype_->clear();
  }
  clear_has_sorttype();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::sorttype() const {
  return *sorttype_;
}
inline void INF_QueryETFlistInfo_Req::set_sorttype(const ::std::string& value) {
  set_has_sorttype();
  if (sorttype_ == &::google::protobuf::internal::kEmptyString) {
    sorttype_ = new ::std::string;
  }
  sorttype_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_sorttype(const char* value) {
  set_has_sorttype();
  if (sorttype_ == &::google::protobuf::internal::kEmptyString) {
    sorttype_ = new ::std::string;
  }
  sorttype_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_sorttype(const char* value, size_t size) {
  set_has_sorttype();
  if (sorttype_ == &::google::protobuf::internal::kEmptyString) {
    sorttype_ = new ::std::string;
  }
  sorttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_sorttype() {
  set_has_sorttype();
  if (sorttype_ == &::google::protobuf::internal::kEmptyString) {
    sorttype_ = new ::std::string;
  }
  return sorttype_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_sorttype() {
  clear_has_sorttype();
  if (sorttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sorttype_;
    sorttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 11;
inline bool INF_QueryETFlistInfo_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryETFlistInfo_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryETFlistInfo_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryETFlistInfo_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryETFlistInfo_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryETFlistInfo_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryETFlistInfo_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryETFlistInfo_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryETFdynamicInfo_Req

// optional string RT0 = 1;
inline bool INF_QueryETFdynamicInfo_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::rt0() const {
  return *rt0_;
}
inline void INF_QueryETFdynamicInfo_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_QueryETFdynamicInfo_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::localhost() const {
  return *localhost_;
}
inline void INF_QueryETFdynamicInfo_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_QueryETFdynamicInfo_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::reqid() const {
  return *reqid_;
}
inline void INF_QueryETFdynamicInfo_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_QueryETFdynamicInfo_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::funcid() const {
  return *funcid_;
}
inline void INF_QueryETFdynamicInfo_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_QueryETFdynamicInfo_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_QueryETFdynamicInfo_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MarketID = 6;
inline bool INF_QueryETFdynamicInfo_Req::has_marketid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_marketid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::marketid() const {
  return *marketid_;
}
inline void INF_QueryETFdynamicInfo_Req::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_QueryETFdynamicInfo_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::rt6() const {
  return *rt6_;
}
inline void INF_QueryETFdynamicInfo_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_QueryETFdynamicInfo_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::customid() const {
  return *customid_;
}
inline void INF_QueryETFdynamicInfo_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustBatchNO = 9;
inline bool INF_QueryETFdynamicInfo_Req::has_entrustbatchno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_entrustbatchno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_entrustbatchno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_entrustbatchno() {
  if (entrustbatchno_ != &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_->clear();
  }
  clear_has_entrustbatchno();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::entrustbatchno() const {
  return *entrustbatchno_;
}
inline void INF_QueryETFdynamicInfo_Req::set_entrustbatchno(const ::std::string& value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_entrustbatchno(const char* value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_entrustbatchno(const char* value, size_t size) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_entrustbatchno() {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  return entrustbatchno_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_entrustbatchno() {
  clear_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustbatchno_;
    entrustbatchno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 10;
inline bool INF_QueryETFdynamicInfo_Req::has_securitycode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_securitycode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::securitycode() const {
  return *securitycode_;
}
inline void INF_QueryETFdynamicInfo_Req::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFminPurRedemUint = 11;
inline bool INF_QueryETFdynamicInfo_Req::has_etfminpurredemuint() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_etfminpurredemuint() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_etfminpurredemuint() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_etfminpurredemuint() {
  if (etfminpurredemuint_ != &::google::protobuf::internal::kEmptyString) {
    etfminpurredemuint_->clear();
  }
  clear_has_etfminpurredemuint();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::etfminpurredemuint() const {
  return *etfminpurredemuint_;
}
inline void INF_QueryETFdynamicInfo_Req::set_etfminpurredemuint(const ::std::string& value) {
  set_has_etfminpurredemuint();
  if (etfminpurredemuint_ == &::google::protobuf::internal::kEmptyString) {
    etfminpurredemuint_ = new ::std::string;
  }
  etfminpurredemuint_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_etfminpurredemuint(const char* value) {
  set_has_etfminpurredemuint();
  if (etfminpurredemuint_ == &::google::protobuf::internal::kEmptyString) {
    etfminpurredemuint_ = new ::std::string;
  }
  etfminpurredemuint_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_etfminpurredemuint(const char* value, size_t size) {
  set_has_etfminpurredemuint();
  if (etfminpurredemuint_ == &::google::protobuf::internal::kEmptyString) {
    etfminpurredemuint_ = new ::std::string;
  }
  etfminpurredemuint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_etfminpurredemuint() {
  set_has_etfminpurredemuint();
  if (etfminpurredemuint_ == &::google::protobuf::internal::kEmptyString) {
    etfminpurredemuint_ = new ::std::string;
  }
  return etfminpurredemuint_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_etfminpurredemuint() {
  clear_has_etfminpurredemuint();
  if (etfminpurredemuint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfminpurredemuint_;
    etfminpurredemuint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 12;
inline bool INF_QueryETFdynamicInfo_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryETFdynamicInfo_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryETFdynamicInfo_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryETFdynamicInfo_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryFundCondition_Req

// optional string RT0 = 1;
inline bool INF_QueryFundCondition_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryFundCondition_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryFundCondition_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryFundCondition_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_QueryFundCondition_Req::rt0() const {
  return *rt0_;
}
inline void INF_QueryFundCondition_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_QueryFundCondition_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_QueryFundCondition_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryFundCondition_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryFundCondition_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryFundCondition_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_QueryFundCondition_Req::localhost() const {
  return *localhost_;
}
inline void INF_QueryFundCondition_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_QueryFundCondition_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_QueryFundCondition_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryFundCondition_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryFundCondition_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryFundCondition_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_QueryFundCondition_Req::reqid() const {
  return *reqid_;
}
inline void INF_QueryFundCondition_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_QueryFundCondition_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_QueryFundCondition_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryFundCondition_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryFundCondition_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryFundCondition_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_QueryFundCondition_Req::funcid() const {
  return *funcid_;
}
inline void INF_QueryFundCondition_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_QueryFundCondition_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_QueryFundCondition_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryFundCondition_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryFundCondition_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryFundCondition_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_QueryFundCondition_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_QueryFundCondition_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_QueryFundCondition_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MoneyType = 6;
inline bool INF_QueryFundCondition_Req::has_moneytype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryFundCondition_Req::set_has_moneytype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryFundCondition_Req::clear_has_moneytype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryFundCondition_Req::clear_moneytype() {
  if (moneytype_ != &::google::protobuf::internal::kEmptyString) {
    moneytype_->clear();
  }
  clear_has_moneytype();
}
inline const ::std::string& INF_QueryFundCondition_Req::moneytype() const {
  return *moneytype_;
}
inline void INF_QueryFundCondition_Req::set_moneytype(const ::std::string& value) {
  set_has_moneytype();
  if (moneytype_ == &::google::protobuf::internal::kEmptyString) {
    moneytype_ = new ::std::string;
  }
  moneytype_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_moneytype(const char* value) {
  set_has_moneytype();
  if (moneytype_ == &::google::protobuf::internal::kEmptyString) {
    moneytype_ = new ::std::string;
  }
  moneytype_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_moneytype(const char* value, size_t size) {
  set_has_moneytype();
  if (moneytype_ == &::google::protobuf::internal::kEmptyString) {
    moneytype_ = new ::std::string;
  }
  moneytype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Req::mutable_moneytype() {
  set_has_moneytype();
  if (moneytype_ == &::google::protobuf::internal::kEmptyString) {
    moneytype_ = new ::std::string;
  }
  return moneytype_;
}
inline ::std::string* INF_QueryFundCondition_Req::release_moneytype() {
  clear_has_moneytype();
  if (moneytype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moneytype_;
    moneytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_QueryFundCondition_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryFundCondition_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryFundCondition_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryFundCondition_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_QueryFundCondition_Req::rt6() const {
  return *rt6_;
}
inline void INF_QueryFundCondition_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_QueryFundCondition_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_QueryFundCondition_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryFundCondition_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryFundCondition_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryFundCondition_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_QueryFundCondition_Req::customid() const {
  return *customid_;
}
inline void INF_QueryFundCondition_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_QueryFundCondition_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 9;
inline bool INF_QueryFundCondition_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryFundCondition_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryFundCondition_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryFundCondition_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryFundCondition_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryFundCondition_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryFundCondition_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PropertyDebt = 10;
inline bool INF_QueryFundCondition_Req::has_propertydebt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryFundCondition_Req::set_has_propertydebt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryFundCondition_Req::clear_has_propertydebt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryFundCondition_Req::clear_propertydebt() {
  if (propertydebt_ != &::google::protobuf::internal::kEmptyString) {
    propertydebt_->clear();
  }
  clear_has_propertydebt();
}
inline const ::std::string& INF_QueryFundCondition_Req::propertydebt() const {
  return *propertydebt_;
}
inline void INF_QueryFundCondition_Req::set_propertydebt(const ::std::string& value) {
  set_has_propertydebt();
  if (propertydebt_ == &::google::protobuf::internal::kEmptyString) {
    propertydebt_ = new ::std::string;
  }
  propertydebt_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_propertydebt(const char* value) {
  set_has_propertydebt();
  if (propertydebt_ == &::google::protobuf::internal::kEmptyString) {
    propertydebt_ = new ::std::string;
  }
  propertydebt_->assign(value);
}
inline void INF_QueryFundCondition_Req::set_propertydebt(const char* value, size_t size) {
  set_has_propertydebt();
  if (propertydebt_ == &::google::protobuf::internal::kEmptyString) {
    propertydebt_ = new ::std::string;
  }
  propertydebt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Req::mutable_propertydebt() {
  set_has_propertydebt();
  if (propertydebt_ == &::google::protobuf::internal::kEmptyString) {
    propertydebt_ = new ::std::string;
  }
  return propertydebt_;
}
inline ::std::string* INF_QueryFundCondition_Req::release_propertydebt() {
  clear_has_propertydebt();
  if (propertydebt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = propertydebt_;
    propertydebt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_ETFPurRedem_Req

// optional string RT0 = 1;
inline bool INF_ETFPurRedem_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_ETFPurRedem_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_ETFPurRedem_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_ETFPurRedem_Req::rt0() const {
  return *rt0_;
}
inline void INF_ETFPurRedem_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_ETFPurRedem_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_ETFPurRedem_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_ETFPurRedem_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_ETFPurRedem_Req::localhost() const {
  return *localhost_;
}
inline void INF_ETFPurRedem_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_ETFPurRedem_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_ETFPurRedem_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_ETFPurRedem_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_ETFPurRedem_Req::reqid() const {
  return *reqid_;
}
inline void INF_ETFPurRedem_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_ETFPurRedem_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_ETFPurRedem_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_ETFPurRedem_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_ETFPurRedem_Req::funcid() const {
  return *funcid_;
}
inline void INF_ETFPurRedem_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_ETFPurRedem_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_ETFPurRedem_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_ETFPurRedem_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_ETFPurRedem_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_ETFPurRedem_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MoneyID = 6;
inline bool INF_ETFPurRedem_Req::has_moneyid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_moneyid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_ETFPurRedem_Req::clear_has_moneyid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_ETFPurRedem_Req::clear_moneyid() {
  if (moneyid_ != &::google::protobuf::internal::kEmptyString) {
    moneyid_->clear();
  }
  clear_has_moneyid();
}
inline const ::std::string& INF_ETFPurRedem_Req::moneyid() const {
  return *moneyid_;
}
inline void INF_ETFPurRedem_Req::set_moneyid(const ::std::string& value) {
  set_has_moneyid();
  if (moneyid_ == &::google::protobuf::internal::kEmptyString) {
    moneyid_ = new ::std::string;
  }
  moneyid_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_moneyid(const char* value) {
  set_has_moneyid();
  if (moneyid_ == &::google::protobuf::internal::kEmptyString) {
    moneyid_ = new ::std::string;
  }
  moneyid_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_moneyid(const char* value, size_t size) {
  set_has_moneyid();
  if (moneyid_ == &::google::protobuf::internal::kEmptyString) {
    moneyid_ = new ::std::string;
  }
  moneyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_moneyid() {
  set_has_moneyid();
  if (moneyid_ == &::google::protobuf::internal::kEmptyString) {
    moneyid_ = new ::std::string;
  }
  return moneyid_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_moneyid() {
  clear_has_moneyid();
  if (moneyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moneyid_;
    moneyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_ETFPurRedem_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_ETFPurRedem_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_ETFPurRedem_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_ETFPurRedem_Req::rt6() const {
  return *rt6_;
}
inline void INF_ETFPurRedem_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_ETFPurRedem_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_ETFPurRedem_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_ETFPurRedem_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_ETFPurRedem_Req::customid() const {
  return *customid_;
}
inline void INF_ETFPurRedem_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustBatchNO = 9;
inline bool INF_ETFPurRedem_Req::has_entrustbatchno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_entrustbatchno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_ETFPurRedem_Req::clear_has_entrustbatchno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_ETFPurRedem_Req::clear_entrustbatchno() {
  if (entrustbatchno_ != &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_->clear();
  }
  clear_has_entrustbatchno();
}
inline const ::std::string& INF_ETFPurRedem_Req::entrustbatchno() const {
  return *entrustbatchno_;
}
inline void INF_ETFPurRedem_Req::set_entrustbatchno(const ::std::string& value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_entrustbatchno(const char* value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_entrustbatchno(const char* value, size_t size) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_entrustbatchno() {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  return entrustbatchno_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_entrustbatchno() {
  clear_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustbatchno_;
    entrustbatchno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OperateFunc = 10;
inline bool INF_ETFPurRedem_Req::has_operatefunc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_operatefunc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_ETFPurRedem_Req::clear_has_operatefunc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_ETFPurRedem_Req::clear_operatefunc() {
  if (operatefunc_ != &::google::protobuf::internal::kEmptyString) {
    operatefunc_->clear();
  }
  clear_has_operatefunc();
}
inline const ::std::string& INF_ETFPurRedem_Req::operatefunc() const {
  return *operatefunc_;
}
inline void INF_ETFPurRedem_Req::set_operatefunc(const ::std::string& value) {
  set_has_operatefunc();
  if (operatefunc_ == &::google::protobuf::internal::kEmptyString) {
    operatefunc_ = new ::std::string;
  }
  operatefunc_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_operatefunc(const char* value) {
  set_has_operatefunc();
  if (operatefunc_ == &::google::protobuf::internal::kEmptyString) {
    operatefunc_ = new ::std::string;
  }
  operatefunc_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_operatefunc(const char* value, size_t size) {
  set_has_operatefunc();
  if (operatefunc_ == &::google::protobuf::internal::kEmptyString) {
    operatefunc_ = new ::std::string;
  }
  operatefunc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_operatefunc() {
  set_has_operatefunc();
  if (operatefunc_ == &::google::protobuf::internal::kEmptyString) {
    operatefunc_ = new ::std::string;
  }
  return operatefunc_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_operatefunc() {
  clear_has_operatefunc();
  if (operatefunc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operatefunc_;
    operatefunc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 11;
inline bool INF_ETFPurRedem_Req::has_securitycode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_securitycode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_ETFPurRedem_Req::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_ETFPurRedem_Req::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_ETFPurRedem_Req::securitycode() const {
  return *securitycode_;
}
inline void INF_ETFPurRedem_Req::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustNum = 12;
inline bool INF_ETFPurRedem_Req::has_entrustnum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_entrustnum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_ETFPurRedem_Req::clear_has_entrustnum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_ETFPurRedem_Req::clear_entrustnum() {
  if (entrustnum_ != &::google::protobuf::internal::kEmptyString) {
    entrustnum_->clear();
  }
  clear_has_entrustnum();
}
inline const ::std::string& INF_ETFPurRedem_Req::entrustnum() const {
  return *entrustnum_;
}
inline void INF_ETFPurRedem_Req::set_entrustnum(const ::std::string& value) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_entrustnum(const char* value) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_entrustnum(const char* value, size_t size) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_entrustnum() {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  return entrustnum_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_entrustnum() {
  clear_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustnum_;
    entrustnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 13;
inline bool INF_ETFPurRedem_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_ETFPurRedem_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_ETFPurRedem_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_ETFPurRedem_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_ETFPurRedem_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_ETFPurRedem_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_ETFPurRedem_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_ETFPurRedem_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryBatchEntrust_Req

// optional string RT0 = 1;
inline bool INF_QueryBatchEntrust_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryBatchEntrust_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::rt0() const {
  return *rt0_;
}
inline void INF_QueryBatchEntrust_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_QueryBatchEntrust_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryBatchEntrust_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::localhost() const {
  return *localhost_;
}
inline void INF_QueryBatchEntrust_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_QueryBatchEntrust_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryBatchEntrust_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::reqid() const {
  return *reqid_;
}
inline void INF_QueryBatchEntrust_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_QueryBatchEntrust_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryBatchEntrust_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::funcid() const {
  return *funcid_;
}
inline void INF_QueryBatchEntrust_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_QueryBatchEntrust_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryBatchEntrust_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_QueryBatchEntrust_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT5 = 6;
inline bool INF_QueryBatchEntrust_Req::has_rt5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_rt5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_rt5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryBatchEntrust_Req::clear_rt5() {
  if (rt5_ != &::google::protobuf::internal::kEmptyString) {
    rt5_->clear();
  }
  clear_has_rt5();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::rt5() const {
  return *rt5_;
}
inline void INF_QueryBatchEntrust_Req::set_rt5(const ::std::string& value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt5(const char* value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt5(const char* value, size_t size) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_rt5() {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  return rt5_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_rt5() {
  clear_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt5_;
    rt5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_QueryBatchEntrust_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryBatchEntrust_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::rt6() const {
  return *rt6_;
}
inline void INF_QueryBatchEntrust_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_QueryBatchEntrust_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryBatchEntrust_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::customid() const {
  return *customid_;
}
inline void INF_QueryBatchEntrust_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT8 = 9;
inline bool INF_QueryBatchEntrust_Req::has_rt8() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_rt8() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_rt8() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryBatchEntrust_Req::clear_rt8() {
  if (rt8_ != &::google::protobuf::internal::kEmptyString) {
    rt8_->clear();
  }
  clear_has_rt8();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::rt8() const {
  return *rt8_;
}
inline void INF_QueryBatchEntrust_Req::set_rt8(const ::std::string& value) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt8(const char* value) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt8(const char* value, size_t size) {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  rt8_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_rt8() {
  set_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    rt8_ = new ::std::string;
  }
  return rt8_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_rt8() {
  clear_has_rt8();
  if (rt8_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt8_;
    rt8_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT9 = 10;
inline bool INF_QueryBatchEntrust_Req::has_rt9() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_rt9() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_rt9() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryBatchEntrust_Req::clear_rt9() {
  if (rt9_ != &::google::protobuf::internal::kEmptyString) {
    rt9_->clear();
  }
  clear_has_rt9();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::rt9() const {
  return *rt9_;
}
inline void INF_QueryBatchEntrust_Req::set_rt9(const ::std::string& value) {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  rt9_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt9(const char* value) {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  rt9_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt9(const char* value, size_t size) {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  rt9_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_rt9() {
  set_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    rt9_ = new ::std::string;
  }
  return rt9_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_rt9() {
  clear_has_rt9();
  if (rt9_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt9_;
    rt9_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustBatchNO = 11;
inline bool INF_QueryBatchEntrust_Req::has_entrustbatchno() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_entrustbatchno() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_entrustbatchno() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryBatchEntrust_Req::clear_entrustbatchno() {
  if (entrustbatchno_ != &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_->clear();
  }
  clear_has_entrustbatchno();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::entrustbatchno() const {
  return *entrustbatchno_;
}
inline void INF_QueryBatchEntrust_Req::set_entrustbatchno(const ::std::string& value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_entrustbatchno(const char* value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_entrustbatchno(const char* value, size_t size) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_entrustbatchno() {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  return entrustbatchno_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_entrustbatchno() {
  clear_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustbatchno_;
    entrustbatchno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT11 = 12;
inline bool INF_QueryBatchEntrust_Req::has_rt11() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_rt11() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_rt11() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryBatchEntrust_Req::clear_rt11() {
  if (rt11_ != &::google::protobuf::internal::kEmptyString) {
    rt11_->clear();
  }
  clear_has_rt11();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::rt11() const {
  return *rt11_;
}
inline void INF_QueryBatchEntrust_Req::set_rt11(const ::std::string& value) {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  rt11_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt11(const char* value) {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  rt11_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt11(const char* value, size_t size) {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  rt11_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_rt11() {
  set_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    rt11_ = new ::std::string;
  }
  return rt11_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_rt11() {
  clear_has_rt11();
  if (rt11_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt11_;
    rt11_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CombineMode = 13;
inline bool INF_QueryBatchEntrust_Req::has_combinemode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_combinemode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_combinemode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_QueryBatchEntrust_Req::clear_combinemode() {
  if (combinemode_ != &::google::protobuf::internal::kEmptyString) {
    combinemode_->clear();
  }
  clear_has_combinemode();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::combinemode() const {
  return *combinemode_;
}
inline void INF_QueryBatchEntrust_Req::set_combinemode(const ::std::string& value) {
  set_has_combinemode();
  if (combinemode_ == &::google::protobuf::internal::kEmptyString) {
    combinemode_ = new ::std::string;
  }
  combinemode_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_combinemode(const char* value) {
  set_has_combinemode();
  if (combinemode_ == &::google::protobuf::internal::kEmptyString) {
    combinemode_ = new ::std::string;
  }
  combinemode_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_combinemode(const char* value, size_t size) {
  set_has_combinemode();
  if (combinemode_ == &::google::protobuf::internal::kEmptyString) {
    combinemode_ = new ::std::string;
  }
  combinemode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_combinemode() {
  set_has_combinemode();
  if (combinemode_ == &::google::protobuf::internal::kEmptyString) {
    combinemode_ = new ::std::string;
  }
  return combinemode_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_combinemode() {
  clear_has_combinemode();
  if (combinemode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = combinemode_;
    combinemode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string QueryDir = 14;
inline bool INF_QueryBatchEntrust_Req::has_querydir() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_querydir() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_querydir() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_QueryBatchEntrust_Req::clear_querydir() {
  if (querydir_ != &::google::protobuf::internal::kEmptyString) {
    querydir_->clear();
  }
  clear_has_querydir();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::querydir() const {
  return *querydir_;
}
inline void INF_QueryBatchEntrust_Req::set_querydir(const ::std::string& value) {
  set_has_querydir();
  if (querydir_ == &::google::protobuf::internal::kEmptyString) {
    querydir_ = new ::std::string;
  }
  querydir_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_querydir(const char* value) {
  set_has_querydir();
  if (querydir_ == &::google::protobuf::internal::kEmptyString) {
    querydir_ = new ::std::string;
  }
  querydir_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_querydir(const char* value, size_t size) {
  set_has_querydir();
  if (querydir_ == &::google::protobuf::internal::kEmptyString) {
    querydir_ = new ::std::string;
  }
  querydir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_querydir() {
  set_has_querydir();
  if (querydir_ == &::google::protobuf::internal::kEmptyString) {
    querydir_ = new ::std::string;
  }
  return querydir_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_querydir() {
  clear_has_querydir();
  if (querydir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = querydir_;
    querydir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT14 = 15;
inline bool INF_QueryBatchEntrust_Req::has_rt14() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_rt14() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_rt14() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_QueryBatchEntrust_Req::clear_rt14() {
  if (rt14_ != &::google::protobuf::internal::kEmptyString) {
    rt14_->clear();
  }
  clear_has_rt14();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::rt14() const {
  return *rt14_;
}
inline void INF_QueryBatchEntrust_Req::set_rt14(const ::std::string& value) {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  rt14_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt14(const char* value) {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  rt14_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt14(const char* value, size_t size) {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  rt14_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_rt14() {
  set_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    rt14_ = new ::std::string;
  }
  return rt14_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_rt14() {
  clear_has_rt14();
  if (rt14_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt14_;
    rt14_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT15 = 16;
inline bool INF_QueryBatchEntrust_Req::has_rt15() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_rt15() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_rt15() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_QueryBatchEntrust_Req::clear_rt15() {
  if (rt15_ != &::google::protobuf::internal::kEmptyString) {
    rt15_->clear();
  }
  clear_has_rt15();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::rt15() const {
  return *rt15_;
}
inline void INF_QueryBatchEntrust_Req::set_rt15(const ::std::string& value) {
  set_has_rt15();
  if (rt15_ == &::google::protobuf::internal::kEmptyString) {
    rt15_ = new ::std::string;
  }
  rt15_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt15(const char* value) {
  set_has_rt15();
  if (rt15_ == &::google::protobuf::internal::kEmptyString) {
    rt15_ = new ::std::string;
  }
  rt15_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_rt15(const char* value, size_t size) {
  set_has_rt15();
  if (rt15_ == &::google::protobuf::internal::kEmptyString) {
    rt15_ = new ::std::string;
  }
  rt15_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_rt15() {
  set_has_rt15();
  if (rt15_ == &::google::protobuf::internal::kEmptyString) {
    rt15_ = new ::std::string;
  }
  return rt15_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_rt15() {
  clear_has_rt15();
  if (rt15_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt15_;
    rt15_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 17;
inline bool INF_QueryBatchEntrust_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void INF_QueryBatchEntrust_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void INF_QueryBatchEntrust_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void INF_QueryBatchEntrust_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryBatchEntrust_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryBatchEntrust_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryBatchEntrust_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryBatchEntrust_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_BatchEntrust_Req

// optional string RT0 = 1;
inline bool INF_BatchEntrust_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_BatchEntrust_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_BatchEntrust_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_BatchEntrust_Req::rt0() const {
  return *rt0_;
}
inline void INF_BatchEntrust_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_BatchEntrust_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_BatchEntrust_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_BatchEntrust_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_BatchEntrust_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_BatchEntrust_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_BatchEntrust_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_BatchEntrust_Req::localhost() const {
  return *localhost_;
}
inline void INF_BatchEntrust_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_BatchEntrust_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_BatchEntrust_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_BatchEntrust_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_BatchEntrust_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_BatchEntrust_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_BatchEntrust_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_BatchEntrust_Req::reqid() const {
  return *reqid_;
}
inline void INF_BatchEntrust_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_BatchEntrust_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_BatchEntrust_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_BatchEntrust_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_BatchEntrust_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_BatchEntrust_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_BatchEntrust_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_BatchEntrust_Req::funcid() const {
  return *funcid_;
}
inline void INF_BatchEntrust_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_BatchEntrust_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_BatchEntrust_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_BatchEntrust_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_BatchEntrust_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_BatchEntrust_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_BatchEntrust_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_BatchEntrust_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_BatchEntrust_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_BatchEntrust_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_BatchEntrust_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_BatchEntrust_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT5 = 6;
inline bool INF_BatchEntrust_Req::has_rt5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_rt5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_BatchEntrust_Req::clear_has_rt5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_BatchEntrust_Req::clear_rt5() {
  if (rt5_ != &::google::protobuf::internal::kEmptyString) {
    rt5_->clear();
  }
  clear_has_rt5();
}
inline const ::std::string& INF_BatchEntrust_Req::rt5() const {
  return *rt5_;
}
inline void INF_BatchEntrust_Req::set_rt5(const ::std::string& value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_BatchEntrust_Req::set_rt5(const char* value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_BatchEntrust_Req::set_rt5(const char* value, size_t size) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_rt5() {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  return rt5_;
}
inline ::std::string* INF_BatchEntrust_Req::release_rt5() {
  clear_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt5_;
    rt5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_BatchEntrust_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_BatchEntrust_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_BatchEntrust_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_BatchEntrust_Req::rt6() const {
  return *rt6_;
}
inline void INF_BatchEntrust_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_BatchEntrust_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_BatchEntrust_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_BatchEntrust_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_BatchEntrust_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_BatchEntrust_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_BatchEntrust_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_BatchEntrust_Req::customid() const {
  return *customid_;
}
inline void INF_BatchEntrust_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_BatchEntrust_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_BatchEntrust_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_BatchEntrust_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFserialNO = 9;
inline bool INF_BatchEntrust_Req::has_etfserialno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_etfserialno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_BatchEntrust_Req::clear_has_etfserialno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_BatchEntrust_Req::clear_etfserialno() {
  if (etfserialno_ != &::google::protobuf::internal::kEmptyString) {
    etfserialno_->clear();
  }
  clear_has_etfserialno();
}
inline const ::std::string& INF_BatchEntrust_Req::etfserialno() const {
  return *etfserialno_;
}
inline void INF_BatchEntrust_Req::set_etfserialno(const ::std::string& value) {
  set_has_etfserialno();
  if (etfserialno_ == &::google::protobuf::internal::kEmptyString) {
    etfserialno_ = new ::std::string;
  }
  etfserialno_->assign(value);
}
inline void INF_BatchEntrust_Req::set_etfserialno(const char* value) {
  set_has_etfserialno();
  if (etfserialno_ == &::google::protobuf::internal::kEmptyString) {
    etfserialno_ = new ::std::string;
  }
  etfserialno_->assign(value);
}
inline void INF_BatchEntrust_Req::set_etfserialno(const char* value, size_t size) {
  set_has_etfserialno();
  if (etfserialno_ == &::google::protobuf::internal::kEmptyString) {
    etfserialno_ = new ::std::string;
  }
  etfserialno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_etfserialno() {
  set_has_etfserialno();
  if (etfserialno_ == &::google::protobuf::internal::kEmptyString) {
    etfserialno_ = new ::std::string;
  }
  return etfserialno_;
}
inline ::std::string* INF_BatchEntrust_Req::release_etfserialno() {
  clear_has_etfserialno();
  if (etfserialno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfserialno_;
    etfserialno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ControlArg = 10;
inline bool INF_BatchEntrust_Req::has_controlarg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_controlarg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_BatchEntrust_Req::clear_has_controlarg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_BatchEntrust_Req::clear_controlarg() {
  if (controlarg_ != &::google::protobuf::internal::kEmptyString) {
    controlarg_->clear();
  }
  clear_has_controlarg();
}
inline const ::std::string& INF_BatchEntrust_Req::controlarg() const {
  return *controlarg_;
}
inline void INF_BatchEntrust_Req::set_controlarg(const ::std::string& value) {
  set_has_controlarg();
  if (controlarg_ == &::google::protobuf::internal::kEmptyString) {
    controlarg_ = new ::std::string;
  }
  controlarg_->assign(value);
}
inline void INF_BatchEntrust_Req::set_controlarg(const char* value) {
  set_has_controlarg();
  if (controlarg_ == &::google::protobuf::internal::kEmptyString) {
    controlarg_ = new ::std::string;
  }
  controlarg_->assign(value);
}
inline void INF_BatchEntrust_Req::set_controlarg(const char* value, size_t size) {
  set_has_controlarg();
  if (controlarg_ == &::google::protobuf::internal::kEmptyString) {
    controlarg_ = new ::std::string;
  }
  controlarg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_controlarg() {
  set_has_controlarg();
  if (controlarg_ == &::google::protobuf::internal::kEmptyString) {
    controlarg_ = new ::std::string;
  }
  return controlarg_;
}
inline ::std::string* INF_BatchEntrust_Req::release_controlarg() {
  clear_has_controlarg();
  if (controlarg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = controlarg_;
    controlarg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 11;
inline bool INF_BatchEntrust_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_BatchEntrust_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_BatchEntrust_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_BatchEntrust_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_BatchEntrust_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_BatchEntrust_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_BatchEntrust_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_BatchEntrust_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustBatchNO = 12;
inline bool INF_BatchEntrust_Req::has_entrustbatchno() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_entrustbatchno() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_BatchEntrust_Req::clear_has_entrustbatchno() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_BatchEntrust_Req::clear_entrustbatchno() {
  if (entrustbatchno_ != &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_->clear();
  }
  clear_has_entrustbatchno();
}
inline const ::std::string& INF_BatchEntrust_Req::entrustbatchno() const {
  return *entrustbatchno_;
}
inline void INF_BatchEntrust_Req::set_entrustbatchno(const ::std::string& value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_BatchEntrust_Req::set_entrustbatchno(const char* value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_BatchEntrust_Req::set_entrustbatchno(const char* value, size_t size) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_entrustbatchno() {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  return entrustbatchno_;
}
inline ::std::string* INF_BatchEntrust_Req::release_entrustbatchno() {
  clear_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustbatchno_;
    entrustbatchno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustHistoryNum = 13;
inline bool INF_BatchEntrust_Req::has_entrusthistorynum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_entrusthistorynum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_BatchEntrust_Req::clear_has_entrusthistorynum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_BatchEntrust_Req::clear_entrusthistorynum() {
  if (entrusthistorynum_ != &::google::protobuf::internal::kEmptyString) {
    entrusthistorynum_->clear();
  }
  clear_has_entrusthistorynum();
}
inline const ::std::string& INF_BatchEntrust_Req::entrusthistorynum() const {
  return *entrusthistorynum_;
}
inline void INF_BatchEntrust_Req::set_entrusthistorynum(const ::std::string& value) {
  set_has_entrusthistorynum();
  if (entrusthistorynum_ == &::google::protobuf::internal::kEmptyString) {
    entrusthistorynum_ = new ::std::string;
  }
  entrusthistorynum_->assign(value);
}
inline void INF_BatchEntrust_Req::set_entrusthistorynum(const char* value) {
  set_has_entrusthistorynum();
  if (entrusthistorynum_ == &::google::protobuf::internal::kEmptyString) {
    entrusthistorynum_ = new ::std::string;
  }
  entrusthistorynum_->assign(value);
}
inline void INF_BatchEntrust_Req::set_entrusthistorynum(const char* value, size_t size) {
  set_has_entrusthistorynum();
  if (entrusthistorynum_ == &::google::protobuf::internal::kEmptyString) {
    entrusthistorynum_ = new ::std::string;
  }
  entrusthistorynum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_entrusthistorynum() {
  set_has_entrusthistorynum();
  if (entrusthistorynum_ == &::google::protobuf::internal::kEmptyString) {
    entrusthistorynum_ = new ::std::string;
  }
  return entrusthistorynum_;
}
inline ::std::string* INF_BatchEntrust_Req::release_entrusthistorynum() {
  clear_has_entrusthistorynum();
  if (entrusthistorynum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusthistorynum_;
    entrusthistorynum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustData = 14;
inline bool INF_BatchEntrust_Req::has_entrustdata() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_BatchEntrust_Req::set_has_entrustdata() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_BatchEntrust_Req::clear_has_entrustdata() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_BatchEntrust_Req::clear_entrustdata() {
  if (entrustdata_ != &::google::protobuf::internal::kEmptyString) {
    entrustdata_->clear();
  }
  clear_has_entrustdata();
}
inline const ::std::string& INF_BatchEntrust_Req::entrustdata() const {
  return *entrustdata_;
}
inline void INF_BatchEntrust_Req::set_entrustdata(const ::std::string& value) {
  set_has_entrustdata();
  if (entrustdata_ == &::google::protobuf::internal::kEmptyString) {
    entrustdata_ = new ::std::string;
  }
  entrustdata_->assign(value);
}
inline void INF_BatchEntrust_Req::set_entrustdata(const char* value) {
  set_has_entrustdata();
  if (entrustdata_ == &::google::protobuf::internal::kEmptyString) {
    entrustdata_ = new ::std::string;
  }
  entrustdata_->assign(value);
}
inline void INF_BatchEntrust_Req::set_entrustdata(const char* value, size_t size) {
  set_has_entrustdata();
  if (entrustdata_ == &::google::protobuf::internal::kEmptyString) {
    entrustdata_ = new ::std::string;
  }
  entrustdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Req::mutable_entrustdata() {
  set_has_entrustdata();
  if (entrustdata_ == &::google::protobuf::internal::kEmptyString) {
    entrustdata_ = new ::std::string;
  }
  return entrustdata_;
}
inline ::std::string* INF_BatchEntrust_Req::release_entrustdata() {
  clear_has_entrustdata();
  if (entrustdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustdata_;
    entrustdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_BatchCancel_Req

// optional string RT0 = 1;
inline bool INF_BatchCancel_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_BatchCancel_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_BatchCancel_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_BatchCancel_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_BatchCancel_Req::rt0() const {
  return *rt0_;
}
inline void INF_BatchCancel_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_BatchCancel_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_BatchCancel_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_BatchCancel_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_BatchCancel_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_BatchCancel_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_BatchCancel_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_BatchCancel_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_BatchCancel_Req::localhost() const {
  return *localhost_;
}
inline void INF_BatchCancel_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_BatchCancel_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_BatchCancel_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_BatchCancel_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_BatchCancel_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_BatchCancel_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_BatchCancel_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_BatchCancel_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_BatchCancel_Req::reqid() const {
  return *reqid_;
}
inline void INF_BatchCancel_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_BatchCancel_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_BatchCancel_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_BatchCancel_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_BatchCancel_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_BatchCancel_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_BatchCancel_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_BatchCancel_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_BatchCancel_Req::funcid() const {
  return *funcid_;
}
inline void INF_BatchCancel_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_BatchCancel_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_BatchCancel_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_BatchCancel_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_BatchCancel_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_BatchCancel_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_BatchCancel_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_BatchCancel_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_BatchCancel_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_BatchCancel_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_BatchCancel_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_BatchCancel_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_BatchCancel_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT5 = 6;
inline bool INF_BatchCancel_Req::has_rt5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_BatchCancel_Req::set_has_rt5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_BatchCancel_Req::clear_has_rt5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_BatchCancel_Req::clear_rt5() {
  if (rt5_ != &::google::protobuf::internal::kEmptyString) {
    rt5_->clear();
  }
  clear_has_rt5();
}
inline const ::std::string& INF_BatchCancel_Req::rt5() const {
  return *rt5_;
}
inline void INF_BatchCancel_Req::set_rt5(const ::std::string& value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_BatchCancel_Req::set_rt5(const char* value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_BatchCancel_Req::set_rt5(const char* value, size_t size) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Req::mutable_rt5() {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  return rt5_;
}
inline ::std::string* INF_BatchCancel_Req::release_rt5() {
  clear_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt5_;
    rt5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_BatchCancel_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_BatchCancel_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_BatchCancel_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_BatchCancel_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_BatchCancel_Req::rt6() const {
  return *rt6_;
}
inline void INF_BatchCancel_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_BatchCancel_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_BatchCancel_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_BatchCancel_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_BatchCancel_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_BatchCancel_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_BatchCancel_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_BatchCancel_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_BatchCancel_Req::customid() const {
  return *customid_;
}
inline void INF_BatchCancel_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_BatchCancel_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_BatchCancel_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_BatchCancel_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustBatchNO = 9;
inline bool INF_BatchCancel_Req::has_entrustbatchno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_BatchCancel_Req::set_has_entrustbatchno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_BatchCancel_Req::clear_has_entrustbatchno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_BatchCancel_Req::clear_entrustbatchno() {
  if (entrustbatchno_ != &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_->clear();
  }
  clear_has_entrustbatchno();
}
inline const ::std::string& INF_BatchCancel_Req::entrustbatchno() const {
  return *entrustbatchno_;
}
inline void INF_BatchCancel_Req::set_entrustbatchno(const ::std::string& value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_BatchCancel_Req::set_entrustbatchno(const char* value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_BatchCancel_Req::set_entrustbatchno(const char* value, size_t size) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Req::mutable_entrustbatchno() {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  return entrustbatchno_;
}
inline ::std::string* INF_BatchCancel_Req::release_entrustbatchno() {
  clear_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustbatchno_;
    entrustbatchno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 10;
inline bool INF_BatchCancel_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_BatchCancel_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_BatchCancel_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_BatchCancel_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_BatchCancel_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_BatchCancel_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_BatchCancel_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_BatchCancel_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_BatchCancel_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryVaildRedemNum_Req

// optional string RT0 = 1;
inline bool INF_QueryVaildRedemNum_Req::has_rt0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_rt0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_rt0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryVaildRedemNum_Req::clear_rt0() {
  if (rt0_ != &::google::protobuf::internal::kEmptyString) {
    rt0_->clear();
  }
  clear_has_rt0();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::rt0() const {
  return *rt0_;
}
inline void INF_QueryVaildRedemNum_Req::set_rt0(const ::std::string& value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_rt0(const char* value) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_rt0(const char* value, size_t size) {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  rt0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_rt0() {
  set_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    rt0_ = new ::std::string;
  }
  return rt0_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_rt0() {
  clear_has_rt0();
  if (rt0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt0_;
    rt0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Localhost = 2;
inline bool INF_QueryVaildRedemNum_Req::has_localhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_localhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_localhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryVaildRedemNum_Req::clear_localhost() {
  if (localhost_ != &::google::protobuf::internal::kEmptyString) {
    localhost_->clear();
  }
  clear_has_localhost();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::localhost() const {
  return *localhost_;
}
inline void INF_QueryVaildRedemNum_Req::set_localhost(const ::std::string& value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_localhost(const char* value) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_localhost(const char* value, size_t size) {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  localhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_localhost() {
  set_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    localhost_ = new ::std::string;
  }
  return localhost_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_localhost() {
  clear_has_localhost();
  if (localhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localhost_;
    localhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ReqID = 3;
inline bool INF_QueryVaildRedemNum_Req::has_reqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_reqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_reqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryVaildRedemNum_Req::clear_reqid() {
  if (reqid_ != &::google::protobuf::internal::kEmptyString) {
    reqid_->clear();
  }
  clear_has_reqid();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::reqid() const {
  return *reqid_;
}
inline void INF_QueryVaildRedemNum_Req::set_reqid(const ::std::string& value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_reqid(const char* value) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_reqid(const char* value, size_t size) {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  reqid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_reqid() {
  set_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    reqid_ = new ::std::string;
  }
  return reqid_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_reqid() {
  clear_has_reqid();
  if (reqid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reqid_;
    reqid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FuncID = 4;
inline bool INF_QueryVaildRedemNum_Req::has_funcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_funcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryVaildRedemNum_Req::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::funcid() const {
  return *funcid_;
}
inline void INF_QueryVaildRedemNum_Req::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DepartmentID = 5;
inline bool INF_QueryVaildRedemNum_Req::has_departmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_departmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_departmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryVaildRedemNum_Req::clear_departmentid() {
  if (departmentid_ != &::google::protobuf::internal::kEmptyString) {
    departmentid_->clear();
  }
  clear_has_departmentid();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::departmentid() const {
  return *departmentid_;
}
inline void INF_QueryVaildRedemNum_Req::set_departmentid(const ::std::string& value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_departmentid(const char* value) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_departmentid(const char* value, size_t size) {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  departmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_departmentid() {
  set_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    departmentid_ = new ::std::string;
  }
  return departmentid_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_departmentid() {
  clear_has_departmentid();
  if (departmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departmentid_;
    departmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT5 = 6;
inline bool INF_QueryVaildRedemNum_Req::has_rt5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_rt5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_rt5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryVaildRedemNum_Req::clear_rt5() {
  if (rt5_ != &::google::protobuf::internal::kEmptyString) {
    rt5_->clear();
  }
  clear_has_rt5();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::rt5() const {
  return *rt5_;
}
inline void INF_QueryVaildRedemNum_Req::set_rt5(const ::std::string& value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_rt5(const char* value) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_rt5(const char* value, size_t size) {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  rt5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_rt5() {
  set_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    rt5_ = new ::std::string;
  }
  return rt5_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_rt5() {
  clear_has_rt5();
  if (rt5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt5_;
    rt5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RT6 = 7;
inline bool INF_QueryVaildRedemNum_Req::has_rt6() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_rt6() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_rt6() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryVaildRedemNum_Req::clear_rt6() {
  if (rt6_ != &::google::protobuf::internal::kEmptyString) {
    rt6_->clear();
  }
  clear_has_rt6();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::rt6() const {
  return *rt6_;
}
inline void INF_QueryVaildRedemNum_Req::set_rt6(const ::std::string& value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_rt6(const char* value) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_rt6(const char* value, size_t size) {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  rt6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_rt6() {
  set_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    rt6_ = new ::std::string;
  }
  return rt6_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_rt6() {
  clear_has_rt6();
  if (rt6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rt6_;
    rt6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CustomID = 8;
inline bool INF_QueryVaildRedemNum_Req::has_customid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_customid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_customid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryVaildRedemNum_Req::clear_customid() {
  if (customid_ != &::google::protobuf::internal::kEmptyString) {
    customid_->clear();
  }
  clear_has_customid();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::customid() const {
  return *customid_;
}
inline void INF_QueryVaildRedemNum_Req::set_customid(const ::std::string& value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_customid(const char* value) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_customid(const char* value, size_t size) {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  customid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_customid() {
  set_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    customid_ = new ::std::string;
  }
  return customid_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_customid() {
  clear_has_customid();
  if (customid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customid_;
    customid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFserialNumber = 9;
inline bool INF_QueryVaildRedemNum_Req::has_etfserialnumber() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_etfserialnumber() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_etfserialnumber() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryVaildRedemNum_Req::clear_etfserialnumber() {
  if (etfserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    etfserialnumber_->clear();
  }
  clear_has_etfserialnumber();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::etfserialnumber() const {
  return *etfserialnumber_;
}
inline void INF_QueryVaildRedemNum_Req::set_etfserialnumber(const ::std::string& value) {
  set_has_etfserialnumber();
  if (etfserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    etfserialnumber_ = new ::std::string;
  }
  etfserialnumber_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_etfserialnumber(const char* value) {
  set_has_etfserialnumber();
  if (etfserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    etfserialnumber_ = new ::std::string;
  }
  etfserialnumber_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_etfserialnumber(const char* value, size_t size) {
  set_has_etfserialnumber();
  if (etfserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    etfserialnumber_ = new ::std::string;
  }
  etfserialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_etfserialnumber() {
  set_has_etfserialnumber();
  if (etfserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    etfserialnumber_ = new ::std::string;
  }
  return etfserialnumber_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_etfserialnumber() {
  clear_has_etfserialnumber();
  if (etfserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfserialnumber_;
    etfserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 10;
inline bool INF_QueryVaildRedemNum_Req::has_securitycode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_securitycode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryVaildRedemNum_Req::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::securitycode() const {
  return *securitycode_;
}
inline void INF_QueryVaildRedemNum_Req::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PurRedemFlag = 11;
inline bool INF_QueryVaildRedemNum_Req::has_purredemflag() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_purredemflag() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_purredemflag() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryVaildRedemNum_Req::clear_purredemflag() {
  if (purredemflag_ != &::google::protobuf::internal::kEmptyString) {
    purredemflag_->clear();
  }
  clear_has_purredemflag();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::purredemflag() const {
  return *purredemflag_;
}
inline void INF_QueryVaildRedemNum_Req::set_purredemflag(const ::std::string& value) {
  set_has_purredemflag();
  if (purredemflag_ == &::google::protobuf::internal::kEmptyString) {
    purredemflag_ = new ::std::string;
  }
  purredemflag_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_purredemflag(const char* value) {
  set_has_purredemflag();
  if (purredemflag_ == &::google::protobuf::internal::kEmptyString) {
    purredemflag_ = new ::std::string;
  }
  purredemflag_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_purredemflag(const char* value, size_t size) {
  set_has_purredemflag();
  if (purredemflag_ == &::google::protobuf::internal::kEmptyString) {
    purredemflag_ = new ::std::string;
  }
  purredemflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_purredemflag() {
  set_has_purredemflag();
  if (purredemflag_ == &::google::protobuf::internal::kEmptyString) {
    purredemflag_ = new ::std::string;
  }
  return purredemflag_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_purredemflag() {
  clear_has_purredemflag();
  if (purredemflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = purredemflag_;
    purredemflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 12;
inline bool INF_QueryVaildRedemNum_Req::has_entrusttype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryVaildRedemNum_Req::set_has_entrusttype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryVaildRedemNum_Req::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryVaildRedemNum_Req::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryVaildRedemNum_Req::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryVaildRedemNum_Req::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryVaildRedemNum_Req::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryVaildRedemNum_Req::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryVaildRedemNum_Req::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_OneEntrust_Ack

// optional string EntrustSerial = 1;
inline bool INF_OneEntrust_Ack::has_entrustserial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_OneEntrust_Ack::set_has_entrustserial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_OneEntrust_Ack::clear_has_entrustserial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_OneEntrust_Ack::clear_entrustserial() {
  if (entrustserial_ != &::google::protobuf::internal::kEmptyString) {
    entrustserial_->clear();
  }
  clear_has_entrustserial();
}
inline const ::std::string& INF_OneEntrust_Ack::entrustserial() const {
  return *entrustserial_;
}
inline void INF_OneEntrust_Ack::set_entrustserial(const ::std::string& value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_OneEntrust_Ack::set_entrustserial(const char* value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_OneEntrust_Ack::set_entrustserial(const char* value, size_t size) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Ack::mutable_entrustserial() {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  return entrustserial_;
}
inline ::std::string* INF_OneEntrust_Ack::release_entrustserial() {
  clear_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustserial_;
    entrustserial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Valid = 2;
inline bool INF_OneEntrust_Ack::has_valid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_OneEntrust_Ack::set_has_valid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_OneEntrust_Ack::clear_has_valid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_OneEntrust_Ack::clear_valid() {
  if (valid_ != &::google::protobuf::internal::kEmptyString) {
    valid_->clear();
  }
  clear_has_valid();
}
inline const ::std::string& INF_OneEntrust_Ack::valid() const {
  return *valid_;
}
inline void INF_OneEntrust_Ack::set_valid(const ::std::string& value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_OneEntrust_Ack::set_valid(const char* value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_OneEntrust_Ack::set_valid(const char* value, size_t size) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Ack::mutable_valid() {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  return valid_;
}
inline ::std::string* INF_OneEntrust_Ack::release_valid() {
  clear_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_;
    valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 3;
inline bool INF_OneEntrust_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_OneEntrust_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_OneEntrust_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_OneEntrust_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_OneEntrust_Ack::respflag() const {
  return *respflag_;
}
inline void INF_OneEntrust_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_OneEntrust_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_OneEntrust_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_OneEntrust_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsSuccess = 4;
inline bool INF_OneEntrust_Ack::has_issuccess() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_OneEntrust_Ack::set_has_issuccess() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_OneEntrust_Ack::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_OneEntrust_Ack::clear_issuccess() {
  if (issuccess_ != &::google::protobuf::internal::kEmptyString) {
    issuccess_->clear();
  }
  clear_has_issuccess();
}
inline const ::std::string& INF_OneEntrust_Ack::issuccess() const {
  return *issuccess_;
}
inline void INF_OneEntrust_Ack::set_issuccess(const ::std::string& value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_OneEntrust_Ack::set_issuccess(const char* value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_OneEntrust_Ack::set_issuccess(const char* value, size_t size) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Ack::mutable_issuccess() {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  return issuccess_;
}
inline ::std::string* INF_OneEntrust_Ack::release_issuccess() {
  clear_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issuccess_;
    issuccess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustSeq = 5;
inline bool INF_OneEntrust_Ack::has_entrustseq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_OneEntrust_Ack::set_has_entrustseq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_OneEntrust_Ack::clear_has_entrustseq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_OneEntrust_Ack::clear_entrustseq() {
  if (entrustseq_ != &::google::protobuf::internal::kEmptyString) {
    entrustseq_->clear();
  }
  clear_has_entrustseq();
}
inline const ::std::string& INF_OneEntrust_Ack::entrustseq() const {
  return *entrustseq_;
}
inline void INF_OneEntrust_Ack::set_entrustseq(const ::std::string& value) {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  entrustseq_->assign(value);
}
inline void INF_OneEntrust_Ack::set_entrustseq(const char* value) {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  entrustseq_->assign(value);
}
inline void INF_OneEntrust_Ack::set_entrustseq(const char* value, size_t size) {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  entrustseq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Ack::mutable_entrustseq() {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  return entrustseq_;
}
inline ::std::string* INF_OneEntrust_Ack::release_entrustseq() {
  clear_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustseq_;
    entrustseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustBatchNO = 6;
inline bool INF_OneEntrust_Ack::has_entrustbatchno() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_OneEntrust_Ack::set_has_entrustbatchno() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_OneEntrust_Ack::clear_has_entrustbatchno() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_OneEntrust_Ack::clear_entrustbatchno() {
  if (entrustbatchno_ != &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_->clear();
  }
  clear_has_entrustbatchno();
}
inline const ::std::string& INF_OneEntrust_Ack::entrustbatchno() const {
  return *entrustbatchno_;
}
inline void INF_OneEntrust_Ack::set_entrustbatchno(const ::std::string& value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_OneEntrust_Ack::set_entrustbatchno(const char* value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_OneEntrust_Ack::set_entrustbatchno(const char* value, size_t size) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Ack::mutable_entrustbatchno() {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  return entrustbatchno_;
}
inline ::std::string* INF_OneEntrust_Ack::release_entrustbatchno() {
  clear_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustbatchno_;
    entrustbatchno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SuccessNum = 7;
inline bool INF_OneEntrust_Ack::has_successnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_OneEntrust_Ack::set_has_successnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_OneEntrust_Ack::clear_has_successnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_OneEntrust_Ack::clear_successnum() {
  if (successnum_ != &::google::protobuf::internal::kEmptyString) {
    successnum_->clear();
  }
  clear_has_successnum();
}
inline const ::std::string& INF_OneEntrust_Ack::successnum() const {
  return *successnum_;
}
inline void INF_OneEntrust_Ack::set_successnum(const ::std::string& value) {
  set_has_successnum();
  if (successnum_ == &::google::protobuf::internal::kEmptyString) {
    successnum_ = new ::std::string;
  }
  successnum_->assign(value);
}
inline void INF_OneEntrust_Ack::set_successnum(const char* value) {
  set_has_successnum();
  if (successnum_ == &::google::protobuf::internal::kEmptyString) {
    successnum_ = new ::std::string;
  }
  successnum_->assign(value);
}
inline void INF_OneEntrust_Ack::set_successnum(const char* value, size_t size) {
  set_has_successnum();
  if (successnum_ == &::google::protobuf::internal::kEmptyString) {
    successnum_ = new ::std::string;
  }
  successnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneEntrust_Ack::mutable_successnum() {
  set_has_successnum();
  if (successnum_ == &::google::protobuf::internal::kEmptyString) {
    successnum_ = new ::std::string;
  }
  return successnum_;
}
inline ::std::string* INF_OneEntrust_Ack::release_successnum() {
  clear_has_successnum();
  if (successnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = successnum_;
    successnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_BatchEntrust_Ack

// optional string EntrustSerial = 1;
inline bool INF_BatchEntrust_Ack::has_entrustserial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_BatchEntrust_Ack::set_has_entrustserial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_BatchEntrust_Ack::clear_has_entrustserial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_BatchEntrust_Ack::clear_entrustserial() {
  if (entrustserial_ != &::google::protobuf::internal::kEmptyString) {
    entrustserial_->clear();
  }
  clear_has_entrustserial();
}
inline const ::std::string& INF_BatchEntrust_Ack::entrustserial() const {
  return *entrustserial_;
}
inline void INF_BatchEntrust_Ack::set_entrustserial(const ::std::string& value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_entrustserial(const char* value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_entrustserial(const char* value, size_t size) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Ack::mutable_entrustserial() {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  return entrustserial_;
}
inline ::std::string* INF_BatchEntrust_Ack::release_entrustserial() {
  clear_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustserial_;
    entrustserial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Valid = 2;
inline bool INF_BatchEntrust_Ack::has_valid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_BatchEntrust_Ack::set_has_valid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_BatchEntrust_Ack::clear_has_valid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_BatchEntrust_Ack::clear_valid() {
  if (valid_ != &::google::protobuf::internal::kEmptyString) {
    valid_->clear();
  }
  clear_has_valid();
}
inline const ::std::string& INF_BatchEntrust_Ack::valid() const {
  return *valid_;
}
inline void INF_BatchEntrust_Ack::set_valid(const ::std::string& value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_valid(const char* value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_valid(const char* value, size_t size) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Ack::mutable_valid() {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  return valid_;
}
inline ::std::string* INF_BatchEntrust_Ack::release_valid() {
  clear_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_;
    valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 3;
inline bool INF_BatchEntrust_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_BatchEntrust_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_BatchEntrust_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_BatchEntrust_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_BatchEntrust_Ack::respflag() const {
  return *respflag_;
}
inline void INF_BatchEntrust_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_BatchEntrust_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsSuccess = 4;
inline bool INF_BatchEntrust_Ack::has_issuccess() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_BatchEntrust_Ack::set_has_issuccess() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_BatchEntrust_Ack::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_BatchEntrust_Ack::clear_issuccess() {
  if (issuccess_ != &::google::protobuf::internal::kEmptyString) {
    issuccess_->clear();
  }
  clear_has_issuccess();
}
inline const ::std::string& INF_BatchEntrust_Ack::issuccess() const {
  return *issuccess_;
}
inline void INF_BatchEntrust_Ack::set_issuccess(const ::std::string& value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_issuccess(const char* value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_issuccess(const char* value, size_t size) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Ack::mutable_issuccess() {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  return issuccess_;
}
inline ::std::string* INF_BatchEntrust_Ack::release_issuccess() {
  clear_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issuccess_;
    issuccess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RecordNum = 5;
inline bool INF_BatchEntrust_Ack::has_recordnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_BatchEntrust_Ack::set_has_recordnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_BatchEntrust_Ack::clear_has_recordnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_BatchEntrust_Ack::clear_recordnum() {
  if (recordnum_ != &::google::protobuf::internal::kEmptyString) {
    recordnum_->clear();
  }
  clear_has_recordnum();
}
inline const ::std::string& INF_BatchEntrust_Ack::recordnum() const {
  return *recordnum_;
}
inline void INF_BatchEntrust_Ack::set_recordnum(const ::std::string& value) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_recordnum(const char* value) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_recordnum(const char* value, size_t size) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Ack::mutable_recordnum() {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  return recordnum_;
}
inline ::std::string* INF_BatchEntrust_Ack::release_recordnum() {
  clear_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recordnum_;
    recordnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string TradingResults = 6;
inline bool INF_BatchEntrust_Ack::has_tradingresults() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_BatchEntrust_Ack::set_has_tradingresults() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_BatchEntrust_Ack::clear_has_tradingresults() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_BatchEntrust_Ack::clear_tradingresults() {
  if (tradingresults_ != &::google::protobuf::internal::kEmptyString) {
    tradingresults_->clear();
  }
  clear_has_tradingresults();
}
inline const ::std::string& INF_BatchEntrust_Ack::tradingresults() const {
  return *tradingresults_;
}
inline void INF_BatchEntrust_Ack::set_tradingresults(const ::std::string& value) {
  set_has_tradingresults();
  if (tradingresults_ == &::google::protobuf::internal::kEmptyString) {
    tradingresults_ = new ::std::string;
  }
  tradingresults_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_tradingresults(const char* value) {
  set_has_tradingresults();
  if (tradingresults_ == &::google::protobuf::internal::kEmptyString) {
    tradingresults_ = new ::std::string;
  }
  tradingresults_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_tradingresults(const char* value, size_t size) {
  set_has_tradingresults();
  if (tradingresults_ == &::google::protobuf::internal::kEmptyString) {
    tradingresults_ = new ::std::string;
  }
  tradingresults_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Ack::mutable_tradingresults() {
  set_has_tradingresults();
  if (tradingresults_ == &::google::protobuf::internal::kEmptyString) {
    tradingresults_ = new ::std::string;
  }
  return tradingresults_;
}
inline ::std::string* INF_BatchEntrust_Ack::release_tradingresults() {
  clear_has_tradingresults();
  if (tradingresults_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradingresults_;
    tradingresults_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustBatchNO = 7;
inline bool INF_BatchEntrust_Ack::has_entrustbatchno() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_BatchEntrust_Ack::set_has_entrustbatchno() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_BatchEntrust_Ack::clear_has_entrustbatchno() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_BatchEntrust_Ack::clear_entrustbatchno() {
  if (entrustbatchno_ != &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_->clear();
  }
  clear_has_entrustbatchno();
}
inline const ::std::string& INF_BatchEntrust_Ack::entrustbatchno() const {
  return *entrustbatchno_;
}
inline void INF_BatchEntrust_Ack::set_entrustbatchno(const ::std::string& value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_entrustbatchno(const char* value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_entrustbatchno(const char* value, size_t size) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Ack::mutable_entrustbatchno() {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  return entrustbatchno_;
}
inline ::std::string* INF_BatchEntrust_Ack::release_entrustbatchno() {
  clear_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustbatchno_;
    entrustbatchno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BargainNO = 8;
inline bool INF_BatchEntrust_Ack::has_bargainno() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_BatchEntrust_Ack::set_has_bargainno() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_BatchEntrust_Ack::clear_has_bargainno() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_BatchEntrust_Ack::clear_bargainno() {
  if (bargainno_ != &::google::protobuf::internal::kEmptyString) {
    bargainno_->clear();
  }
  clear_has_bargainno();
}
inline const ::std::string& INF_BatchEntrust_Ack::bargainno() const {
  return *bargainno_;
}
inline void INF_BatchEntrust_Ack::set_bargainno(const ::std::string& value) {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  bargainno_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_bargainno(const char* value) {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  bargainno_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_bargainno(const char* value, size_t size) {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  bargainno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Ack::mutable_bargainno() {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  return bargainno_;
}
inline ::std::string* INF_BatchEntrust_Ack::release_bargainno() {
  clear_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bargainno_;
    bargainno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustSeq = 9;
inline bool INF_BatchEntrust_Ack::has_entrustseq() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_BatchEntrust_Ack::set_has_entrustseq() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_BatchEntrust_Ack::clear_has_entrustseq() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_BatchEntrust_Ack::clear_entrustseq() {
  if (entrustseq_ != &::google::protobuf::internal::kEmptyString) {
    entrustseq_->clear();
  }
  clear_has_entrustseq();
}
inline const ::std::string& INF_BatchEntrust_Ack::entrustseq() const {
  return *entrustseq_;
}
inline void INF_BatchEntrust_Ack::set_entrustseq(const ::std::string& value) {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  entrustseq_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_entrustseq(const char* value) {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  entrustseq_->assign(value);
}
inline void INF_BatchEntrust_Ack::set_entrustseq(const char* value, size_t size) {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  entrustseq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchEntrust_Ack::mutable_entrustseq() {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  return entrustseq_;
}
inline ::std::string* INF_BatchEntrust_Ack::release_entrustseq() {
  clear_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustseq_;
    entrustseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryOneEntrust_Ack

// optional string Valid = 1;
inline bool INF_QueryOneEntrust_Ack::has_valid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_valid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_valid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryOneEntrust_Ack::clear_valid() {
  if (valid_ != &::google::protobuf::internal::kEmptyString) {
    valid_->clear();
  }
  clear_has_valid();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::valid() const {
  return *valid_;
}
inline void INF_QueryOneEntrust_Ack::set_valid(const ::std::string& value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_valid(const char* value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_valid(const char* value, size_t size) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_valid() {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  return valid_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_valid() {
  clear_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_;
    valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 2;
inline bool INF_QueryOneEntrust_Ack::has_securitycode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_securitycode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryOneEntrust_Ack::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::securitycode() const {
  return *securitycode_;
}
inline void INF_QueryOneEntrust_Ack::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityName = 3;
inline bool INF_QueryOneEntrust_Ack::has_securityname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_securityname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_securityname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryOneEntrust_Ack::clear_securityname() {
  if (securityname_ != &::google::protobuf::internal::kEmptyString) {
    securityname_->clear();
  }
  clear_has_securityname();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::securityname() const {
  return *securityname_;
}
inline void INF_QueryOneEntrust_Ack::set_securityname(const ::std::string& value) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_securityname(const char* value) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_securityname(const char* value, size_t size) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_securityname() {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  return securityname_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_securityname() {
  clear_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securityname_;
    securityname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustNum = 4;
inline bool INF_QueryOneEntrust_Ack::has_entrustnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_entrustnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_entrustnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryOneEntrust_Ack::clear_entrustnum() {
  if (entrustnum_ != &::google::protobuf::internal::kEmptyString) {
    entrustnum_->clear();
  }
  clear_has_entrustnum();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::entrustnum() const {
  return *entrustnum_;
}
inline void INF_QueryOneEntrust_Ack::set_entrustnum(const ::std::string& value) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrustnum(const char* value) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrustnum(const char* value, size_t size) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_entrustnum() {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  return entrustnum_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_entrustnum() {
  clear_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustnum_;
    entrustnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustPrice = 5;
inline bool INF_QueryOneEntrust_Ack::has_entrustprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_entrustprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_entrustprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryOneEntrust_Ack::clear_entrustprice() {
  if (entrustprice_ != &::google::protobuf::internal::kEmptyString) {
    entrustprice_->clear();
  }
  clear_has_entrustprice();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::entrustprice() const {
  return *entrustprice_;
}
inline void INF_QueryOneEntrust_Ack::set_entrustprice(const ::std::string& value) {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  entrustprice_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrustprice(const char* value) {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  entrustprice_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrustprice(const char* value, size_t size) {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  entrustprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_entrustprice() {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  return entrustprice_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_entrustprice() {
  clear_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustprice_;
    entrustprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustSerial = 6;
inline bool INF_QueryOneEntrust_Ack::has_entrustserial() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_entrustserial() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_entrustserial() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryOneEntrust_Ack::clear_entrustserial() {
  if (entrustserial_ != &::google::protobuf::internal::kEmptyString) {
    entrustserial_->clear();
  }
  clear_has_entrustserial();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::entrustserial() const {
  return *entrustserial_;
}
inline void INF_QueryOneEntrust_Ack::set_entrustserial(const ::std::string& value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrustserial(const char* value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrustserial(const char* value, size_t size) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_entrustserial() {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  return entrustserial_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_entrustserial() {
  clear_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustserial_;
    entrustserial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjNum = 7;
inline bool INF_QueryOneEntrust_Ack::has_cjnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_cjnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_cjnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryOneEntrust_Ack::clear_cjnum() {
  if (cjnum_ != &::google::protobuf::internal::kEmptyString) {
    cjnum_->clear();
  }
  clear_has_cjnum();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::cjnum() const {
  return *cjnum_;
}
inline void INF_QueryOneEntrust_Ack::set_cjnum(const ::std::string& value) {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  cjnum_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cjnum(const char* value) {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  cjnum_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cjnum(const char* value, size_t size) {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  cjnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_cjnum() {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  return cjnum_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_cjnum() {
  clear_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjnum_;
    cjnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustTime = 8;
inline bool INF_QueryOneEntrust_Ack::has_entrusttime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_entrusttime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_entrusttime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryOneEntrust_Ack::clear_entrusttime() {
  if (entrusttime_ != &::google::protobuf::internal::kEmptyString) {
    entrusttime_->clear();
  }
  clear_has_entrusttime();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::entrusttime() const {
  return *entrusttime_;
}
inline void INF_QueryOneEntrust_Ack::set_entrusttime(const ::std::string& value) {
  set_has_entrusttime();
  if (entrusttime_ == &::google::protobuf::internal::kEmptyString) {
    entrusttime_ = new ::std::string;
  }
  entrusttime_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrusttime(const char* value) {
  set_has_entrusttime();
  if (entrusttime_ == &::google::protobuf::internal::kEmptyString) {
    entrusttime_ = new ::std::string;
  }
  entrusttime_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrusttime(const char* value, size_t size) {
  set_has_entrusttime();
  if (entrusttime_ == &::google::protobuf::internal::kEmptyString) {
    entrusttime_ = new ::std::string;
  }
  entrusttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_entrusttime() {
  set_has_entrusttime();
  if (entrusttime_ == &::google::protobuf::internal::kEmptyString) {
    entrusttime_ = new ::std::string;
  }
  return entrusttime_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_entrusttime() {
  clear_has_entrusttime();
  if (entrusttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttime_;
    entrusttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MarketID = 9;
inline bool INF_QueryOneEntrust_Ack::has_marketid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_marketid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryOneEntrust_Ack::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::marketid() const {
  return *marketid_;
}
inline void INF_QueryOneEntrust_Ack::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BSflag = 10;
inline bool INF_QueryOneEntrust_Ack::has_bsflag() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_bsflag() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_bsflag() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryOneEntrust_Ack::clear_bsflag() {
  if (bsflag_ != &::google::protobuf::internal::kEmptyString) {
    bsflag_->clear();
  }
  clear_has_bsflag();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::bsflag() const {
  return *bsflag_;
}
inline void INF_QueryOneEntrust_Ack::set_bsflag(const ::std::string& value) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_bsflag(const char* value) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_bsflag(const char* value, size_t size) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_bsflag() {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  return bsflag_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_bsflag() {
  clear_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bsflag_;
    bsflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustStatus = 11;
inline bool INF_QueryOneEntrust_Ack::has_entruststatus() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_entruststatus() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_entruststatus() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryOneEntrust_Ack::clear_entruststatus() {
  if (entruststatus_ != &::google::protobuf::internal::kEmptyString) {
    entruststatus_->clear();
  }
  clear_has_entruststatus();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::entruststatus() const {
  return *entruststatus_;
}
inline void INF_QueryOneEntrust_Ack::set_entruststatus(const ::std::string& value) {
  set_has_entruststatus();
  if (entruststatus_ == &::google::protobuf::internal::kEmptyString) {
    entruststatus_ = new ::std::string;
  }
  entruststatus_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entruststatus(const char* value) {
  set_has_entruststatus();
  if (entruststatus_ == &::google::protobuf::internal::kEmptyString) {
    entruststatus_ = new ::std::string;
  }
  entruststatus_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entruststatus(const char* value, size_t size) {
  set_has_entruststatus();
  if (entruststatus_ == &::google::protobuf::internal::kEmptyString) {
    entruststatus_ = new ::std::string;
  }
  entruststatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_entruststatus() {
  set_has_entruststatus();
  if (entruststatus_ == &::google::protobuf::internal::kEmptyString) {
    entruststatus_ = new ::std::string;
  }
  return entruststatus_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_entruststatus() {
  clear_has_entruststatus();
  if (entruststatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entruststatus_;
    entruststatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjPriceSum = 12;
inline bool INF_QueryOneEntrust_Ack::has_cjpricesum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_cjpricesum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_cjpricesum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryOneEntrust_Ack::clear_cjpricesum() {
  if (cjpricesum_ != &::google::protobuf::internal::kEmptyString) {
    cjpricesum_->clear();
  }
  clear_has_cjpricesum();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::cjpricesum() const {
  return *cjpricesum_;
}
inline void INF_QueryOneEntrust_Ack::set_cjpricesum(const ::std::string& value) {
  set_has_cjpricesum();
  if (cjpricesum_ == &::google::protobuf::internal::kEmptyString) {
    cjpricesum_ = new ::std::string;
  }
  cjpricesum_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cjpricesum(const char* value) {
  set_has_cjpricesum();
  if (cjpricesum_ == &::google::protobuf::internal::kEmptyString) {
    cjpricesum_ = new ::std::string;
  }
  cjpricesum_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cjpricesum(const char* value, size_t size) {
  set_has_cjpricesum();
  if (cjpricesum_ == &::google::protobuf::internal::kEmptyString) {
    cjpricesum_ = new ::std::string;
  }
  cjpricesum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_cjpricesum() {
  set_has_cjpricesum();
  if (cjpricesum_ == &::google::protobuf::internal::kEmptyString) {
    cjpricesum_ = new ::std::string;
  }
  return cjpricesum_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_cjpricesum() {
  clear_has_cjpricesum();
  if (cjpricesum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjpricesum_;
    cjpricesum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 13;
inline bool INF_QueryOneEntrust_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_QueryOneEntrust_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::respflag() const {
  return *respflag_;
}
inline void INF_QueryOneEntrust_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsSuccess = 14;
inline bool INF_QueryOneEntrust_Ack::has_issuccess() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_issuccess() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_QueryOneEntrust_Ack::clear_issuccess() {
  if (issuccess_ != &::google::protobuf::internal::kEmptyString) {
    issuccess_->clear();
  }
  clear_has_issuccess();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::issuccess() const {
  return *issuccess_;
}
inline void INF_QueryOneEntrust_Ack::set_issuccess(const ::std::string& value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_issuccess(const char* value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_issuccess(const char* value, size_t size) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_issuccess() {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  return issuccess_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_issuccess() {
  clear_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issuccess_;
    issuccess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RecordNum = 15;
inline bool INF_QueryOneEntrust_Ack::has_recordnum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_recordnum() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_recordnum() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_QueryOneEntrust_Ack::clear_recordnum() {
  if (recordnum_ != &::google::protobuf::internal::kEmptyString) {
    recordnum_->clear();
  }
  clear_has_recordnum();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::recordnum() const {
  return *recordnum_;
}
inline void INF_QueryOneEntrust_Ack::set_recordnum(const ::std::string& value) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_recordnum(const char* value) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_recordnum(const char* value, size_t size) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_recordnum() {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  return recordnum_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_recordnum() {
  clear_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recordnum_;
    recordnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string StockholderAccount = 16;
inline bool INF_QueryOneEntrust_Ack::has_stockholderaccount() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_stockholderaccount() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_stockholderaccount() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_QueryOneEntrust_Ack::clear_stockholderaccount() {
  if (stockholderaccount_ != &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_->clear();
  }
  clear_has_stockholderaccount();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::stockholderaccount() const {
  return *stockholderaccount_;
}
inline void INF_QueryOneEntrust_Ack::set_stockholderaccount(const ::std::string& value) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_stockholderaccount(const char* value) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_stockholderaccount(const char* value, size_t size) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_stockholderaccount() {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  return stockholderaccount_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_stockholderaccount() {
  clear_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stockholderaccount_;
    stockholderaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BSTypeName = 17;
inline bool INF_QueryOneEntrust_Ack::has_bstypename() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_bstypename() {
  _has_bits_[0] |= 0x00010000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_bstypename() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void INF_QueryOneEntrust_Ack::clear_bstypename() {
  if (bstypename_ != &::google::protobuf::internal::kEmptyString) {
    bstypename_->clear();
  }
  clear_has_bstypename();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::bstypename() const {
  return *bstypename_;
}
inline void INF_QueryOneEntrust_Ack::set_bstypename(const ::std::string& value) {
  set_has_bstypename();
  if (bstypename_ == &::google::protobuf::internal::kEmptyString) {
    bstypename_ = new ::std::string;
  }
  bstypename_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_bstypename(const char* value) {
  set_has_bstypename();
  if (bstypename_ == &::google::protobuf::internal::kEmptyString) {
    bstypename_ = new ::std::string;
  }
  bstypename_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_bstypename(const char* value, size_t size) {
  set_has_bstypename();
  if (bstypename_ == &::google::protobuf::internal::kEmptyString) {
    bstypename_ = new ::std::string;
  }
  bstypename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_bstypename() {
  set_has_bstypename();
  if (bstypename_ == &::google::protobuf::internal::kEmptyString) {
    bstypename_ = new ::std::string;
  }
  return bstypename_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_bstypename() {
  clear_has_bstypename();
  if (bstypename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bstypename_;
    bstypename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BSTypeFlag = 18;
inline bool INF_QueryOneEntrust_Ack::has_bstypeflag() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_bstypeflag() {
  _has_bits_[0] |= 0x00020000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_bstypeflag() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void INF_QueryOneEntrust_Ack::clear_bstypeflag() {
  if (bstypeflag_ != &::google::protobuf::internal::kEmptyString) {
    bstypeflag_->clear();
  }
  clear_has_bstypeflag();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::bstypeflag() const {
  return *bstypeflag_;
}
inline void INF_QueryOneEntrust_Ack::set_bstypeflag(const ::std::string& value) {
  set_has_bstypeflag();
  if (bstypeflag_ == &::google::protobuf::internal::kEmptyString) {
    bstypeflag_ = new ::std::string;
  }
  bstypeflag_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_bstypeflag(const char* value) {
  set_has_bstypeflag();
  if (bstypeflag_ == &::google::protobuf::internal::kEmptyString) {
    bstypeflag_ = new ::std::string;
  }
  bstypeflag_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_bstypeflag(const char* value, size_t size) {
  set_has_bstypeflag();
  if (bstypeflag_ == &::google::protobuf::internal::kEmptyString) {
    bstypeflag_ = new ::std::string;
  }
  bstypeflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_bstypeflag() {
  set_has_bstypeflag();
  if (bstypeflag_ == &::google::protobuf::internal::kEmptyString) {
    bstypeflag_ = new ::std::string;
  }
  return bstypeflag_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_bstypeflag() {
  clear_has_bstypeflag();
  if (bstypeflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bstypeflag_;
    bstypeflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BargainNO = 19;
inline bool INF_QueryOneEntrust_Ack::has_bargainno() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_bargainno() {
  _has_bits_[0] |= 0x00040000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_bargainno() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void INF_QueryOneEntrust_Ack::clear_bargainno() {
  if (bargainno_ != &::google::protobuf::internal::kEmptyString) {
    bargainno_->clear();
  }
  clear_has_bargainno();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::bargainno() const {
  return *bargainno_;
}
inline void INF_QueryOneEntrust_Ack::set_bargainno(const ::std::string& value) {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  bargainno_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_bargainno(const char* value) {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  bargainno_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_bargainno(const char* value, size_t size) {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  bargainno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_bargainno() {
  set_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    bargainno_ = new ::std::string;
  }
  return bargainno_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_bargainno() {
  clear_has_bargainno();
  if (bargainno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bargainno_;
    bargainno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjPrice = 20;
inline bool INF_QueryOneEntrust_Ack::has_cjprice() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_cjprice() {
  _has_bits_[0] |= 0x00080000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_cjprice() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void INF_QueryOneEntrust_Ack::clear_cjprice() {
  if (cjprice_ != &::google::protobuf::internal::kEmptyString) {
    cjprice_->clear();
  }
  clear_has_cjprice();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::cjprice() const {
  return *cjprice_;
}
inline void INF_QueryOneEntrust_Ack::set_cjprice(const ::std::string& value) {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  cjprice_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cjprice(const char* value) {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  cjprice_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cjprice(const char* value, size_t size) {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  cjprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_cjprice() {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  return cjprice_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_cjprice() {
  clear_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjprice_;
    cjprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjStatusName = 21;
inline bool INF_QueryOneEntrust_Ack::has_cjstatusname() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_cjstatusname() {
  _has_bits_[0] |= 0x00100000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_cjstatusname() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void INF_QueryOneEntrust_Ack::clear_cjstatusname() {
  if (cjstatusname_ != &::google::protobuf::internal::kEmptyString) {
    cjstatusname_->clear();
  }
  clear_has_cjstatusname();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::cjstatusname() const {
  return *cjstatusname_;
}
inline void INF_QueryOneEntrust_Ack::set_cjstatusname(const ::std::string& value) {
  set_has_cjstatusname();
  if (cjstatusname_ == &::google::protobuf::internal::kEmptyString) {
    cjstatusname_ = new ::std::string;
  }
  cjstatusname_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cjstatusname(const char* value) {
  set_has_cjstatusname();
  if (cjstatusname_ == &::google::protobuf::internal::kEmptyString) {
    cjstatusname_ = new ::std::string;
  }
  cjstatusname_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cjstatusname(const char* value, size_t size) {
  set_has_cjstatusname();
  if (cjstatusname_ == &::google::protobuf::internal::kEmptyString) {
    cjstatusname_ = new ::std::string;
  }
  cjstatusname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_cjstatusname() {
  set_has_cjstatusname();
  if (cjstatusname_ == &::google::protobuf::internal::kEmptyString) {
    cjstatusname_ = new ::std::string;
  }
  return cjstatusname_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_cjstatusname() {
  clear_has_cjstatusname();
  if (cjstatusname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjstatusname_;
    cjstatusname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Date = 22;
inline bool INF_QueryOneEntrust_Ack::has_date() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_date() {
  _has_bits_[0] |= 0x00200000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_date() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void INF_QueryOneEntrust_Ack::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::date() const {
  return *date_;
}
inline void INF_QueryOneEntrust_Ack::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ErrorMsg = 23;
inline bool INF_QueryOneEntrust_Ack::has_errormsg() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_errormsg() {
  _has_bits_[0] |= 0x00400000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void INF_QueryOneEntrust_Ack::clear_errormsg() {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    errormsg_->clear();
  }
  clear_has_errormsg();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::errormsg() const {
  return *errormsg_;
}
inline void INF_QueryOneEntrust_Ack::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_errormsg(const char* value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  return errormsg_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_errormsg() {
  clear_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormsg_;
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ErrorCode = 24;
inline bool INF_QueryOneEntrust_Ack::has_errorcode() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_errorcode() {
  _has_bits_[0] |= 0x00800000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void INF_QueryOneEntrust_Ack::clear_errorcode() {
  if (errorcode_ != &::google::protobuf::internal::kEmptyString) {
    errorcode_->clear();
  }
  clear_has_errorcode();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::errorcode() const {
  return *errorcode_;
}
inline void INF_QueryOneEntrust_Ack::set_errorcode(const ::std::string& value) {
  set_has_errorcode();
  if (errorcode_ == &::google::protobuf::internal::kEmptyString) {
    errorcode_ = new ::std::string;
  }
  errorcode_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_errorcode(const char* value) {
  set_has_errorcode();
  if (errorcode_ == &::google::protobuf::internal::kEmptyString) {
    errorcode_ = new ::std::string;
  }
  errorcode_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_errorcode(const char* value, size_t size) {
  set_has_errorcode();
  if (errorcode_ == &::google::protobuf::internal::kEmptyString) {
    errorcode_ = new ::std::string;
  }
  errorcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_errorcode() {
  set_has_errorcode();
  if (errorcode_ == &::google::protobuf::internal::kEmptyString) {
    errorcode_ = new ::std::string;
  }
  return errorcode_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_errorcode() {
  clear_has_errorcode();
  if (errorcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errorcode_;
    errorcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjStatus = 25;
inline bool INF_QueryOneEntrust_Ack::has_cjstatus() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_cjstatus() {
  _has_bits_[0] |= 0x01000000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_cjstatus() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void INF_QueryOneEntrust_Ack::clear_cjstatus() {
  if (cjstatus_ != &::google::protobuf::internal::kEmptyString) {
    cjstatus_->clear();
  }
  clear_has_cjstatus();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::cjstatus() const {
  return *cjstatus_;
}
inline void INF_QueryOneEntrust_Ack::set_cjstatus(const ::std::string& value) {
  set_has_cjstatus();
  if (cjstatus_ == &::google::protobuf::internal::kEmptyString) {
    cjstatus_ = new ::std::string;
  }
  cjstatus_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cjstatus(const char* value) {
  set_has_cjstatus();
  if (cjstatus_ == &::google::protobuf::internal::kEmptyString) {
    cjstatus_ = new ::std::string;
  }
  cjstatus_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cjstatus(const char* value, size_t size) {
  set_has_cjstatus();
  if (cjstatus_ == &::google::protobuf::internal::kEmptyString) {
    cjstatus_ = new ::std::string;
  }
  cjstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_cjstatus() {
  set_has_cjstatus();
  if (cjstatus_ == &::google::protobuf::internal::kEmptyString) {
    cjstatus_ = new ::std::string;
  }
  return cjstatus_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_cjstatus() {
  clear_has_cjstatus();
  if (cjstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjstatus_;
    cjstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustStatusFlag = 26;
inline bool INF_QueryOneEntrust_Ack::has_entruststatusflag() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_entruststatusflag() {
  _has_bits_[0] |= 0x02000000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_entruststatusflag() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void INF_QueryOneEntrust_Ack::clear_entruststatusflag() {
  if (entruststatusflag_ != &::google::protobuf::internal::kEmptyString) {
    entruststatusflag_->clear();
  }
  clear_has_entruststatusflag();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::entruststatusflag() const {
  return *entruststatusflag_;
}
inline void INF_QueryOneEntrust_Ack::set_entruststatusflag(const ::std::string& value) {
  set_has_entruststatusflag();
  if (entruststatusflag_ == &::google::protobuf::internal::kEmptyString) {
    entruststatusflag_ = new ::std::string;
  }
  entruststatusflag_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entruststatusflag(const char* value) {
  set_has_entruststatusflag();
  if (entruststatusflag_ == &::google::protobuf::internal::kEmptyString) {
    entruststatusflag_ = new ::std::string;
  }
  entruststatusflag_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entruststatusflag(const char* value, size_t size) {
  set_has_entruststatusflag();
  if (entruststatusflag_ == &::google::protobuf::internal::kEmptyString) {
    entruststatusflag_ = new ::std::string;
  }
  entruststatusflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_entruststatusflag() {
  set_has_entruststatusflag();
  if (entruststatusflag_ == &::google::protobuf::internal::kEmptyString) {
    entruststatusflag_ = new ::std::string;
  }
  return entruststatusflag_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_entruststatusflag() {
  clear_has_entruststatusflag();
  if (entruststatusflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entruststatusflag_;
    entruststatusflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CancelOrderNum = 27;
inline bool INF_QueryOneEntrust_Ack::has_cancelordernum() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_cancelordernum() {
  _has_bits_[0] |= 0x04000000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_cancelordernum() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void INF_QueryOneEntrust_Ack::clear_cancelordernum() {
  if (cancelordernum_ != &::google::protobuf::internal::kEmptyString) {
    cancelordernum_->clear();
  }
  clear_has_cancelordernum();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::cancelordernum() const {
  return *cancelordernum_;
}
inline void INF_QueryOneEntrust_Ack::set_cancelordernum(const ::std::string& value) {
  set_has_cancelordernum();
  if (cancelordernum_ == &::google::protobuf::internal::kEmptyString) {
    cancelordernum_ = new ::std::string;
  }
  cancelordernum_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cancelordernum(const char* value) {
  set_has_cancelordernum();
  if (cancelordernum_ == &::google::protobuf::internal::kEmptyString) {
    cancelordernum_ = new ::std::string;
  }
  cancelordernum_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_cancelordernum(const char* value, size_t size) {
  set_has_cancelordernum();
  if (cancelordernum_ == &::google::protobuf::internal::kEmptyString) {
    cancelordernum_ = new ::std::string;
  }
  cancelordernum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_cancelordernum() {
  set_has_cancelordernum();
  if (cancelordernum_ == &::google::protobuf::internal::kEmptyString) {
    cancelordernum_ = new ::std::string;
  }
  return cancelordernum_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_cancelordernum() {
  clear_has_cancelordernum();
  if (cancelordernum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cancelordernum_;
    cancelordernum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustAttr = 28;
inline bool INF_QueryOneEntrust_Ack::has_entrustattr() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_entrustattr() {
  _has_bits_[0] |= 0x08000000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_entrustattr() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void INF_QueryOneEntrust_Ack::clear_entrustattr() {
  if (entrustattr_ != &::google::protobuf::internal::kEmptyString) {
    entrustattr_->clear();
  }
  clear_has_entrustattr();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::entrustattr() const {
  return *entrustattr_;
}
inline void INF_QueryOneEntrust_Ack::set_entrustattr(const ::std::string& value) {
  set_has_entrustattr();
  if (entrustattr_ == &::google::protobuf::internal::kEmptyString) {
    entrustattr_ = new ::std::string;
  }
  entrustattr_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrustattr(const char* value) {
  set_has_entrustattr();
  if (entrustattr_ == &::google::protobuf::internal::kEmptyString) {
    entrustattr_ = new ::std::string;
  }
  entrustattr_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrustattr(const char* value, size_t size) {
  set_has_entrustattr();
  if (entrustattr_ == &::google::protobuf::internal::kEmptyString) {
    entrustattr_ = new ::std::string;
  }
  entrustattr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_entrustattr() {
  set_has_entrustattr();
  if (entrustattr_ == &::google::protobuf::internal::kEmptyString) {
    entrustattr_ = new ::std::string;
  }
  return entrustattr_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_entrustattr() {
  clear_has_entrustattr();
  if (entrustattr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustattr_;
    entrustattr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 29;
inline bool INF_QueryOneEntrust_Ack::has_entrusttype() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void INF_QueryOneEntrust_Ack::set_has_entrusttype() {
  _has_bits_[0] |= 0x10000000u;
}
inline void INF_QueryOneEntrust_Ack::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void INF_QueryOneEntrust_Ack::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryOneEntrust_Ack::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryOneEntrust_Ack::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryOneEntrust_Ack::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryOneEntrust_Ack::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryOneEntrust_Ack::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryBatchEntrust_Ack

// optional string EntrustBatchNO = 1;
inline bool INF_QueryBatchEntrust_Ack::has_entrustbatchno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_entrustbatchno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_entrustbatchno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryBatchEntrust_Ack::clear_entrustbatchno() {
  if (entrustbatchno_ != &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_->clear();
  }
  clear_has_entrustbatchno();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::entrustbatchno() const {
  return *entrustbatchno_;
}
inline void INF_QueryBatchEntrust_Ack::set_entrustbatchno(const ::std::string& value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustbatchno(const char* value) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustbatchno(const char* value, size_t size) {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  entrustbatchno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_entrustbatchno() {
  set_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    entrustbatchno_ = new ::std::string;
  }
  return entrustbatchno_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_entrustbatchno() {
  clear_has_entrustbatchno();
  if (entrustbatchno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustbatchno_;
    entrustbatchno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustSeq = 2;
inline bool INF_QueryBatchEntrust_Ack::has_entrustseq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_entrustseq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_entrustseq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryBatchEntrust_Ack::clear_entrustseq() {
  if (entrustseq_ != &::google::protobuf::internal::kEmptyString) {
    entrustseq_->clear();
  }
  clear_has_entrustseq();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::entrustseq() const {
  return *entrustseq_;
}
inline void INF_QueryBatchEntrust_Ack::set_entrustseq(const ::std::string& value) {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  entrustseq_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustseq(const char* value) {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  entrustseq_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustseq(const char* value, size_t size) {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  entrustseq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_entrustseq() {
  set_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    entrustseq_ = new ::std::string;
  }
  return entrustseq_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_entrustseq() {
  clear_has_entrustseq();
  if (entrustseq_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustseq_;
    entrustseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MarketID = 3;
inline bool INF_QueryBatchEntrust_Ack::has_marketid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_marketid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryBatchEntrust_Ack::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::marketid() const {
  return *marketid_;
}
inline void INF_QueryBatchEntrust_Ack::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 4;
inline bool INF_QueryBatchEntrust_Ack::has_securitycode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_securitycode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryBatchEntrust_Ack::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::securitycode() const {
  return *securitycode_;
}
inline void INF_QueryBatchEntrust_Ack::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BSflag = 5;
inline bool INF_QueryBatchEntrust_Ack::has_bsflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_bsflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_bsflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryBatchEntrust_Ack::clear_bsflag() {
  if (bsflag_ != &::google::protobuf::internal::kEmptyString) {
    bsflag_->clear();
  }
  clear_has_bsflag();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::bsflag() const {
  return *bsflag_;
}
inline void INF_QueryBatchEntrust_Ack::set_bsflag(const ::std::string& value) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_bsflag(const char* value) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_bsflag(const char* value, size_t size) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_bsflag() {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  return bsflag_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_bsflag() {
  clear_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bsflag_;
    bsflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustNum = 6;
inline bool INF_QueryBatchEntrust_Ack::has_entrustnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_entrustnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_entrustnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryBatchEntrust_Ack::clear_entrustnum() {
  if (entrustnum_ != &::google::protobuf::internal::kEmptyString) {
    entrustnum_->clear();
  }
  clear_has_entrustnum();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::entrustnum() const {
  return *entrustnum_;
}
inline void INF_QueryBatchEntrust_Ack::set_entrustnum(const ::std::string& value) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustnum(const char* value) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustnum(const char* value, size_t size) {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  entrustnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_entrustnum() {
  set_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    entrustnum_ = new ::std::string;
  }
  return entrustnum_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_entrustnum() {
  clear_has_entrustnum();
  if (entrustnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustnum_;
    entrustnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustPrice = 7;
inline bool INF_QueryBatchEntrust_Ack::has_entrustprice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_entrustprice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_entrustprice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryBatchEntrust_Ack::clear_entrustprice() {
  if (entrustprice_ != &::google::protobuf::internal::kEmptyString) {
    entrustprice_->clear();
  }
  clear_has_entrustprice();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::entrustprice() const {
  return *entrustprice_;
}
inline void INF_QueryBatchEntrust_Ack::set_entrustprice(const ::std::string& value) {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  entrustprice_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustprice(const char* value) {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  entrustprice_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustprice(const char* value, size_t size) {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  entrustprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_entrustprice() {
  set_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    entrustprice_ = new ::std::string;
  }
  return entrustprice_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_entrustprice() {
  clear_has_entrustprice();
  if (entrustprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustprice_;
    entrustprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustStatus = 8;
inline bool INF_QueryBatchEntrust_Ack::has_entruststatus() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_entruststatus() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_entruststatus() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryBatchEntrust_Ack::clear_entruststatus() {
  if (entruststatus_ != &::google::protobuf::internal::kEmptyString) {
    entruststatus_->clear();
  }
  clear_has_entruststatus();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::entruststatus() const {
  return *entruststatus_;
}
inline void INF_QueryBatchEntrust_Ack::set_entruststatus(const ::std::string& value) {
  set_has_entruststatus();
  if (entruststatus_ == &::google::protobuf::internal::kEmptyString) {
    entruststatus_ = new ::std::string;
  }
  entruststatus_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entruststatus(const char* value) {
  set_has_entruststatus();
  if (entruststatus_ == &::google::protobuf::internal::kEmptyString) {
    entruststatus_ = new ::std::string;
  }
  entruststatus_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entruststatus(const char* value, size_t size) {
  set_has_entruststatus();
  if (entruststatus_ == &::google::protobuf::internal::kEmptyString) {
    entruststatus_ = new ::std::string;
  }
  entruststatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_entruststatus() {
  set_has_entruststatus();
  if (entruststatus_ == &::google::protobuf::internal::kEmptyString) {
    entruststatus_ = new ::std::string;
  }
  return entruststatus_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_entruststatus() {
  clear_has_entruststatus();
  if (entruststatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entruststatus_;
    entruststatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjNum = 9;
inline bool INF_QueryBatchEntrust_Ack::has_cjnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_cjnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_cjnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryBatchEntrust_Ack::clear_cjnum() {
  if (cjnum_ != &::google::protobuf::internal::kEmptyString) {
    cjnum_->clear();
  }
  clear_has_cjnum();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::cjnum() const {
  return *cjnum_;
}
inline void INF_QueryBatchEntrust_Ack::set_cjnum(const ::std::string& value) {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  cjnum_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_cjnum(const char* value) {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  cjnum_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_cjnum(const char* value, size_t size) {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  cjnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_cjnum() {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  return cjnum_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_cjnum() {
  clear_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjnum_;
    cjnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjPrice = 10;
inline bool INF_QueryBatchEntrust_Ack::has_cjprice() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_cjprice() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_cjprice() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryBatchEntrust_Ack::clear_cjprice() {
  if (cjprice_ != &::google::protobuf::internal::kEmptyString) {
    cjprice_->clear();
  }
  clear_has_cjprice();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::cjprice() const {
  return *cjprice_;
}
inline void INF_QueryBatchEntrust_Ack::set_cjprice(const ::std::string& value) {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  cjprice_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_cjprice(const char* value) {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  cjprice_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_cjprice(const char* value, size_t size) {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  cjprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_cjprice() {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  return cjprice_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_cjprice() {
  clear_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjprice_;
    cjprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustTime = 11;
inline bool INF_QueryBatchEntrust_Ack::has_entrusttime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_entrusttime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_entrusttime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryBatchEntrust_Ack::clear_entrusttime() {
  if (entrusttime_ != &::google::protobuf::internal::kEmptyString) {
    entrusttime_->clear();
  }
  clear_has_entrusttime();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::entrusttime() const {
  return *entrusttime_;
}
inline void INF_QueryBatchEntrust_Ack::set_entrusttime(const ::std::string& value) {
  set_has_entrusttime();
  if (entrusttime_ == &::google::protobuf::internal::kEmptyString) {
    entrusttime_ = new ::std::string;
  }
  entrusttime_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrusttime(const char* value) {
  set_has_entrusttime();
  if (entrusttime_ == &::google::protobuf::internal::kEmptyString) {
    entrusttime_ = new ::std::string;
  }
  entrusttime_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrusttime(const char* value, size_t size) {
  set_has_entrusttime();
  if (entrusttime_ == &::google::protobuf::internal::kEmptyString) {
    entrusttime_ = new ::std::string;
  }
  entrusttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_entrusttime() {
  set_has_entrusttime();
  if (entrusttime_ == &::google::protobuf::internal::kEmptyString) {
    entrusttime_ = new ::std::string;
  }
  return entrusttime_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_entrusttime() {
  clear_has_entrusttime();
  if (entrusttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttime_;
    entrusttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Valid = 12;
inline bool INF_QueryBatchEntrust_Ack::has_valid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_valid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_valid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryBatchEntrust_Ack::clear_valid() {
  if (valid_ != &::google::protobuf::internal::kEmptyString) {
    valid_->clear();
  }
  clear_has_valid();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::valid() const {
  return *valid_;
}
inline void INF_QueryBatchEntrust_Ack::set_valid(const ::std::string& value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_valid(const char* value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_valid(const char* value, size_t size) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_valid() {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  return valid_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_valid() {
  clear_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_;
    valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 13;
inline bool INF_QueryBatchEntrust_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::respflag() const {
  return *respflag_;
}
inline void INF_QueryBatchEntrust_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsSuccess = 14;
inline bool INF_QueryBatchEntrust_Ack::has_issuccess() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_issuccess() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_issuccess() {
  if (issuccess_ != &::google::protobuf::internal::kEmptyString) {
    issuccess_->clear();
  }
  clear_has_issuccess();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::issuccess() const {
  return *issuccess_;
}
inline void INF_QueryBatchEntrust_Ack::set_issuccess(const ::std::string& value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_issuccess(const char* value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_issuccess(const char* value, size_t size) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_issuccess() {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  return issuccess_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_issuccess() {
  clear_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issuccess_;
    issuccess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RecordNum = 15;
inline bool INF_QueryBatchEntrust_Ack::has_recordnum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_recordnum() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_recordnum() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_recordnum() {
  if (recordnum_ != &::google::protobuf::internal::kEmptyString) {
    recordnum_->clear();
  }
  clear_has_recordnum();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::recordnum() const {
  return *recordnum_;
}
inline void INF_QueryBatchEntrust_Ack::set_recordnum(const ::std::string& value) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_recordnum(const char* value) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_recordnum(const char* value, size_t size) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_recordnum() {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  return recordnum_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_recordnum() {
  clear_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recordnum_;
    recordnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CurrentDate = 16;
inline bool INF_QueryBatchEntrust_Ack::has_currentdate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_currentdate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_currentdate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_currentdate() {
  if (currentdate_ != &::google::protobuf::internal::kEmptyString) {
    currentdate_->clear();
  }
  clear_has_currentdate();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::currentdate() const {
  return *currentdate_;
}
inline void INF_QueryBatchEntrust_Ack::set_currentdate(const ::std::string& value) {
  set_has_currentdate();
  if (currentdate_ == &::google::protobuf::internal::kEmptyString) {
    currentdate_ = new ::std::string;
  }
  currentdate_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_currentdate(const char* value) {
  set_has_currentdate();
  if (currentdate_ == &::google::protobuf::internal::kEmptyString) {
    currentdate_ = new ::std::string;
  }
  currentdate_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_currentdate(const char* value, size_t size) {
  set_has_currentdate();
  if (currentdate_ == &::google::protobuf::internal::kEmptyString) {
    currentdate_ = new ::std::string;
  }
  currentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_currentdate() {
  set_has_currentdate();
  if (currentdate_ == &::google::protobuf::internal::kEmptyString) {
    currentdate_ = new ::std::string;
  }
  return currentdate_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_currentdate() {
  clear_has_currentdate();
  if (currentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentdate_;
    currentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustNo = 17;
inline bool INF_QueryBatchEntrust_Ack::has_entrustno() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_entrustno() {
  _has_bits_[0] |= 0x00010000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_entrustno() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_entrustno() {
  if (entrustno_ != &::google::protobuf::internal::kEmptyString) {
    entrustno_->clear();
  }
  clear_has_entrustno();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::entrustno() const {
  return *entrustno_;
}
inline void INF_QueryBatchEntrust_Ack::set_entrustno(const ::std::string& value) {
  set_has_entrustno();
  if (entrustno_ == &::google::protobuf::internal::kEmptyString) {
    entrustno_ = new ::std::string;
  }
  entrustno_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustno(const char* value) {
  set_has_entrustno();
  if (entrustno_ == &::google::protobuf::internal::kEmptyString) {
    entrustno_ = new ::std::string;
  }
  entrustno_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustno(const char* value, size_t size) {
  set_has_entrustno();
  if (entrustno_ == &::google::protobuf::internal::kEmptyString) {
    entrustno_ = new ::std::string;
  }
  entrustno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_entrustno() {
  set_has_entrustno();
  if (entrustno_ == &::google::protobuf::internal::kEmptyString) {
    entrustno_ = new ::std::string;
  }
  return entrustno_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_entrustno() {
  clear_has_entrustno();
  if (entrustno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustno_;
    entrustno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DeclareNo = 18;
inline bool INF_QueryBatchEntrust_Ack::has_declareno() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_declareno() {
  _has_bits_[0] |= 0x00020000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_declareno() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_declareno() {
  if (declareno_ != &::google::protobuf::internal::kEmptyString) {
    declareno_->clear();
  }
  clear_has_declareno();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::declareno() const {
  return *declareno_;
}
inline void INF_QueryBatchEntrust_Ack::set_declareno(const ::std::string& value) {
  set_has_declareno();
  if (declareno_ == &::google::protobuf::internal::kEmptyString) {
    declareno_ = new ::std::string;
  }
  declareno_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_declareno(const char* value) {
  set_has_declareno();
  if (declareno_ == &::google::protobuf::internal::kEmptyString) {
    declareno_ = new ::std::string;
  }
  declareno_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_declareno(const char* value, size_t size) {
  set_has_declareno();
  if (declareno_ == &::google::protobuf::internal::kEmptyString) {
    declareno_ = new ::std::string;
  }
  declareno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_declareno() {
  set_has_declareno();
  if (declareno_ == &::google::protobuf::internal::kEmptyString) {
    declareno_ = new ::std::string;
  }
  return declareno_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_declareno() {
  clear_has_declareno();
  if (declareno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = declareno_;
    declareno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ClientNo = 19;
inline bool INF_QueryBatchEntrust_Ack::has_clientno() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_clientno() {
  _has_bits_[0] |= 0x00040000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_clientno() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_clientno() {
  if (clientno_ != &::google::protobuf::internal::kEmptyString) {
    clientno_->clear();
  }
  clear_has_clientno();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::clientno() const {
  return *clientno_;
}
inline void INF_QueryBatchEntrust_Ack::set_clientno(const ::std::string& value) {
  set_has_clientno();
  if (clientno_ == &::google::protobuf::internal::kEmptyString) {
    clientno_ = new ::std::string;
  }
  clientno_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_clientno(const char* value) {
  set_has_clientno();
  if (clientno_ == &::google::protobuf::internal::kEmptyString) {
    clientno_ = new ::std::string;
  }
  clientno_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_clientno(const char* value, size_t size) {
  set_has_clientno();
  if (clientno_ == &::google::protobuf::internal::kEmptyString) {
    clientno_ = new ::std::string;
  }
  clientno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_clientno() {
  set_has_clientno();
  if (clientno_ == &::google::protobuf::internal::kEmptyString) {
    clientno_ = new ::std::string;
  }
  return clientno_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_clientno() {
  clear_has_clientno();
  if (clientno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientno_;
    clientno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string StockholderAccount = 20;
inline bool INF_QueryBatchEntrust_Ack::has_stockholderaccount() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_stockholderaccount() {
  _has_bits_[0] |= 0x00080000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_stockholderaccount() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_stockholderaccount() {
  if (stockholderaccount_ != &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_->clear();
  }
  clear_has_stockholderaccount();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::stockholderaccount() const {
  return *stockholderaccount_;
}
inline void INF_QueryBatchEntrust_Ack::set_stockholderaccount(const ::std::string& value) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_stockholderaccount(const char* value) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_stockholderaccount(const char* value, size_t size) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_stockholderaccount() {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  return stockholderaccount_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_stockholderaccount() {
  clear_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stockholderaccount_;
    stockholderaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityName = 21;
inline bool INF_QueryBatchEntrust_Ack::has_securityname() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_securityname() {
  _has_bits_[0] |= 0x00100000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_securityname() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_securityname() {
  if (securityname_ != &::google::protobuf::internal::kEmptyString) {
    securityname_->clear();
  }
  clear_has_securityname();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::securityname() const {
  return *securityname_;
}
inline void INF_QueryBatchEntrust_Ack::set_securityname(const ::std::string& value) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_securityname(const char* value) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_securityname(const char* value, size_t size) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_securityname() {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  return securityname_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_securityname() {
  clear_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securityname_;
    securityname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 22;
inline bool INF_QueryBatchEntrust_Ack::has_entrusttype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_entrusttype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryBatchEntrust_Ack::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BSflagName = 23;
inline bool INF_QueryBatchEntrust_Ack::has_bsflagname() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_bsflagname() {
  _has_bits_[0] |= 0x00400000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_bsflagname() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_bsflagname() {
  if (bsflagname_ != &::google::protobuf::internal::kEmptyString) {
    bsflagname_->clear();
  }
  clear_has_bsflagname();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::bsflagname() const {
  return *bsflagname_;
}
inline void INF_QueryBatchEntrust_Ack::set_bsflagname(const ::std::string& value) {
  set_has_bsflagname();
  if (bsflagname_ == &::google::protobuf::internal::kEmptyString) {
    bsflagname_ = new ::std::string;
  }
  bsflagname_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_bsflagname(const char* value) {
  set_has_bsflagname();
  if (bsflagname_ == &::google::protobuf::internal::kEmptyString) {
    bsflagname_ = new ::std::string;
  }
  bsflagname_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_bsflagname(const char* value, size_t size) {
  set_has_bsflagname();
  if (bsflagname_ == &::google::protobuf::internal::kEmptyString) {
    bsflagname_ = new ::std::string;
  }
  bsflagname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_bsflagname() {
  set_has_bsflagname();
  if (bsflagname_ == &::google::protobuf::internal::kEmptyString) {
    bsflagname_ = new ::std::string;
  }
  return bsflagname_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_bsflagname() {
  clear_has_bsflagname();
  if (bsflagname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bsflagname_;
    bsflagname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjStatus = 24;
inline bool INF_QueryBatchEntrust_Ack::has_cjstatus() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_cjstatus() {
  _has_bits_[0] |= 0x00800000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_cjstatus() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_cjstatus() {
  if (cjstatus_ != &::google::protobuf::internal::kEmptyString) {
    cjstatus_->clear();
  }
  clear_has_cjstatus();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::cjstatus() const {
  return *cjstatus_;
}
inline void INF_QueryBatchEntrust_Ack::set_cjstatus(const ::std::string& value) {
  set_has_cjstatus();
  if (cjstatus_ == &::google::protobuf::internal::kEmptyString) {
    cjstatus_ = new ::std::string;
  }
  cjstatus_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_cjstatus(const char* value) {
  set_has_cjstatus();
  if (cjstatus_ == &::google::protobuf::internal::kEmptyString) {
    cjstatus_ = new ::std::string;
  }
  cjstatus_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_cjstatus(const char* value, size_t size) {
  set_has_cjstatus();
  if (cjstatus_ == &::google::protobuf::internal::kEmptyString) {
    cjstatus_ = new ::std::string;
  }
  cjstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_cjstatus() {
  set_has_cjstatus();
  if (cjstatus_ == &::google::protobuf::internal::kEmptyString) {
    cjstatus_ = new ::std::string;
  }
  return cjstatus_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_cjstatus() {
  clear_has_cjstatus();
  if (cjstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjstatus_;
    cjstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjStatusName = 25;
inline bool INF_QueryBatchEntrust_Ack::has_cjstatusname() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_cjstatusname() {
  _has_bits_[0] |= 0x01000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_cjstatusname() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_cjstatusname() {
  if (cjstatusname_ != &::google::protobuf::internal::kEmptyString) {
    cjstatusname_->clear();
  }
  clear_has_cjstatusname();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::cjstatusname() const {
  return *cjstatusname_;
}
inline void INF_QueryBatchEntrust_Ack::set_cjstatusname(const ::std::string& value) {
  set_has_cjstatusname();
  if (cjstatusname_ == &::google::protobuf::internal::kEmptyString) {
    cjstatusname_ = new ::std::string;
  }
  cjstatusname_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_cjstatusname(const char* value) {
  set_has_cjstatusname();
  if (cjstatusname_ == &::google::protobuf::internal::kEmptyString) {
    cjstatusname_ = new ::std::string;
  }
  cjstatusname_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_cjstatusname(const char* value, size_t size) {
  set_has_cjstatusname();
  if (cjstatusname_ == &::google::protobuf::internal::kEmptyString) {
    cjstatusname_ = new ::std::string;
  }
  cjstatusname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_cjstatusname() {
  set_has_cjstatusname();
  if (cjstatusname_ == &::google::protobuf::internal::kEmptyString) {
    cjstatusname_ = new ::std::string;
  }
  return cjstatusname_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_cjstatusname() {
  clear_has_cjstatusname();
  if (cjstatusname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjstatusname_;
    cjstatusname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjDate = 26;
inline bool INF_QueryBatchEntrust_Ack::has_cjdate() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_cjdate() {
  _has_bits_[0] |= 0x02000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_cjdate() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_cjdate() {
  if (cjdate_ != &::google::protobuf::internal::kEmptyString) {
    cjdate_->clear();
  }
  clear_has_cjdate();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::cjdate() const {
  return *cjdate_;
}
inline void INF_QueryBatchEntrust_Ack::set_cjdate(const ::std::string& value) {
  set_has_cjdate();
  if (cjdate_ == &::google::protobuf::internal::kEmptyString) {
    cjdate_ = new ::std::string;
  }
  cjdate_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_cjdate(const char* value) {
  set_has_cjdate();
  if (cjdate_ == &::google::protobuf::internal::kEmptyString) {
    cjdate_ = new ::std::string;
  }
  cjdate_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_cjdate(const char* value, size_t size) {
  set_has_cjdate();
  if (cjdate_ == &::google::protobuf::internal::kEmptyString) {
    cjdate_ = new ::std::string;
  }
  cjdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_cjdate() {
  set_has_cjdate();
  if (cjdate_ == &::google::protobuf::internal::kEmptyString) {
    cjdate_ = new ::std::string;
  }
  return cjdate_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_cjdate() {
  clear_has_cjdate();
  if (cjdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjdate_;
    cjdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DeclareTime = 27;
inline bool INF_QueryBatchEntrust_Ack::has_declaretime() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_declaretime() {
  _has_bits_[0] |= 0x04000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_declaretime() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_declaretime() {
  if (declaretime_ != &::google::protobuf::internal::kEmptyString) {
    declaretime_->clear();
  }
  clear_has_declaretime();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::declaretime() const {
  return *declaretime_;
}
inline void INF_QueryBatchEntrust_Ack::set_declaretime(const ::std::string& value) {
  set_has_declaretime();
  if (declaretime_ == &::google::protobuf::internal::kEmptyString) {
    declaretime_ = new ::std::string;
  }
  declaretime_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_declaretime(const char* value) {
  set_has_declaretime();
  if (declaretime_ == &::google::protobuf::internal::kEmptyString) {
    declaretime_ = new ::std::string;
  }
  declaretime_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_declaretime(const char* value, size_t size) {
  set_has_declaretime();
  if (declaretime_ == &::google::protobuf::internal::kEmptyString) {
    declaretime_ = new ::std::string;
  }
  declaretime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_declaretime() {
  set_has_declaretime();
  if (declaretime_ == &::google::protobuf::internal::kEmptyString) {
    declaretime_ = new ::std::string;
  }
  return declaretime_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_declaretime() {
  clear_has_declaretime();
  if (declaretime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = declaretime_;
    declaretime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustPenNum = 28;
inline bool INF_QueryBatchEntrust_Ack::has_entrustpennum() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_entrustpennum() {
  _has_bits_[0] |= 0x08000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_entrustpennum() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_entrustpennum() {
  if (entrustpennum_ != &::google::protobuf::internal::kEmptyString) {
    entrustpennum_->clear();
  }
  clear_has_entrustpennum();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::entrustpennum() const {
  return *entrustpennum_;
}
inline void INF_QueryBatchEntrust_Ack::set_entrustpennum(const ::std::string& value) {
  set_has_entrustpennum();
  if (entrustpennum_ == &::google::protobuf::internal::kEmptyString) {
    entrustpennum_ = new ::std::string;
  }
  entrustpennum_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustpennum(const char* value) {
  set_has_entrustpennum();
  if (entrustpennum_ == &::google::protobuf::internal::kEmptyString) {
    entrustpennum_ = new ::std::string;
  }
  entrustpennum_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_entrustpennum(const char* value, size_t size) {
  set_has_entrustpennum();
  if (entrustpennum_ == &::google::protobuf::internal::kEmptyString) {
    entrustpennum_ = new ::std::string;
  }
  entrustpennum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_entrustpennum() {
  set_has_entrustpennum();
  if (entrustpennum_ == &::google::protobuf::internal::kEmptyString) {
    entrustpennum_ = new ::std::string;
  }
  return entrustpennum_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_entrustpennum() {
  clear_has_entrustpennum();
  if (entrustpennum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustpennum_;
    entrustpennum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PageStartPos = 29;
inline bool INF_QueryBatchEntrust_Ack::has_pagestartpos() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_pagestartpos() {
  _has_bits_[0] |= 0x10000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_pagestartpos() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_pagestartpos() {
  if (pagestartpos_ != &::google::protobuf::internal::kEmptyString) {
    pagestartpos_->clear();
  }
  clear_has_pagestartpos();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::pagestartpos() const {
  return *pagestartpos_;
}
inline void INF_QueryBatchEntrust_Ack::set_pagestartpos(const ::std::string& value) {
  set_has_pagestartpos();
  if (pagestartpos_ == &::google::protobuf::internal::kEmptyString) {
    pagestartpos_ = new ::std::string;
  }
  pagestartpos_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_pagestartpos(const char* value) {
  set_has_pagestartpos();
  if (pagestartpos_ == &::google::protobuf::internal::kEmptyString) {
    pagestartpos_ = new ::std::string;
  }
  pagestartpos_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_pagestartpos(const char* value, size_t size) {
  set_has_pagestartpos();
  if (pagestartpos_ == &::google::protobuf::internal::kEmptyString) {
    pagestartpos_ = new ::std::string;
  }
  pagestartpos_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_pagestartpos() {
  set_has_pagestartpos();
  if (pagestartpos_ == &::google::protobuf::internal::kEmptyString) {
    pagestartpos_ = new ::std::string;
  }
  return pagestartpos_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_pagestartpos() {
  clear_has_pagestartpos();
  if (pagestartpos_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pagestartpos_;
    pagestartpos_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string HaveCancelNum = 30;
inline bool INF_QueryBatchEntrust_Ack::has_havecancelnum() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void INF_QueryBatchEntrust_Ack::set_has_havecancelnum() {
  _has_bits_[0] |= 0x20000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_has_havecancelnum() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void INF_QueryBatchEntrust_Ack::clear_havecancelnum() {
  if (havecancelnum_ != &::google::protobuf::internal::kEmptyString) {
    havecancelnum_->clear();
  }
  clear_has_havecancelnum();
}
inline const ::std::string& INF_QueryBatchEntrust_Ack::havecancelnum() const {
  return *havecancelnum_;
}
inline void INF_QueryBatchEntrust_Ack::set_havecancelnum(const ::std::string& value) {
  set_has_havecancelnum();
  if (havecancelnum_ == &::google::protobuf::internal::kEmptyString) {
    havecancelnum_ = new ::std::string;
  }
  havecancelnum_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_havecancelnum(const char* value) {
  set_has_havecancelnum();
  if (havecancelnum_ == &::google::protobuf::internal::kEmptyString) {
    havecancelnum_ = new ::std::string;
  }
  havecancelnum_->assign(value);
}
inline void INF_QueryBatchEntrust_Ack::set_havecancelnum(const char* value, size_t size) {
  set_has_havecancelnum();
  if (havecancelnum_ == &::google::protobuf::internal::kEmptyString) {
    havecancelnum_ = new ::std::string;
  }
  havecancelnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryBatchEntrust_Ack::mutable_havecancelnum() {
  set_has_havecancelnum();
  if (havecancelnum_ == &::google::protobuf::internal::kEmptyString) {
    havecancelnum_ = new ::std::string;
  }
  return havecancelnum_;
}
inline ::std::string* INF_QueryBatchEntrust_Ack::release_havecancelnum() {
  clear_has_havecancelnum();
  if (havecancelnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = havecancelnum_;
    havecancelnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_OneCancel_Ack

// optional string Valid = 1;
inline bool INF_OneCancel_Ack::has_valid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_OneCancel_Ack::set_has_valid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_OneCancel_Ack::clear_has_valid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_OneCancel_Ack::clear_valid() {
  if (valid_ != &::google::protobuf::internal::kEmptyString) {
    valid_->clear();
  }
  clear_has_valid();
}
inline const ::std::string& INF_OneCancel_Ack::valid() const {
  return *valid_;
}
inline void INF_OneCancel_Ack::set_valid(const ::std::string& value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_OneCancel_Ack::set_valid(const char* value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_OneCancel_Ack::set_valid(const char* value, size_t size) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Ack::mutable_valid() {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  return valid_;
}
inline ::std::string* INF_OneCancel_Ack::release_valid() {
  clear_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_;
    valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 2;
inline bool INF_OneCancel_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_OneCancel_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_OneCancel_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_OneCancel_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_OneCancel_Ack::respflag() const {
  return *respflag_;
}
inline void INF_OneCancel_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_OneCancel_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_OneCancel_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_OneCancel_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsSuccess = 3;
inline bool INF_OneCancel_Ack::has_issuccess() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_OneCancel_Ack::set_has_issuccess() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_OneCancel_Ack::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_OneCancel_Ack::clear_issuccess() {
  if (issuccess_ != &::google::protobuf::internal::kEmptyString) {
    issuccess_->clear();
  }
  clear_has_issuccess();
}
inline const ::std::string& INF_OneCancel_Ack::issuccess() const {
  return *issuccess_;
}
inline void INF_OneCancel_Ack::set_issuccess(const ::std::string& value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_OneCancel_Ack::set_issuccess(const char* value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_OneCancel_Ack::set_issuccess(const char* value, size_t size) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_OneCancel_Ack::mutable_issuccess() {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  return issuccess_;
}
inline ::std::string* INF_OneCancel_Ack::release_issuccess() {
  clear_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issuccess_;
    issuccess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_BatchCancel_Ack

// optional string Valid = 1;
inline bool INF_BatchCancel_Ack::has_valid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_BatchCancel_Ack::set_has_valid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_BatchCancel_Ack::clear_has_valid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_BatchCancel_Ack::clear_valid() {
  if (valid_ != &::google::protobuf::internal::kEmptyString) {
    valid_->clear();
  }
  clear_has_valid();
}
inline const ::std::string& INF_BatchCancel_Ack::valid() const {
  return *valid_;
}
inline void INF_BatchCancel_Ack::set_valid(const ::std::string& value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_BatchCancel_Ack::set_valid(const char* value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_BatchCancel_Ack::set_valid(const char* value, size_t size) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Ack::mutable_valid() {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  return valid_;
}
inline ::std::string* INF_BatchCancel_Ack::release_valid() {
  clear_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_;
    valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 2;
inline bool INF_BatchCancel_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_BatchCancel_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_BatchCancel_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_BatchCancel_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_BatchCancel_Ack::respflag() const {
  return *respflag_;
}
inline void INF_BatchCancel_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_BatchCancel_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_BatchCancel_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_BatchCancel_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsSuccess = 3;
inline bool INF_BatchCancel_Ack::has_issuccess() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_BatchCancel_Ack::set_has_issuccess() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_BatchCancel_Ack::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_BatchCancel_Ack::clear_issuccess() {
  if (issuccess_ != &::google::protobuf::internal::kEmptyString) {
    issuccess_->clear();
  }
  clear_has_issuccess();
}
inline const ::std::string& INF_BatchCancel_Ack::issuccess() const {
  return *issuccess_;
}
inline void INF_BatchCancel_Ack::set_issuccess(const ::std::string& value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_BatchCancel_Ack::set_issuccess(const char* value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_BatchCancel_Ack::set_issuccess(const char* value, size_t size) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Ack::mutable_issuccess() {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  return issuccess_;
}
inline ::std::string* INF_BatchCancel_Ack::release_issuccess() {
  clear_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issuccess_;
    issuccess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CancelPenNum = 4;
inline bool INF_BatchCancel_Ack::has_cancelpennum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_BatchCancel_Ack::set_has_cancelpennum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_BatchCancel_Ack::clear_has_cancelpennum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_BatchCancel_Ack::clear_cancelpennum() {
  if (cancelpennum_ != &::google::protobuf::internal::kEmptyString) {
    cancelpennum_->clear();
  }
  clear_has_cancelpennum();
}
inline const ::std::string& INF_BatchCancel_Ack::cancelpennum() const {
  return *cancelpennum_;
}
inline void INF_BatchCancel_Ack::set_cancelpennum(const ::std::string& value) {
  set_has_cancelpennum();
  if (cancelpennum_ == &::google::protobuf::internal::kEmptyString) {
    cancelpennum_ = new ::std::string;
  }
  cancelpennum_->assign(value);
}
inline void INF_BatchCancel_Ack::set_cancelpennum(const char* value) {
  set_has_cancelpennum();
  if (cancelpennum_ == &::google::protobuf::internal::kEmptyString) {
    cancelpennum_ = new ::std::string;
  }
  cancelpennum_->assign(value);
}
inline void INF_BatchCancel_Ack::set_cancelpennum(const char* value, size_t size) {
  set_has_cancelpennum();
  if (cancelpennum_ == &::google::protobuf::internal::kEmptyString) {
    cancelpennum_ = new ::std::string;
  }
  cancelpennum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Ack::mutable_cancelpennum() {
  set_has_cancelpennum();
  if (cancelpennum_ == &::google::protobuf::internal::kEmptyString) {
    cancelpennum_ = new ::std::string;
  }
  return cancelpennum_;
}
inline ::std::string* INF_BatchCancel_Ack::release_cancelpennum() {
  clear_has_cancelpennum();
  if (cancelpennum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cancelpennum_;
    cancelpennum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CancelNum = 5;
inline bool INF_BatchCancel_Ack::has_cancelnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_BatchCancel_Ack::set_has_cancelnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_BatchCancel_Ack::clear_has_cancelnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_BatchCancel_Ack::clear_cancelnum() {
  if (cancelnum_ != &::google::protobuf::internal::kEmptyString) {
    cancelnum_->clear();
  }
  clear_has_cancelnum();
}
inline const ::std::string& INF_BatchCancel_Ack::cancelnum() const {
  return *cancelnum_;
}
inline void INF_BatchCancel_Ack::set_cancelnum(const ::std::string& value) {
  set_has_cancelnum();
  if (cancelnum_ == &::google::protobuf::internal::kEmptyString) {
    cancelnum_ = new ::std::string;
  }
  cancelnum_->assign(value);
}
inline void INF_BatchCancel_Ack::set_cancelnum(const char* value) {
  set_has_cancelnum();
  if (cancelnum_ == &::google::protobuf::internal::kEmptyString) {
    cancelnum_ = new ::std::string;
  }
  cancelnum_->assign(value);
}
inline void INF_BatchCancel_Ack::set_cancelnum(const char* value, size_t size) {
  set_has_cancelnum();
  if (cancelnum_ == &::google::protobuf::internal::kEmptyString) {
    cancelnum_ = new ::std::string;
  }
  cancelnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_BatchCancel_Ack::mutable_cancelnum() {
  set_has_cancelnum();
  if (cancelnum_ == &::google::protobuf::internal::kEmptyString) {
    cancelnum_ = new ::std::string;
  }
  return cancelnum_;
}
inline ::std::string* INF_BatchCancel_Ack::release_cancelnum() {
  clear_has_cancelnum();
  if (cancelnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cancelnum_;
    cancelnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryETFbaseInfo_Ack

// optional string ETFName = 1;
inline bool INF_QueryETFbaseInfo_Ack::has_etfname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_etfname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_etfname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_etfname() {
  if (etfname_ != &::google::protobuf::internal::kEmptyString) {
    etfname_->clear();
  }
  clear_has_etfname();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::etfname() const {
  return *etfname_;
}
inline void INF_QueryETFbaseInfo_Ack::set_etfname(const ::std::string& value) {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  etfname_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_etfname(const char* value) {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  etfname_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_etfname(const char* value, size_t size) {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  etfname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_etfname() {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  return etfname_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_etfname() {
  clear_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfname_;
    etfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OneMarketCode = 2;
inline bool INF_QueryETFbaseInfo_Ack::has_onemarketcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_onemarketcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_onemarketcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_onemarketcode() {
  if (onemarketcode_ != &::google::protobuf::internal::kEmptyString) {
    onemarketcode_->clear();
  }
  clear_has_onemarketcode();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::onemarketcode() const {
  return *onemarketcode_;
}
inline void INF_QueryETFbaseInfo_Ack::set_onemarketcode(const ::std::string& value) {
  set_has_onemarketcode();
  if (onemarketcode_ == &::google::protobuf::internal::kEmptyString) {
    onemarketcode_ = new ::std::string;
  }
  onemarketcode_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_onemarketcode(const char* value) {
  set_has_onemarketcode();
  if (onemarketcode_ == &::google::protobuf::internal::kEmptyString) {
    onemarketcode_ = new ::std::string;
  }
  onemarketcode_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_onemarketcode(const char* value, size_t size) {
  set_has_onemarketcode();
  if (onemarketcode_ == &::google::protobuf::internal::kEmptyString) {
    onemarketcode_ = new ::std::string;
  }
  onemarketcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_onemarketcode() {
  set_has_onemarketcode();
  if (onemarketcode_ == &::google::protobuf::internal::kEmptyString) {
    onemarketcode_ = new ::std::string;
  }
  return onemarketcode_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_onemarketcode() {
  clear_has_onemarketcode();
  if (onemarketcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onemarketcode_;
    onemarketcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string TwoMarketCode = 3;
inline bool INF_QueryETFbaseInfo_Ack::has_twomarketcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_twomarketcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_twomarketcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_twomarketcode() {
  if (twomarketcode_ != &::google::protobuf::internal::kEmptyString) {
    twomarketcode_->clear();
  }
  clear_has_twomarketcode();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::twomarketcode() const {
  return *twomarketcode_;
}
inline void INF_QueryETFbaseInfo_Ack::set_twomarketcode(const ::std::string& value) {
  set_has_twomarketcode();
  if (twomarketcode_ == &::google::protobuf::internal::kEmptyString) {
    twomarketcode_ = new ::std::string;
  }
  twomarketcode_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_twomarketcode(const char* value) {
  set_has_twomarketcode();
  if (twomarketcode_ == &::google::protobuf::internal::kEmptyString) {
    twomarketcode_ = new ::std::string;
  }
  twomarketcode_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_twomarketcode(const char* value, size_t size) {
  set_has_twomarketcode();
  if (twomarketcode_ == &::google::protobuf::internal::kEmptyString) {
    twomarketcode_ = new ::std::string;
  }
  twomarketcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_twomarketcode() {
  set_has_twomarketcode();
  if (twomarketcode_ == &::google::protobuf::internal::kEmptyString) {
    twomarketcode_ = new ::std::string;
  }
  return twomarketcode_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_twomarketcode() {
  clear_has_twomarketcode();
  if (twomarketcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = twomarketcode_;
    twomarketcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFminPurRedemUnit = 4;
inline bool INF_QueryETFbaseInfo_Ack::has_etfminpurredemunit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_etfminpurredemunit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_etfminpurredemunit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_etfminpurredemunit() {
  if (etfminpurredemunit_ != &::google::protobuf::internal::kEmptyString) {
    etfminpurredemunit_->clear();
  }
  clear_has_etfminpurredemunit();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::etfminpurredemunit() const {
  return *etfminpurredemunit_;
}
inline void INF_QueryETFbaseInfo_Ack::set_etfminpurredemunit(const ::std::string& value) {
  set_has_etfminpurredemunit();
  if (etfminpurredemunit_ == &::google::protobuf::internal::kEmptyString) {
    etfminpurredemunit_ = new ::std::string;
  }
  etfminpurredemunit_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_etfminpurredemunit(const char* value) {
  set_has_etfminpurredemunit();
  if (etfminpurredemunit_ == &::google::protobuf::internal::kEmptyString) {
    etfminpurredemunit_ = new ::std::string;
  }
  etfminpurredemunit_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_etfminpurredemunit(const char* value, size_t size) {
  set_has_etfminpurredemunit();
  if (etfminpurredemunit_ == &::google::protobuf::internal::kEmptyString) {
    etfminpurredemunit_ = new ::std::string;
  }
  etfminpurredemunit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_etfminpurredemunit() {
  set_has_etfminpurredemunit();
  if (etfminpurredemunit_ == &::google::protobuf::internal::kEmptyString) {
    etfminpurredemunit_ = new ::std::string;
  }
  return etfminpurredemunit_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_etfminpurredemunit() {
  clear_has_etfminpurredemunit();
  if (etfminpurredemunit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfminpurredemunit_;
    etfminpurredemunit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CashDiffer = 5;
inline bool INF_QueryETFbaseInfo_Ack::has_cashdiffer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_cashdiffer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_cashdiffer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_cashdiffer() {
  if (cashdiffer_ != &::google::protobuf::internal::kEmptyString) {
    cashdiffer_->clear();
  }
  clear_has_cashdiffer();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::cashdiffer() const {
  return *cashdiffer_;
}
inline void INF_QueryETFbaseInfo_Ack::set_cashdiffer(const ::std::string& value) {
  set_has_cashdiffer();
  if (cashdiffer_ == &::google::protobuf::internal::kEmptyString) {
    cashdiffer_ = new ::std::string;
  }
  cashdiffer_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_cashdiffer(const char* value) {
  set_has_cashdiffer();
  if (cashdiffer_ == &::google::protobuf::internal::kEmptyString) {
    cashdiffer_ = new ::std::string;
  }
  cashdiffer_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_cashdiffer(const char* value, size_t size) {
  set_has_cashdiffer();
  if (cashdiffer_ == &::google::protobuf::internal::kEmptyString) {
    cashdiffer_ = new ::std::string;
  }
  cashdiffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_cashdiffer() {
  set_has_cashdiffer();
  if (cashdiffer_ == &::google::protobuf::internal::kEmptyString) {
    cashdiffer_ = new ::std::string;
  }
  return cashdiffer_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_cashdiffer() {
  clear_has_cashdiffer();
  if (cashdiffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cashdiffer_;
    cashdiffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CastReplaceRatio = 6;
inline bool INF_QueryETFbaseInfo_Ack::has_castreplaceratio() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_castreplaceratio() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_castreplaceratio() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_castreplaceratio() {
  if (castreplaceratio_ != &::google::protobuf::internal::kEmptyString) {
    castreplaceratio_->clear();
  }
  clear_has_castreplaceratio();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::castreplaceratio() const {
  return *castreplaceratio_;
}
inline void INF_QueryETFbaseInfo_Ack::set_castreplaceratio(const ::std::string& value) {
  set_has_castreplaceratio();
  if (castreplaceratio_ == &::google::protobuf::internal::kEmptyString) {
    castreplaceratio_ = new ::std::string;
  }
  castreplaceratio_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_castreplaceratio(const char* value) {
  set_has_castreplaceratio();
  if (castreplaceratio_ == &::google::protobuf::internal::kEmptyString) {
    castreplaceratio_ = new ::std::string;
  }
  castreplaceratio_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_castreplaceratio(const char* value, size_t size) {
  set_has_castreplaceratio();
  if (castreplaceratio_ == &::google::protobuf::internal::kEmptyString) {
    castreplaceratio_ = new ::std::string;
  }
  castreplaceratio_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_castreplaceratio() {
  set_has_castreplaceratio();
  if (castreplaceratio_ == &::google::protobuf::internal::kEmptyString) {
    castreplaceratio_ = new ::std::string;
  }
  return castreplaceratio_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_castreplaceratio() {
  clear_has_castreplaceratio();
  if (castreplaceratio_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = castreplaceratio_;
    castreplaceratio_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PurRedemStatus = 7;
inline bool INF_QueryETFbaseInfo_Ack::has_purredemstatus() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_purredemstatus() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_purredemstatus() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_purredemstatus() {
  if (purredemstatus_ != &::google::protobuf::internal::kEmptyString) {
    purredemstatus_->clear();
  }
  clear_has_purredemstatus();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::purredemstatus() const {
  return *purredemstatus_;
}
inline void INF_QueryETFbaseInfo_Ack::set_purredemstatus(const ::std::string& value) {
  set_has_purredemstatus();
  if (purredemstatus_ == &::google::protobuf::internal::kEmptyString) {
    purredemstatus_ = new ::std::string;
  }
  purredemstatus_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_purredemstatus(const char* value) {
  set_has_purredemstatus();
  if (purredemstatus_ == &::google::protobuf::internal::kEmptyString) {
    purredemstatus_ = new ::std::string;
  }
  purredemstatus_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_purredemstatus(const char* value, size_t size) {
  set_has_purredemstatus();
  if (purredemstatus_ == &::google::protobuf::internal::kEmptyString) {
    purredemstatus_ = new ::std::string;
  }
  purredemstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_purredemstatus() {
  set_has_purredemstatus();
  if (purredemstatus_ == &::google::protobuf::internal::kEmptyString) {
    purredemstatus_ = new ::std::string;
  }
  return purredemstatus_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_purredemstatus() {
  clear_has_purredemstatus();
  if (purredemstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = purredemstatus_;
    purredemstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EstimDiffer = 8;
inline bool INF_QueryETFbaseInfo_Ack::has_estimdiffer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_estimdiffer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_estimdiffer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_estimdiffer() {
  if (estimdiffer_ != &::google::protobuf::internal::kEmptyString) {
    estimdiffer_->clear();
  }
  clear_has_estimdiffer();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::estimdiffer() const {
  return *estimdiffer_;
}
inline void INF_QueryETFbaseInfo_Ack::set_estimdiffer(const ::std::string& value) {
  set_has_estimdiffer();
  if (estimdiffer_ == &::google::protobuf::internal::kEmptyString) {
    estimdiffer_ = new ::std::string;
  }
  estimdiffer_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_estimdiffer(const char* value) {
  set_has_estimdiffer();
  if (estimdiffer_ == &::google::protobuf::internal::kEmptyString) {
    estimdiffer_ = new ::std::string;
  }
  estimdiffer_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_estimdiffer(const char* value, size_t size) {
  set_has_estimdiffer();
  if (estimdiffer_ == &::google::protobuf::internal::kEmptyString) {
    estimdiffer_ = new ::std::string;
  }
  estimdiffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_estimdiffer() {
  set_has_estimdiffer();
  if (estimdiffer_ == &::google::protobuf::internal::kEmptyString) {
    estimdiffer_ = new ::std::string;
  }
  return estimdiffer_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_estimdiffer() {
  clear_has_estimdiffer();
  if (estimdiffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = estimdiffer_;
    estimdiffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string UnitNetValue = 9;
inline bool INF_QueryETFbaseInfo_Ack::has_unitnetvalue() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_unitnetvalue() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_unitnetvalue() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_unitnetvalue() {
  if (unitnetvalue_ != &::google::protobuf::internal::kEmptyString) {
    unitnetvalue_->clear();
  }
  clear_has_unitnetvalue();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::unitnetvalue() const {
  return *unitnetvalue_;
}
inline void INF_QueryETFbaseInfo_Ack::set_unitnetvalue(const ::std::string& value) {
  set_has_unitnetvalue();
  if (unitnetvalue_ == &::google::protobuf::internal::kEmptyString) {
    unitnetvalue_ = new ::std::string;
  }
  unitnetvalue_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_unitnetvalue(const char* value) {
  set_has_unitnetvalue();
  if (unitnetvalue_ == &::google::protobuf::internal::kEmptyString) {
    unitnetvalue_ = new ::std::string;
  }
  unitnetvalue_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_unitnetvalue(const char* value, size_t size) {
  set_has_unitnetvalue();
  if (unitnetvalue_ == &::google::protobuf::internal::kEmptyString) {
    unitnetvalue_ = new ::std::string;
  }
  unitnetvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_unitnetvalue() {
  set_has_unitnetvalue();
  if (unitnetvalue_ == &::google::protobuf::internal::kEmptyString) {
    unitnetvalue_ = new ::std::string;
  }
  return unitnetvalue_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_unitnetvalue() {
  clear_has_unitnetvalue();
  if (unitnetvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unitnetvalue_;
    unitnetvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string AllStocksNum = 10;
inline bool INF_QueryETFbaseInfo_Ack::has_allstocksnum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_allstocksnum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_allstocksnum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_allstocksnum() {
  if (allstocksnum_ != &::google::protobuf::internal::kEmptyString) {
    allstocksnum_->clear();
  }
  clear_has_allstocksnum();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::allstocksnum() const {
  return *allstocksnum_;
}
inline void INF_QueryETFbaseInfo_Ack::set_allstocksnum(const ::std::string& value) {
  set_has_allstocksnum();
  if (allstocksnum_ == &::google::protobuf::internal::kEmptyString) {
    allstocksnum_ = new ::std::string;
  }
  allstocksnum_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_allstocksnum(const char* value) {
  set_has_allstocksnum();
  if (allstocksnum_ == &::google::protobuf::internal::kEmptyString) {
    allstocksnum_ = new ::std::string;
  }
  allstocksnum_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_allstocksnum(const char* value, size_t size) {
  set_has_allstocksnum();
  if (allstocksnum_ == &::google::protobuf::internal::kEmptyString) {
    allstocksnum_ = new ::std::string;
  }
  allstocksnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_allstocksnum() {
  set_has_allstocksnum();
  if (allstocksnum_ == &::google::protobuf::internal::kEmptyString) {
    allstocksnum_ = new ::std::string;
  }
  return allstocksnum_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_allstocksnum() {
  clear_has_allstocksnum();
  if (allstocksnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = allstocksnum_;
    allstocksnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 11;
inline bool INF_QueryETFbaseInfo_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::respflag() const {
  return *respflag_;
}
inline void INF_QueryETFbaseInfo_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsSuccess = 12;
inline bool INF_QueryETFbaseInfo_Ack::has_issuccess() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_issuccess() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_issuccess() {
  if (issuccess_ != &::google::protobuf::internal::kEmptyString) {
    issuccess_->clear();
  }
  clear_has_issuccess();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::issuccess() const {
  return *issuccess_;
}
inline void INF_QueryETFbaseInfo_Ack::set_issuccess(const ::std::string& value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_issuccess(const char* value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_issuccess(const char* value, size_t size) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_issuccess() {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  return issuccess_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_issuccess() {
  clear_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issuccess_;
    issuccess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RecordNum = 13;
inline bool INF_QueryETFbaseInfo_Ack::has_recordnum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_recordnum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_recordnum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_recordnum() {
  if (recordnum_ != &::google::protobuf::internal::kEmptyString) {
    recordnum_->clear();
  }
  clear_has_recordnum();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::recordnum() const {
  return *recordnum_;
}
inline void INF_QueryETFbaseInfo_Ack::set_recordnum(const ::std::string& value) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_recordnum(const char* value) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_recordnum(const char* value, size_t size) {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  recordnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_recordnum() {
  set_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    recordnum_ = new ::std::string;
  }
  return recordnum_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_recordnum() {
  clear_has_recordnum();
  if (recordnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recordnum_;
    recordnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string subscriptCode = 14;
inline bool INF_QueryETFbaseInfo_Ack::has_subscriptcode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_subscriptcode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_subscriptcode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_subscriptcode() {
  if (subscriptcode_ != &::google::protobuf::internal::kEmptyString) {
    subscriptcode_->clear();
  }
  clear_has_subscriptcode();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::subscriptcode() const {
  return *subscriptcode_;
}
inline void INF_QueryETFbaseInfo_Ack::set_subscriptcode(const ::std::string& value) {
  set_has_subscriptcode();
  if (subscriptcode_ == &::google::protobuf::internal::kEmptyString) {
    subscriptcode_ = new ::std::string;
  }
  subscriptcode_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_subscriptcode(const char* value) {
  set_has_subscriptcode();
  if (subscriptcode_ == &::google::protobuf::internal::kEmptyString) {
    subscriptcode_ = new ::std::string;
  }
  subscriptcode_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_subscriptcode(const char* value, size_t size) {
  set_has_subscriptcode();
  if (subscriptcode_ == &::google::protobuf::internal::kEmptyString) {
    subscriptcode_ = new ::std::string;
  }
  subscriptcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_subscriptcode() {
  set_has_subscriptcode();
  if (subscriptcode_ == &::google::protobuf::internal::kEmptyString) {
    subscriptcode_ = new ::std::string;
  }
  return subscriptcode_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_subscriptcode() {
  clear_has_subscriptcode();
  if (subscriptcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subscriptcode_;
    subscriptcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFNum = 15;
inline bool INF_QueryETFbaseInfo_Ack::has_etfnum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_etfnum() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_etfnum() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_etfnum() {
  if (etfnum_ != &::google::protobuf::internal::kEmptyString) {
    etfnum_->clear();
  }
  clear_has_etfnum();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::etfnum() const {
  return *etfnum_;
}
inline void INF_QueryETFbaseInfo_Ack::set_etfnum(const ::std::string& value) {
  set_has_etfnum();
  if (etfnum_ == &::google::protobuf::internal::kEmptyString) {
    etfnum_ = new ::std::string;
  }
  etfnum_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_etfnum(const char* value) {
  set_has_etfnum();
  if (etfnum_ == &::google::protobuf::internal::kEmptyString) {
    etfnum_ = new ::std::string;
  }
  etfnum_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_etfnum(const char* value, size_t size) {
  set_has_etfnum();
  if (etfnum_ == &::google::protobuf::internal::kEmptyString) {
    etfnum_ = new ::std::string;
  }
  etfnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_etfnum() {
  set_has_etfnum();
  if (etfnum_ == &::google::protobuf::internal::kEmptyString) {
    etfnum_ = new ::std::string;
  }
  return etfnum_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_etfnum() {
  clear_has_etfnum();
  if (etfnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfnum_;
    etfnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CashBalances = 16;
inline bool INF_QueryETFbaseInfo_Ack::has_cashbalances() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_cashbalances() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_cashbalances() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_cashbalances() {
  if (cashbalances_ != &::google::protobuf::internal::kEmptyString) {
    cashbalances_->clear();
  }
  clear_has_cashbalances();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::cashbalances() const {
  return *cashbalances_;
}
inline void INF_QueryETFbaseInfo_Ack::set_cashbalances(const ::std::string& value) {
  set_has_cashbalances();
  if (cashbalances_ == &::google::protobuf::internal::kEmptyString) {
    cashbalances_ = new ::std::string;
  }
  cashbalances_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_cashbalances(const char* value) {
  set_has_cashbalances();
  if (cashbalances_ == &::google::protobuf::internal::kEmptyString) {
    cashbalances_ = new ::std::string;
  }
  cashbalances_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_cashbalances(const char* value, size_t size) {
  set_has_cashbalances();
  if (cashbalances_ == &::google::protobuf::internal::kEmptyString) {
    cashbalances_ = new ::std::string;
  }
  cashbalances_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_cashbalances() {
  set_has_cashbalances();
  if (cashbalances_ == &::google::protobuf::internal::kEmptyString) {
    cashbalances_ = new ::std::string;
  }
  return cashbalances_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_cashbalances() {
  clear_has_cashbalances();
  if (cashbalances_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cashbalances_;
    cashbalances_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsPurRedeem = 17;
inline bool INF_QueryETFbaseInfo_Ack::has_ispurredeem() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_ispurredeem() {
  _has_bits_[0] |= 0x00010000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_ispurredeem() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_ispurredeem() {
  if (ispurredeem_ != &::google::protobuf::internal::kEmptyString) {
    ispurredeem_->clear();
  }
  clear_has_ispurredeem();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::ispurredeem() const {
  return *ispurredeem_;
}
inline void INF_QueryETFbaseInfo_Ack::set_ispurredeem(const ::std::string& value) {
  set_has_ispurredeem();
  if (ispurredeem_ == &::google::protobuf::internal::kEmptyString) {
    ispurredeem_ = new ::std::string;
  }
  ispurredeem_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_ispurredeem(const char* value) {
  set_has_ispurredeem();
  if (ispurredeem_ == &::google::protobuf::internal::kEmptyString) {
    ispurredeem_ = new ::std::string;
  }
  ispurredeem_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_ispurredeem(const char* value, size_t size) {
  set_has_ispurredeem();
  if (ispurredeem_ == &::google::protobuf::internal::kEmptyString) {
    ispurredeem_ = new ::std::string;
  }
  ispurredeem_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_ispurredeem() {
  set_has_ispurredeem();
  if (ispurredeem_ == &::google::protobuf::internal::kEmptyString) {
    ispurredeem_ = new ::std::string;
  }
  return ispurredeem_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_ispurredeem() {
  clear_has_ispurredeem();
  if (ispurredeem_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ispurredeem_;
    ispurredeem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string TrailerDate = 18;
inline bool INF_QueryETFbaseInfo_Ack::has_trailerdate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_trailerdate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_trailerdate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_trailerdate() {
  if (trailerdate_ != &::google::protobuf::internal::kEmptyString) {
    trailerdate_->clear();
  }
  clear_has_trailerdate();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::trailerdate() const {
  return *trailerdate_;
}
inline void INF_QueryETFbaseInfo_Ack::set_trailerdate(const ::std::string& value) {
  set_has_trailerdate();
  if (trailerdate_ == &::google::protobuf::internal::kEmptyString) {
    trailerdate_ = new ::std::string;
  }
  trailerdate_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_trailerdate(const char* value) {
  set_has_trailerdate();
  if (trailerdate_ == &::google::protobuf::internal::kEmptyString) {
    trailerdate_ = new ::std::string;
  }
  trailerdate_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_trailerdate(const char* value, size_t size) {
  set_has_trailerdate();
  if (trailerdate_ == &::google::protobuf::internal::kEmptyString) {
    trailerdate_ = new ::std::string;
  }
  trailerdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_trailerdate() {
  set_has_trailerdate();
  if (trailerdate_ == &::google::protobuf::internal::kEmptyString) {
    trailerdate_ = new ::std::string;
  }
  return trailerdate_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_trailerdate() {
  clear_has_trailerdate();
  if (trailerdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trailerdate_;
    trailerdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PreCashDiffer = 19;
inline bool INF_QueryETFbaseInfo_Ack::has_precashdiffer() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_precashdiffer() {
  _has_bits_[0] |= 0x00040000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_precashdiffer() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_precashdiffer() {
  if (precashdiffer_ != &::google::protobuf::internal::kEmptyString) {
    precashdiffer_->clear();
  }
  clear_has_precashdiffer();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::precashdiffer() const {
  return *precashdiffer_;
}
inline void INF_QueryETFbaseInfo_Ack::set_precashdiffer(const ::std::string& value) {
  set_has_precashdiffer();
  if (precashdiffer_ == &::google::protobuf::internal::kEmptyString) {
    precashdiffer_ = new ::std::string;
  }
  precashdiffer_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_precashdiffer(const char* value) {
  set_has_precashdiffer();
  if (precashdiffer_ == &::google::protobuf::internal::kEmptyString) {
    precashdiffer_ = new ::std::string;
  }
  precashdiffer_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_precashdiffer(const char* value, size_t size) {
  set_has_precashdiffer();
  if (precashdiffer_ == &::google::protobuf::internal::kEmptyString) {
    precashdiffer_ = new ::std::string;
  }
  precashdiffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_precashdiffer() {
  set_has_precashdiffer();
  if (precashdiffer_ == &::google::protobuf::internal::kEmptyString) {
    precashdiffer_ = new ::std::string;
  }
  return precashdiffer_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_precashdiffer() {
  clear_has_precashdiffer();
  if (precashdiffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = precashdiffer_;
    precashdiffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FundNet = 20;
inline bool INF_QueryETFbaseInfo_Ack::has_fundnet() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_fundnet() {
  _has_bits_[0] |= 0x00080000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_fundnet() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_fundnet() {
  if (fundnet_ != &::google::protobuf::internal::kEmptyString) {
    fundnet_->clear();
  }
  clear_has_fundnet();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::fundnet() const {
  return *fundnet_;
}
inline void INF_QueryETFbaseInfo_Ack::set_fundnet(const ::std::string& value) {
  set_has_fundnet();
  if (fundnet_ == &::google::protobuf::internal::kEmptyString) {
    fundnet_ = new ::std::string;
  }
  fundnet_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_fundnet(const char* value) {
  set_has_fundnet();
  if (fundnet_ == &::google::protobuf::internal::kEmptyString) {
    fundnet_ = new ::std::string;
  }
  fundnet_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_fundnet(const char* value, size_t size) {
  set_has_fundnet();
  if (fundnet_ == &::google::protobuf::internal::kEmptyString) {
    fundnet_ = new ::std::string;
  }
  fundnet_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_fundnet() {
  set_has_fundnet();
  if (fundnet_ == &::google::protobuf::internal::kEmptyString) {
    fundnet_ = new ::std::string;
  }
  return fundnet_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_fundnet() {
  clear_has_fundnet();
  if (fundnet_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fundnet_;
    fundnet_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string StockNum = 21;
inline bool INF_QueryETFbaseInfo_Ack::has_stocknum() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_stocknum() {
  _has_bits_[0] |= 0x00100000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_stocknum() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_stocknum() {
  if (stocknum_ != &::google::protobuf::internal::kEmptyString) {
    stocknum_->clear();
  }
  clear_has_stocknum();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::stocknum() const {
  return *stocknum_;
}
inline void INF_QueryETFbaseInfo_Ack::set_stocknum(const ::std::string& value) {
  set_has_stocknum();
  if (stocknum_ == &::google::protobuf::internal::kEmptyString) {
    stocknum_ = new ::std::string;
  }
  stocknum_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_stocknum(const char* value) {
  set_has_stocknum();
  if (stocknum_ == &::google::protobuf::internal::kEmptyString) {
    stocknum_ = new ::std::string;
  }
  stocknum_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_stocknum(const char* value, size_t size) {
  set_has_stocknum();
  if (stocknum_ == &::google::protobuf::internal::kEmptyString) {
    stocknum_ = new ::std::string;
  }
  stocknum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_stocknum() {
  set_has_stocknum();
  if (stocknum_ == &::google::protobuf::internal::kEmptyString) {
    stocknum_ = new ::std::string;
  }
  return stocknum_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_stocknum() {
  clear_has_stocknum();
  if (stocknum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stocknum_;
    stocknum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFAttr = 22;
inline bool INF_QueryETFbaseInfo_Ack::has_etfattr() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void INF_QueryETFbaseInfo_Ack::set_has_etfattr() {
  _has_bits_[0] |= 0x00200000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_has_etfattr() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void INF_QueryETFbaseInfo_Ack::clear_etfattr() {
  if (etfattr_ != &::google::protobuf::internal::kEmptyString) {
    etfattr_->clear();
  }
  clear_has_etfattr();
}
inline const ::std::string& INF_QueryETFbaseInfo_Ack::etfattr() const {
  return *etfattr_;
}
inline void INF_QueryETFbaseInfo_Ack::set_etfattr(const ::std::string& value) {
  set_has_etfattr();
  if (etfattr_ == &::google::protobuf::internal::kEmptyString) {
    etfattr_ = new ::std::string;
  }
  etfattr_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_etfattr(const char* value) {
  set_has_etfattr();
  if (etfattr_ == &::google::protobuf::internal::kEmptyString) {
    etfattr_ = new ::std::string;
  }
  etfattr_->assign(value);
}
inline void INF_QueryETFbaseInfo_Ack::set_etfattr(const char* value, size_t size) {
  set_has_etfattr();
  if (etfattr_ == &::google::protobuf::internal::kEmptyString) {
    etfattr_ = new ::std::string;
  }
  etfattr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::mutable_etfattr() {
  set_has_etfattr();
  if (etfattr_ == &::google::protobuf::internal::kEmptyString) {
    etfattr_ = new ::std::string;
  }
  return etfattr_;
}
inline ::std::string* INF_QueryETFbaseInfo_Ack::release_etfattr() {
  clear_has_etfattr();
  if (etfattr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfattr_;
    etfattr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryETFlistInfo_Ack

// optional string MarketID = 1;
inline bool INF_QueryETFlistInfo_Ack::has_marketid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryETFlistInfo_Ack::set_has_marketid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryETFlistInfo_Ack::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryETFlistInfo_Ack::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_QueryETFlistInfo_Ack::marketid() const {
  return *marketid_;
}
inline void INF_QueryETFlistInfo_Ack::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Ack::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_QueryETFlistInfo_Ack::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 2;
inline bool INF_QueryETFlistInfo_Ack::has_securitycode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryETFlistInfo_Ack::set_has_securitycode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryETFlistInfo_Ack::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryETFlistInfo_Ack::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_QueryETFlistInfo_Ack::securitycode() const {
  return *securitycode_;
}
inline void INF_QueryETFlistInfo_Ack::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Ack::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_QueryETFlistInfo_Ack::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityName = 3;
inline bool INF_QueryETFlistInfo_Ack::has_securityname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryETFlistInfo_Ack::set_has_securityname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryETFlistInfo_Ack::clear_has_securityname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryETFlistInfo_Ack::clear_securityname() {
  if (securityname_ != &::google::protobuf::internal::kEmptyString) {
    securityname_->clear();
  }
  clear_has_securityname();
}
inline const ::std::string& INF_QueryETFlistInfo_Ack::securityname() const {
  return *securityname_;
}
inline void INF_QueryETFlistInfo_Ack::set_securityname(const ::std::string& value) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_securityname(const char* value) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_securityname(const char* value, size_t size) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Ack::mutable_securityname() {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  return securityname_;
}
inline ::std::string* INF_QueryETFlistInfo_Ack::release_securityname() {
  clear_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securityname_;
    securityname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityNum = 4;
inline bool INF_QueryETFlistInfo_Ack::has_securitynum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryETFlistInfo_Ack::set_has_securitynum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryETFlistInfo_Ack::clear_has_securitynum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryETFlistInfo_Ack::clear_securitynum() {
  if (securitynum_ != &::google::protobuf::internal::kEmptyString) {
    securitynum_->clear();
  }
  clear_has_securitynum();
}
inline const ::std::string& INF_QueryETFlistInfo_Ack::securitynum() const {
  return *securitynum_;
}
inline void INF_QueryETFlistInfo_Ack::set_securitynum(const ::std::string& value) {
  set_has_securitynum();
  if (securitynum_ == &::google::protobuf::internal::kEmptyString) {
    securitynum_ = new ::std::string;
  }
  securitynum_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_securitynum(const char* value) {
  set_has_securitynum();
  if (securitynum_ == &::google::protobuf::internal::kEmptyString) {
    securitynum_ = new ::std::string;
  }
  securitynum_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_securitynum(const char* value, size_t size) {
  set_has_securitynum();
  if (securitynum_ == &::google::protobuf::internal::kEmptyString) {
    securitynum_ = new ::std::string;
  }
  securitynum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Ack::mutable_securitynum() {
  set_has_securitynum();
  if (securitynum_ == &::google::protobuf::internal::kEmptyString) {
    securitynum_ = new ::std::string;
  }
  return securitynum_;
}
inline ::std::string* INF_QueryETFlistInfo_Ack::release_securitynum() {
  clear_has_securitynum();
  if (securitynum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitynum_;
    securitynum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CastReplaceFlag = 5;
inline bool INF_QueryETFlistInfo_Ack::has_castreplaceflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryETFlistInfo_Ack::set_has_castreplaceflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryETFlistInfo_Ack::clear_has_castreplaceflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryETFlistInfo_Ack::clear_castreplaceflag() {
  if (castreplaceflag_ != &::google::protobuf::internal::kEmptyString) {
    castreplaceflag_->clear();
  }
  clear_has_castreplaceflag();
}
inline const ::std::string& INF_QueryETFlistInfo_Ack::castreplaceflag() const {
  return *castreplaceflag_;
}
inline void INF_QueryETFlistInfo_Ack::set_castreplaceflag(const ::std::string& value) {
  set_has_castreplaceflag();
  if (castreplaceflag_ == &::google::protobuf::internal::kEmptyString) {
    castreplaceflag_ = new ::std::string;
  }
  castreplaceflag_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_castreplaceflag(const char* value) {
  set_has_castreplaceflag();
  if (castreplaceflag_ == &::google::protobuf::internal::kEmptyString) {
    castreplaceflag_ = new ::std::string;
  }
  castreplaceflag_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_castreplaceflag(const char* value, size_t size) {
  set_has_castreplaceflag();
  if (castreplaceflag_ == &::google::protobuf::internal::kEmptyString) {
    castreplaceflag_ = new ::std::string;
  }
  castreplaceflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Ack::mutable_castreplaceflag() {
  set_has_castreplaceflag();
  if (castreplaceflag_ == &::google::protobuf::internal::kEmptyString) {
    castreplaceflag_ = new ::std::string;
  }
  return castreplaceflag_;
}
inline ::std::string* INF_QueryETFlistInfo_Ack::release_castreplaceflag() {
  clear_has_castreplaceflag();
  if (castreplaceflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = castreplaceflag_;
    castreplaceflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CastReplaceRate = 6;
inline bool INF_QueryETFlistInfo_Ack::has_castreplacerate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryETFlistInfo_Ack::set_has_castreplacerate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryETFlistInfo_Ack::clear_has_castreplacerate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryETFlistInfo_Ack::clear_castreplacerate() {
  if (castreplacerate_ != &::google::protobuf::internal::kEmptyString) {
    castreplacerate_->clear();
  }
  clear_has_castreplacerate();
}
inline const ::std::string& INF_QueryETFlistInfo_Ack::castreplacerate() const {
  return *castreplacerate_;
}
inline void INF_QueryETFlistInfo_Ack::set_castreplacerate(const ::std::string& value) {
  set_has_castreplacerate();
  if (castreplacerate_ == &::google::protobuf::internal::kEmptyString) {
    castreplacerate_ = new ::std::string;
  }
  castreplacerate_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_castreplacerate(const char* value) {
  set_has_castreplacerate();
  if (castreplacerate_ == &::google::protobuf::internal::kEmptyString) {
    castreplacerate_ = new ::std::string;
  }
  castreplacerate_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_castreplacerate(const char* value, size_t size) {
  set_has_castreplacerate();
  if (castreplacerate_ == &::google::protobuf::internal::kEmptyString) {
    castreplacerate_ = new ::std::string;
  }
  castreplacerate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Ack::mutable_castreplacerate() {
  set_has_castreplacerate();
  if (castreplacerate_ == &::google::protobuf::internal::kEmptyString) {
    castreplacerate_ = new ::std::string;
  }
  return castreplacerate_;
}
inline ::std::string* INF_QueryETFlistInfo_Ack::release_castreplacerate() {
  clear_has_castreplacerate();
  if (castreplacerate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = castreplacerate_;
    castreplacerate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FundReplaceSum = 7;
inline bool INF_QueryETFlistInfo_Ack::has_fundreplacesum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryETFlistInfo_Ack::set_has_fundreplacesum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryETFlistInfo_Ack::clear_has_fundreplacesum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryETFlistInfo_Ack::clear_fundreplacesum() {
  if (fundreplacesum_ != &::google::protobuf::internal::kEmptyString) {
    fundreplacesum_->clear();
  }
  clear_has_fundreplacesum();
}
inline const ::std::string& INF_QueryETFlistInfo_Ack::fundreplacesum() const {
  return *fundreplacesum_;
}
inline void INF_QueryETFlistInfo_Ack::set_fundreplacesum(const ::std::string& value) {
  set_has_fundreplacesum();
  if (fundreplacesum_ == &::google::protobuf::internal::kEmptyString) {
    fundreplacesum_ = new ::std::string;
  }
  fundreplacesum_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_fundreplacesum(const char* value) {
  set_has_fundreplacesum();
  if (fundreplacesum_ == &::google::protobuf::internal::kEmptyString) {
    fundreplacesum_ = new ::std::string;
  }
  fundreplacesum_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_fundreplacesum(const char* value, size_t size) {
  set_has_fundreplacesum();
  if (fundreplacesum_ == &::google::protobuf::internal::kEmptyString) {
    fundreplacesum_ = new ::std::string;
  }
  fundreplacesum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Ack::mutable_fundreplacesum() {
  set_has_fundreplacesum();
  if (fundreplacesum_ == &::google::protobuf::internal::kEmptyString) {
    fundreplacesum_ = new ::std::string;
  }
  return fundreplacesum_;
}
inline ::std::string* INF_QueryETFlistInfo_Ack::release_fundreplacesum() {
  clear_has_fundreplacesum();
  if (fundreplacesum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fundreplacesum_;
    fundreplacesum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 8;
inline bool INF_QueryETFlistInfo_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryETFlistInfo_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryETFlistInfo_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryETFlistInfo_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_QueryETFlistInfo_Ack::respflag() const {
  return *respflag_;
}
inline void INF_QueryETFlistInfo_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_QueryETFlistInfo_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DisplayNo = 9;
inline bool INF_QueryETFlistInfo_Ack::has_displayno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryETFlistInfo_Ack::set_has_displayno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryETFlistInfo_Ack::clear_has_displayno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryETFlistInfo_Ack::clear_displayno() {
  if (displayno_ != &::google::protobuf::internal::kEmptyString) {
    displayno_->clear();
  }
  clear_has_displayno();
}
inline const ::std::string& INF_QueryETFlistInfo_Ack::displayno() const {
  return *displayno_;
}
inline void INF_QueryETFlistInfo_Ack::set_displayno(const ::std::string& value) {
  set_has_displayno();
  if (displayno_ == &::google::protobuf::internal::kEmptyString) {
    displayno_ = new ::std::string;
  }
  displayno_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_displayno(const char* value) {
  set_has_displayno();
  if (displayno_ == &::google::protobuf::internal::kEmptyString) {
    displayno_ = new ::std::string;
  }
  displayno_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_displayno(const char* value, size_t size) {
  set_has_displayno();
  if (displayno_ == &::google::protobuf::internal::kEmptyString) {
    displayno_ = new ::std::string;
  }
  displayno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Ack::mutable_displayno() {
  set_has_displayno();
  if (displayno_ == &::google::protobuf::internal::kEmptyString) {
    displayno_ = new ::std::string;
  }
  return displayno_;
}
inline ::std::string* INF_QueryETFlistInfo_Ack::release_displayno() {
  clear_has_displayno();
  if (displayno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayno_;
    displayno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string StockOfMarket = 10;
inline bool INF_QueryETFlistInfo_Ack::has_stockofmarket() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryETFlistInfo_Ack::set_has_stockofmarket() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryETFlistInfo_Ack::clear_has_stockofmarket() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryETFlistInfo_Ack::clear_stockofmarket() {
  if (stockofmarket_ != &::google::protobuf::internal::kEmptyString) {
    stockofmarket_->clear();
  }
  clear_has_stockofmarket();
}
inline const ::std::string& INF_QueryETFlistInfo_Ack::stockofmarket() const {
  return *stockofmarket_;
}
inline void INF_QueryETFlistInfo_Ack::set_stockofmarket(const ::std::string& value) {
  set_has_stockofmarket();
  if (stockofmarket_ == &::google::protobuf::internal::kEmptyString) {
    stockofmarket_ = new ::std::string;
  }
  stockofmarket_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_stockofmarket(const char* value) {
  set_has_stockofmarket();
  if (stockofmarket_ == &::google::protobuf::internal::kEmptyString) {
    stockofmarket_ = new ::std::string;
  }
  stockofmarket_->assign(value);
}
inline void INF_QueryETFlistInfo_Ack::set_stockofmarket(const char* value, size_t size) {
  set_has_stockofmarket();
  if (stockofmarket_ == &::google::protobuf::internal::kEmptyString) {
    stockofmarket_ = new ::std::string;
  }
  stockofmarket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFlistInfo_Ack::mutable_stockofmarket() {
  set_has_stockofmarket();
  if (stockofmarket_ == &::google::protobuf::internal::kEmptyString) {
    stockofmarket_ = new ::std::string;
  }
  return stockofmarket_;
}
inline ::std::string* INF_QueryETFlistInfo_Ack::release_stockofmarket() {
  clear_has_stockofmarket();
  if (stockofmarket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stockofmarket_;
    stockofmarket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryETFdynamicInfo_Ack

// optional string MarketID = 1;
inline bool INF_QueryETFdynamicInfo_Ack::has_marketid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_marketid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::marketid() const {
  return *marketid_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFCode = 2;
inline bool INF_QueryETFdynamicInfo_Ack::has_etfcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_etfcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_etfcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_etfcode() {
  if (etfcode_ != &::google::protobuf::internal::kEmptyString) {
    etfcode_->clear();
  }
  clear_has_etfcode();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::etfcode() const {
  return *etfcode_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_etfcode(const ::std::string& value) {
  set_has_etfcode();
  if (etfcode_ == &::google::protobuf::internal::kEmptyString) {
    etfcode_ = new ::std::string;
  }
  etfcode_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_etfcode(const char* value) {
  set_has_etfcode();
  if (etfcode_ == &::google::protobuf::internal::kEmptyString) {
    etfcode_ = new ::std::string;
  }
  etfcode_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_etfcode(const char* value, size_t size) {
  set_has_etfcode();
  if (etfcode_ == &::google::protobuf::internal::kEmptyString) {
    etfcode_ = new ::std::string;
  }
  etfcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_etfcode() {
  set_has_etfcode();
  if (etfcode_ == &::google::protobuf::internal::kEmptyString) {
    etfcode_ = new ::std::string;
  }
  return etfcode_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_etfcode() {
  clear_has_etfcode();
  if (etfcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfcode_;
    etfcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ValidPurRedemNum = 3;
inline bool INF_QueryETFdynamicInfo_Ack::has_validpurredemnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_validpurredemnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_validpurredemnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_validpurredemnum() {
  if (validpurredemnum_ != &::google::protobuf::internal::kEmptyString) {
    validpurredemnum_->clear();
  }
  clear_has_validpurredemnum();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::validpurredemnum() const {
  return *validpurredemnum_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_validpurredemnum(const ::std::string& value) {
  set_has_validpurredemnum();
  if (validpurredemnum_ == &::google::protobuf::internal::kEmptyString) {
    validpurredemnum_ = new ::std::string;
  }
  validpurredemnum_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_validpurredemnum(const char* value) {
  set_has_validpurredemnum();
  if (validpurredemnum_ == &::google::protobuf::internal::kEmptyString) {
    validpurredemnum_ = new ::std::string;
  }
  validpurredemnum_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_validpurredemnum(const char* value, size_t size) {
  set_has_validpurredemnum();
  if (validpurredemnum_ == &::google::protobuf::internal::kEmptyString) {
    validpurredemnum_ = new ::std::string;
  }
  validpurredemnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_validpurredemnum() {
  set_has_validpurredemnum();
  if (validpurredemnum_ == &::google::protobuf::internal::kEmptyString) {
    validpurredemnum_ = new ::std::string;
  }
  return validpurredemnum_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_validpurredemnum() {
  clear_has_validpurredemnum();
  if (validpurredemnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = validpurredemnum_;
    validpurredemnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 4;
inline bool INF_QueryETFdynamicInfo_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::respflag() const {
  return *respflag_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFName = 5;
inline bool INF_QueryETFdynamicInfo_Ack::has_etfname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_etfname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_etfname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_etfname() {
  if (etfname_ != &::google::protobuf::internal::kEmptyString) {
    etfname_->clear();
  }
  clear_has_etfname();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::etfname() const {
  return *etfname_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_etfname(const ::std::string& value) {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  etfname_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_etfname(const char* value) {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  etfname_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_etfname(const char* value, size_t size) {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  etfname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_etfname() {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  return etfname_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_etfname() {
  clear_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfname_;
    etfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BaskeAskNum = 6;
inline bool INF_QueryETFdynamicInfo_Ack::has_baskeasknum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_baskeasknum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_baskeasknum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_baskeasknum() {
  if (baskeasknum_ != &::google::protobuf::internal::kEmptyString) {
    baskeasknum_->clear();
  }
  clear_has_baskeasknum();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::baskeasknum() const {
  return *baskeasknum_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_baskeasknum(const ::std::string& value) {
  set_has_baskeasknum();
  if (baskeasknum_ == &::google::protobuf::internal::kEmptyString) {
    baskeasknum_ = new ::std::string;
  }
  baskeasknum_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_baskeasknum(const char* value) {
  set_has_baskeasknum();
  if (baskeasknum_ == &::google::protobuf::internal::kEmptyString) {
    baskeasknum_ = new ::std::string;
  }
  baskeasknum_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_baskeasknum(const char* value, size_t size) {
  set_has_baskeasknum();
  if (baskeasknum_ == &::google::protobuf::internal::kEmptyString) {
    baskeasknum_ = new ::std::string;
  }
  baskeasknum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_baskeasknum() {
  set_has_baskeasknum();
  if (baskeasknum_ == &::google::protobuf::internal::kEmptyString) {
    baskeasknum_ = new ::std::string;
  }
  return baskeasknum_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_baskeasknum() {
  clear_has_baskeasknum();
  if (baskeasknum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = baskeasknum_;
    baskeasknum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string NeedBuyNum = 7;
inline bool INF_QueryETFdynamicInfo_Ack::has_needbuynum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_needbuynum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_needbuynum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_needbuynum() {
  if (needbuynum_ != &::google::protobuf::internal::kEmptyString) {
    needbuynum_->clear();
  }
  clear_has_needbuynum();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::needbuynum() const {
  return *needbuynum_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_needbuynum(const ::std::string& value) {
  set_has_needbuynum();
  if (needbuynum_ == &::google::protobuf::internal::kEmptyString) {
    needbuynum_ = new ::std::string;
  }
  needbuynum_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_needbuynum(const char* value) {
  set_has_needbuynum();
  if (needbuynum_ == &::google::protobuf::internal::kEmptyString) {
    needbuynum_ = new ::std::string;
  }
  needbuynum_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_needbuynum(const char* value, size_t size) {
  set_has_needbuynum();
  if (needbuynum_ == &::google::protobuf::internal::kEmptyString) {
    needbuynum_ = new ::std::string;
  }
  needbuynum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_needbuynum() {
  set_has_needbuynum();
  if (needbuynum_ == &::google::protobuf::internal::kEmptyString) {
    needbuynum_ = new ::std::string;
  }
  return needbuynum_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_needbuynum() {
  clear_has_needbuynum();
  if (needbuynum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = needbuynum_;
    needbuynum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CanReplaceFund = 8;
inline bool INF_QueryETFdynamicInfo_Ack::has_canreplacefund() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_canreplacefund() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_canreplacefund() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_canreplacefund() {
  if (canreplacefund_ != &::google::protobuf::internal::kEmptyString) {
    canreplacefund_->clear();
  }
  clear_has_canreplacefund();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::canreplacefund() const {
  return *canreplacefund_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_canreplacefund(const ::std::string& value) {
  set_has_canreplacefund();
  if (canreplacefund_ == &::google::protobuf::internal::kEmptyString) {
    canreplacefund_ = new ::std::string;
  }
  canreplacefund_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_canreplacefund(const char* value) {
  set_has_canreplacefund();
  if (canreplacefund_ == &::google::protobuf::internal::kEmptyString) {
    canreplacefund_ = new ::std::string;
  }
  canreplacefund_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_canreplacefund(const char* value, size_t size) {
  set_has_canreplacefund();
  if (canreplacefund_ == &::google::protobuf::internal::kEmptyString) {
    canreplacefund_ = new ::std::string;
  }
  canreplacefund_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_canreplacefund() {
  set_has_canreplacefund();
  if (canreplacefund_ == &::google::protobuf::internal::kEmptyString) {
    canreplacefund_ = new ::std::string;
  }
  return canreplacefund_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_canreplacefund() {
  clear_has_canreplacefund();
  if (canreplacefund_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = canreplacefund_;
    canreplacefund_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MustReplaceFund = 9;
inline bool INF_QueryETFdynamicInfo_Ack::has_mustreplacefund() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_mustreplacefund() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_mustreplacefund() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_mustreplacefund() {
  if (mustreplacefund_ != &::google::protobuf::internal::kEmptyString) {
    mustreplacefund_->clear();
  }
  clear_has_mustreplacefund();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::mustreplacefund() const {
  return *mustreplacefund_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_mustreplacefund(const ::std::string& value) {
  set_has_mustreplacefund();
  if (mustreplacefund_ == &::google::protobuf::internal::kEmptyString) {
    mustreplacefund_ = new ::std::string;
  }
  mustreplacefund_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_mustreplacefund(const char* value) {
  set_has_mustreplacefund();
  if (mustreplacefund_ == &::google::protobuf::internal::kEmptyString) {
    mustreplacefund_ = new ::std::string;
  }
  mustreplacefund_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_mustreplacefund(const char* value, size_t size) {
  set_has_mustreplacefund();
  if (mustreplacefund_ == &::google::protobuf::internal::kEmptyString) {
    mustreplacefund_ = new ::std::string;
  }
  mustreplacefund_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_mustreplacefund() {
  set_has_mustreplacefund();
  if (mustreplacefund_ == &::google::protobuf::internal::kEmptyString) {
    mustreplacefund_ = new ::std::string;
  }
  return mustreplacefund_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_mustreplacefund() {
  clear_has_mustreplacefund();
  if (mustreplacefund_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mustreplacefund_;
    mustreplacefund_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PositionOfUndeal = 10;
inline bool INF_QueryETFdynamicInfo_Ack::has_positionofundeal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_positionofundeal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_positionofundeal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_positionofundeal() {
  if (positionofundeal_ != &::google::protobuf::internal::kEmptyString) {
    positionofundeal_->clear();
  }
  clear_has_positionofundeal();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::positionofundeal() const {
  return *positionofundeal_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_positionofundeal(const ::std::string& value) {
  set_has_positionofundeal();
  if (positionofundeal_ == &::google::protobuf::internal::kEmptyString) {
    positionofundeal_ = new ::std::string;
  }
  positionofundeal_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_positionofundeal(const char* value) {
  set_has_positionofundeal();
  if (positionofundeal_ == &::google::protobuf::internal::kEmptyString) {
    positionofundeal_ = new ::std::string;
  }
  positionofundeal_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_positionofundeal(const char* value, size_t size) {
  set_has_positionofundeal();
  if (positionofundeal_ == &::google::protobuf::internal::kEmptyString) {
    positionofundeal_ = new ::std::string;
  }
  positionofundeal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_positionofundeal() {
  set_has_positionofundeal();
  if (positionofundeal_ == &::google::protobuf::internal::kEmptyString) {
    positionofundeal_ = new ::std::string;
  }
  return positionofundeal_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_positionofundeal() {
  clear_has_positionofundeal();
  if (positionofundeal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = positionofundeal_;
    positionofundeal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MaxPurRedemNum = 11;
inline bool INF_QueryETFdynamicInfo_Ack::has_maxpurredemnum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryETFdynamicInfo_Ack::set_has_maxpurredemnum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_has_maxpurredemnum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryETFdynamicInfo_Ack::clear_maxpurredemnum() {
  if (maxpurredemnum_ != &::google::protobuf::internal::kEmptyString) {
    maxpurredemnum_->clear();
  }
  clear_has_maxpurredemnum();
}
inline const ::std::string& INF_QueryETFdynamicInfo_Ack::maxpurredemnum() const {
  return *maxpurredemnum_;
}
inline void INF_QueryETFdynamicInfo_Ack::set_maxpurredemnum(const ::std::string& value) {
  set_has_maxpurredemnum();
  if (maxpurredemnum_ == &::google::protobuf::internal::kEmptyString) {
    maxpurredemnum_ = new ::std::string;
  }
  maxpurredemnum_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_maxpurredemnum(const char* value) {
  set_has_maxpurredemnum();
  if (maxpurredemnum_ == &::google::protobuf::internal::kEmptyString) {
    maxpurredemnum_ = new ::std::string;
  }
  maxpurredemnum_->assign(value);
}
inline void INF_QueryETFdynamicInfo_Ack::set_maxpurredemnum(const char* value, size_t size) {
  set_has_maxpurredemnum();
  if (maxpurredemnum_ == &::google::protobuf::internal::kEmptyString) {
    maxpurredemnum_ = new ::std::string;
  }
  maxpurredemnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::mutable_maxpurredemnum() {
  set_has_maxpurredemnum();
  if (maxpurredemnum_ == &::google::protobuf::internal::kEmptyString) {
    maxpurredemnum_ = new ::std::string;
  }
  return maxpurredemnum_;
}
inline ::std::string* INF_QueryETFdynamicInfo_Ack::release_maxpurredemnum() {
  clear_has_maxpurredemnum();
  if (maxpurredemnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = maxpurredemnum_;
    maxpurredemnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryFundCondition_Ack

// optional string Valid = 1;
inline bool INF_QueryFundCondition_Ack::has_valid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_valid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryFundCondition_Ack::clear_has_valid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryFundCondition_Ack::clear_valid() {
  if (valid_ != &::google::protobuf::internal::kEmptyString) {
    valid_->clear();
  }
  clear_has_valid();
}
inline const ::std::string& INF_QueryFundCondition_Ack::valid() const {
  return *valid_;
}
inline void INF_QueryFundCondition_Ack::set_valid(const ::std::string& value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_valid(const char* value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_valid(const char* value, size_t size) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_valid() {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  return valid_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_valid() {
  clear_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_;
    valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FundRemain = 2;
inline bool INF_QueryFundCondition_Ack::has_fundremain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_fundremain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryFundCondition_Ack::clear_has_fundremain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryFundCondition_Ack::clear_fundremain() {
  if (fundremain_ != &::google::protobuf::internal::kEmptyString) {
    fundremain_->clear();
  }
  clear_has_fundremain();
}
inline const ::std::string& INF_QueryFundCondition_Ack::fundremain() const {
  return *fundremain_;
}
inline void INF_QueryFundCondition_Ack::set_fundremain(const ::std::string& value) {
  set_has_fundremain();
  if (fundremain_ == &::google::protobuf::internal::kEmptyString) {
    fundremain_ = new ::std::string;
  }
  fundremain_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundremain(const char* value) {
  set_has_fundremain();
  if (fundremain_ == &::google::protobuf::internal::kEmptyString) {
    fundremain_ = new ::std::string;
  }
  fundremain_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundremain(const char* value, size_t size) {
  set_has_fundremain();
  if (fundremain_ == &::google::protobuf::internal::kEmptyString) {
    fundremain_ = new ::std::string;
  }
  fundremain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_fundremain() {
  set_has_fundremain();
  if (fundremain_ == &::google::protobuf::internal::kEmptyString) {
    fundremain_ = new ::std::string;
  }
  return fundremain_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_fundremain() {
  clear_has_fundremain();
  if (fundremain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fundremain_;
    fundremain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Validfund = 3;
inline bool INF_QueryFundCondition_Ack::has_validfund() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_validfund() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryFundCondition_Ack::clear_has_validfund() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryFundCondition_Ack::clear_validfund() {
  if (validfund_ != &::google::protobuf::internal::kEmptyString) {
    validfund_->clear();
  }
  clear_has_validfund();
}
inline const ::std::string& INF_QueryFundCondition_Ack::validfund() const {
  return *validfund_;
}
inline void INF_QueryFundCondition_Ack::set_validfund(const ::std::string& value) {
  set_has_validfund();
  if (validfund_ == &::google::protobuf::internal::kEmptyString) {
    validfund_ = new ::std::string;
  }
  validfund_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_validfund(const char* value) {
  set_has_validfund();
  if (validfund_ == &::google::protobuf::internal::kEmptyString) {
    validfund_ = new ::std::string;
  }
  validfund_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_validfund(const char* value, size_t size) {
  set_has_validfund();
  if (validfund_ == &::google::protobuf::internal::kEmptyString) {
    validfund_ = new ::std::string;
  }
  validfund_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_validfund() {
  set_has_validfund();
  if (validfund_ == &::google::protobuf::internal::kEmptyString) {
    validfund_ = new ::std::string;
  }
  return validfund_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_validfund() {
  clear_has_validfund();
  if (validfund_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = validfund_;
    validfund_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MarketValue = 4;
inline bool INF_QueryFundCondition_Ack::has_marketvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_marketvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryFundCondition_Ack::clear_has_marketvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryFundCondition_Ack::clear_marketvalue() {
  if (marketvalue_ != &::google::protobuf::internal::kEmptyString) {
    marketvalue_->clear();
  }
  clear_has_marketvalue();
}
inline const ::std::string& INF_QueryFundCondition_Ack::marketvalue() const {
  return *marketvalue_;
}
inline void INF_QueryFundCondition_Ack::set_marketvalue(const ::std::string& value) {
  set_has_marketvalue();
  if (marketvalue_ == &::google::protobuf::internal::kEmptyString) {
    marketvalue_ = new ::std::string;
  }
  marketvalue_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_marketvalue(const char* value) {
  set_has_marketvalue();
  if (marketvalue_ == &::google::protobuf::internal::kEmptyString) {
    marketvalue_ = new ::std::string;
  }
  marketvalue_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_marketvalue(const char* value, size_t size) {
  set_has_marketvalue();
  if (marketvalue_ == &::google::protobuf::internal::kEmptyString) {
    marketvalue_ = new ::std::string;
  }
  marketvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_marketvalue() {
  set_has_marketvalue();
  if (marketvalue_ == &::google::protobuf::internal::kEmptyString) {
    marketvalue_ = new ::std::string;
  }
  return marketvalue_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_marketvalue() {
  clear_has_marketvalue();
  if (marketvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketvalue_;
    marketvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 5;
inline bool INF_QueryFundCondition_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryFundCondition_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryFundCondition_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_QueryFundCondition_Ack::respflag() const {
  return *respflag_;
}
inline void INF_QueryFundCondition_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsSuccess = 6;
inline bool INF_QueryFundCondition_Ack::has_issuccess() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_issuccess() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryFundCondition_Ack::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryFundCondition_Ack::clear_issuccess() {
  if (issuccess_ != &::google::protobuf::internal::kEmptyString) {
    issuccess_->clear();
  }
  clear_has_issuccess();
}
inline const ::std::string& INF_QueryFundCondition_Ack::issuccess() const {
  return *issuccess_;
}
inline void INF_QueryFundCondition_Ack::set_issuccess(const ::std::string& value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_issuccess(const char* value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_issuccess(const char* value, size_t size) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_issuccess() {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  return issuccess_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_issuccess() {
  clear_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issuccess_;
    issuccess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FundSum = 7;
inline bool INF_QueryFundCondition_Ack::has_fundsum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_fundsum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryFundCondition_Ack::clear_has_fundsum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryFundCondition_Ack::clear_fundsum() {
  if (fundsum_ != &::google::protobuf::internal::kEmptyString) {
    fundsum_->clear();
  }
  clear_has_fundsum();
}
inline const ::std::string& INF_QueryFundCondition_Ack::fundsum() const {
  return *fundsum_;
}
inline void INF_QueryFundCondition_Ack::set_fundsum(const ::std::string& value) {
  set_has_fundsum();
  if (fundsum_ == &::google::protobuf::internal::kEmptyString) {
    fundsum_ = new ::std::string;
  }
  fundsum_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundsum(const char* value) {
  set_has_fundsum();
  if (fundsum_ == &::google::protobuf::internal::kEmptyString) {
    fundsum_ = new ::std::string;
  }
  fundsum_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundsum(const char* value, size_t size) {
  set_has_fundsum();
  if (fundsum_ == &::google::protobuf::internal::kEmptyString) {
    fundsum_ = new ::std::string;
  }
  fundsum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_fundsum() {
  set_has_fundsum();
  if (fundsum_ == &::google::protobuf::internal::kEmptyString) {
    fundsum_ = new ::std::string;
  }
  return fundsum_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_fundsum() {
  clear_has_fundsum();
  if (fundsum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fundsum_;
    fundsum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string TodayBuyCj = 8;
inline bool INF_QueryFundCondition_Ack::has_todaybuycj() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_todaybuycj() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryFundCondition_Ack::clear_has_todaybuycj() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryFundCondition_Ack::clear_todaybuycj() {
  if (todaybuycj_ != &::google::protobuf::internal::kEmptyString) {
    todaybuycj_->clear();
  }
  clear_has_todaybuycj();
}
inline const ::std::string& INF_QueryFundCondition_Ack::todaybuycj() const {
  return *todaybuycj_;
}
inline void INF_QueryFundCondition_Ack::set_todaybuycj(const ::std::string& value) {
  set_has_todaybuycj();
  if (todaybuycj_ == &::google::protobuf::internal::kEmptyString) {
    todaybuycj_ = new ::std::string;
  }
  todaybuycj_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_todaybuycj(const char* value) {
  set_has_todaybuycj();
  if (todaybuycj_ == &::google::protobuf::internal::kEmptyString) {
    todaybuycj_ = new ::std::string;
  }
  todaybuycj_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_todaybuycj(const char* value, size_t size) {
  set_has_todaybuycj();
  if (todaybuycj_ == &::google::protobuf::internal::kEmptyString) {
    todaybuycj_ = new ::std::string;
  }
  todaybuycj_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_todaybuycj() {
  set_has_todaybuycj();
  if (todaybuycj_ == &::google::protobuf::internal::kEmptyString) {
    todaybuycj_ = new ::std::string;
  }
  return todaybuycj_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_todaybuycj() {
  clear_has_todaybuycj();
  if (todaybuycj_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = todaybuycj_;
    todaybuycj_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string TodaySellCj = 9;
inline bool INF_QueryFundCondition_Ack::has_todaysellcj() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_todaysellcj() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryFundCondition_Ack::clear_has_todaysellcj() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryFundCondition_Ack::clear_todaysellcj() {
  if (todaysellcj_ != &::google::protobuf::internal::kEmptyString) {
    todaysellcj_->clear();
  }
  clear_has_todaysellcj();
}
inline const ::std::string& INF_QueryFundCondition_Ack::todaysellcj() const {
  return *todaysellcj_;
}
inline void INF_QueryFundCondition_Ack::set_todaysellcj(const ::std::string& value) {
  set_has_todaysellcj();
  if (todaysellcj_ == &::google::protobuf::internal::kEmptyString) {
    todaysellcj_ = new ::std::string;
  }
  todaysellcj_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_todaysellcj(const char* value) {
  set_has_todaysellcj();
  if (todaysellcj_ == &::google::protobuf::internal::kEmptyString) {
    todaysellcj_ = new ::std::string;
  }
  todaysellcj_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_todaysellcj(const char* value, size_t size) {
  set_has_todaysellcj();
  if (todaysellcj_ == &::google::protobuf::internal::kEmptyString) {
    todaysellcj_ = new ::std::string;
  }
  todaysellcj_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_todaysellcj() {
  set_has_todaysellcj();
  if (todaysellcj_ == &::google::protobuf::internal::kEmptyString) {
    todaysellcj_ = new ::std::string;
  }
  return todaysellcj_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_todaysellcj() {
  clear_has_todaysellcj();
  if (todaysellcj_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = todaysellcj_;
    todaysellcj_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SumFloatProfitLoss = 10;
inline bool INF_QueryFundCondition_Ack::has_sumfloatprofitloss() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_sumfloatprofitloss() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryFundCondition_Ack::clear_has_sumfloatprofitloss() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryFundCondition_Ack::clear_sumfloatprofitloss() {
  if (sumfloatprofitloss_ != &::google::protobuf::internal::kEmptyString) {
    sumfloatprofitloss_->clear();
  }
  clear_has_sumfloatprofitloss();
}
inline const ::std::string& INF_QueryFundCondition_Ack::sumfloatprofitloss() const {
  return *sumfloatprofitloss_;
}
inline void INF_QueryFundCondition_Ack::set_sumfloatprofitloss(const ::std::string& value) {
  set_has_sumfloatprofitloss();
  if (sumfloatprofitloss_ == &::google::protobuf::internal::kEmptyString) {
    sumfloatprofitloss_ = new ::std::string;
  }
  sumfloatprofitloss_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_sumfloatprofitloss(const char* value) {
  set_has_sumfloatprofitloss();
  if (sumfloatprofitloss_ == &::google::protobuf::internal::kEmptyString) {
    sumfloatprofitloss_ = new ::std::string;
  }
  sumfloatprofitloss_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_sumfloatprofitloss(const char* value, size_t size) {
  set_has_sumfloatprofitloss();
  if (sumfloatprofitloss_ == &::google::protobuf::internal::kEmptyString) {
    sumfloatprofitloss_ = new ::std::string;
  }
  sumfloatprofitloss_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_sumfloatprofitloss() {
  set_has_sumfloatprofitloss();
  if (sumfloatprofitloss_ == &::google::protobuf::internal::kEmptyString) {
    sumfloatprofitloss_ = new ::std::string;
  }
  return sumfloatprofitloss_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_sumfloatprofitloss() {
  clear_has_sumfloatprofitloss();
  if (sumfloatprofitloss_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sumfloatprofitloss_;
    sumfloatprofitloss_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FundOfTodayBuyUndeal = 11;
inline bool INF_QueryFundCondition_Ack::has_fundoftodaybuyundeal() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_fundoftodaybuyundeal() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryFundCondition_Ack::clear_has_fundoftodaybuyundeal() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryFundCondition_Ack::clear_fundoftodaybuyundeal() {
  if (fundoftodaybuyundeal_ != &::google::protobuf::internal::kEmptyString) {
    fundoftodaybuyundeal_->clear();
  }
  clear_has_fundoftodaybuyundeal();
}
inline const ::std::string& INF_QueryFundCondition_Ack::fundoftodaybuyundeal() const {
  return *fundoftodaybuyundeal_;
}
inline void INF_QueryFundCondition_Ack::set_fundoftodaybuyundeal(const ::std::string& value) {
  set_has_fundoftodaybuyundeal();
  if (fundoftodaybuyundeal_ == &::google::protobuf::internal::kEmptyString) {
    fundoftodaybuyundeal_ = new ::std::string;
  }
  fundoftodaybuyundeal_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundoftodaybuyundeal(const char* value) {
  set_has_fundoftodaybuyundeal();
  if (fundoftodaybuyundeal_ == &::google::protobuf::internal::kEmptyString) {
    fundoftodaybuyundeal_ = new ::std::string;
  }
  fundoftodaybuyundeal_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundoftodaybuyundeal(const char* value, size_t size) {
  set_has_fundoftodaybuyundeal();
  if (fundoftodaybuyundeal_ == &::google::protobuf::internal::kEmptyString) {
    fundoftodaybuyundeal_ = new ::std::string;
  }
  fundoftodaybuyundeal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_fundoftodaybuyundeal() {
  set_has_fundoftodaybuyundeal();
  if (fundoftodaybuyundeal_ == &::google::protobuf::internal::kEmptyString) {
    fundoftodaybuyundeal_ = new ::std::string;
  }
  return fundoftodaybuyundeal_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_fundoftodaybuyundeal() {
  clear_has_fundoftodaybuyundeal();
  if (fundoftodaybuyundeal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fundoftodaybuyundeal_;
    fundoftodaybuyundeal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FundOfBuyUnsettled = 12;
inline bool INF_QueryFundCondition_Ack::has_fundofbuyunsettled() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_fundofbuyunsettled() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryFundCondition_Ack::clear_has_fundofbuyunsettled() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryFundCondition_Ack::clear_fundofbuyunsettled() {
  if (fundofbuyunsettled_ != &::google::protobuf::internal::kEmptyString) {
    fundofbuyunsettled_->clear();
  }
  clear_has_fundofbuyunsettled();
}
inline const ::std::string& INF_QueryFundCondition_Ack::fundofbuyunsettled() const {
  return *fundofbuyunsettled_;
}
inline void INF_QueryFundCondition_Ack::set_fundofbuyunsettled(const ::std::string& value) {
  set_has_fundofbuyunsettled();
  if (fundofbuyunsettled_ == &::google::protobuf::internal::kEmptyString) {
    fundofbuyunsettled_ = new ::std::string;
  }
  fundofbuyunsettled_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundofbuyunsettled(const char* value) {
  set_has_fundofbuyunsettled();
  if (fundofbuyunsettled_ == &::google::protobuf::internal::kEmptyString) {
    fundofbuyunsettled_ = new ::std::string;
  }
  fundofbuyunsettled_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundofbuyunsettled(const char* value, size_t size) {
  set_has_fundofbuyunsettled();
  if (fundofbuyunsettled_ == &::google::protobuf::internal::kEmptyString) {
    fundofbuyunsettled_ = new ::std::string;
  }
  fundofbuyunsettled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_fundofbuyunsettled() {
  set_has_fundofbuyunsettled();
  if (fundofbuyunsettled_ == &::google::protobuf::internal::kEmptyString) {
    fundofbuyunsettled_ = new ::std::string;
  }
  return fundofbuyunsettled_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_fundofbuyunsettled() {
  clear_has_fundofbuyunsettled();
  if (fundofbuyunsettled_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fundofbuyunsettled_;
    fundofbuyunsettled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FundOfSellUnsettled = 13;
inline bool INF_QueryFundCondition_Ack::has_fundofsellunsettled() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_fundofsellunsettled() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_QueryFundCondition_Ack::clear_has_fundofsellunsettled() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_QueryFundCondition_Ack::clear_fundofsellunsettled() {
  if (fundofsellunsettled_ != &::google::protobuf::internal::kEmptyString) {
    fundofsellunsettled_->clear();
  }
  clear_has_fundofsellunsettled();
}
inline const ::std::string& INF_QueryFundCondition_Ack::fundofsellunsettled() const {
  return *fundofsellunsettled_;
}
inline void INF_QueryFundCondition_Ack::set_fundofsellunsettled(const ::std::string& value) {
  set_has_fundofsellunsettled();
  if (fundofsellunsettled_ == &::google::protobuf::internal::kEmptyString) {
    fundofsellunsettled_ = new ::std::string;
  }
  fundofsellunsettled_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundofsellunsettled(const char* value) {
  set_has_fundofsellunsettled();
  if (fundofsellunsettled_ == &::google::protobuf::internal::kEmptyString) {
    fundofsellunsettled_ = new ::std::string;
  }
  fundofsellunsettled_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundofsellunsettled(const char* value, size_t size) {
  set_has_fundofsellunsettled();
  if (fundofsellunsettled_ == &::google::protobuf::internal::kEmptyString) {
    fundofsellunsettled_ = new ::std::string;
  }
  fundofsellunsettled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_fundofsellunsettled() {
  set_has_fundofsellunsettled();
  if (fundofsellunsettled_ == &::google::protobuf::internal::kEmptyString) {
    fundofsellunsettled_ = new ::std::string;
  }
  return fundofsellunsettled_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_fundofsellunsettled() {
  clear_has_fundofsellunsettled();
  if (fundofsellunsettled_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fundofsellunsettled_;
    fundofsellunsettled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MoneyName = 14;
inline bool INF_QueryFundCondition_Ack::has_moneyname() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_moneyname() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_QueryFundCondition_Ack::clear_has_moneyname() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_QueryFundCondition_Ack::clear_moneyname() {
  if (moneyname_ != &::google::protobuf::internal::kEmptyString) {
    moneyname_->clear();
  }
  clear_has_moneyname();
}
inline const ::std::string& INF_QueryFundCondition_Ack::moneyname() const {
  return *moneyname_;
}
inline void INF_QueryFundCondition_Ack::set_moneyname(const ::std::string& value) {
  set_has_moneyname();
  if (moneyname_ == &::google::protobuf::internal::kEmptyString) {
    moneyname_ = new ::std::string;
  }
  moneyname_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_moneyname(const char* value) {
  set_has_moneyname();
  if (moneyname_ == &::google::protobuf::internal::kEmptyString) {
    moneyname_ = new ::std::string;
  }
  moneyname_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_moneyname(const char* value, size_t size) {
  set_has_moneyname();
  if (moneyname_ == &::google::protobuf::internal::kEmptyString) {
    moneyname_ = new ::std::string;
  }
  moneyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_moneyname() {
  set_has_moneyname();
  if (moneyname_ == &::google::protobuf::internal::kEmptyString) {
    moneyname_ = new ::std::string;
  }
  return moneyname_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_moneyname() {
  clear_has_moneyname();
  if (moneyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moneyname_;
    moneyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FundOfExceptLock = 15;
inline bool INF_QueryFundCondition_Ack::has_fundofexceptlock() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_fundofexceptlock() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_QueryFundCondition_Ack::clear_has_fundofexceptlock() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_QueryFundCondition_Ack::clear_fundofexceptlock() {
  if (fundofexceptlock_ != &::google::protobuf::internal::kEmptyString) {
    fundofexceptlock_->clear();
  }
  clear_has_fundofexceptlock();
}
inline const ::std::string& INF_QueryFundCondition_Ack::fundofexceptlock() const {
  return *fundofexceptlock_;
}
inline void INF_QueryFundCondition_Ack::set_fundofexceptlock(const ::std::string& value) {
  set_has_fundofexceptlock();
  if (fundofexceptlock_ == &::google::protobuf::internal::kEmptyString) {
    fundofexceptlock_ = new ::std::string;
  }
  fundofexceptlock_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundofexceptlock(const char* value) {
  set_has_fundofexceptlock();
  if (fundofexceptlock_ == &::google::protobuf::internal::kEmptyString) {
    fundofexceptlock_ = new ::std::string;
  }
  fundofexceptlock_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_fundofexceptlock(const char* value, size_t size) {
  set_has_fundofexceptlock();
  if (fundofexceptlock_ == &::google::protobuf::internal::kEmptyString) {
    fundofexceptlock_ = new ::std::string;
  }
  fundofexceptlock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_fundofexceptlock() {
  set_has_fundofexceptlock();
  if (fundofexceptlock_ == &::google::protobuf::internal::kEmptyString) {
    fundofexceptlock_ = new ::std::string;
  }
  return fundofexceptlock_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_fundofexceptlock() {
  clear_has_fundofexceptlock();
  if (fundofexceptlock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fundofexceptlock_;
    fundofexceptlock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MoneyID = 16;
inline bool INF_QueryFundCondition_Ack::has_moneyid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_moneyid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_QueryFundCondition_Ack::clear_has_moneyid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_QueryFundCondition_Ack::clear_moneyid() {
  if (moneyid_ != &::google::protobuf::internal::kEmptyString) {
    moneyid_->clear();
  }
  clear_has_moneyid();
}
inline const ::std::string& INF_QueryFundCondition_Ack::moneyid() const {
  return *moneyid_;
}
inline void INF_QueryFundCondition_Ack::set_moneyid(const ::std::string& value) {
  set_has_moneyid();
  if (moneyid_ == &::google::protobuf::internal::kEmptyString) {
    moneyid_ = new ::std::string;
  }
  moneyid_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_moneyid(const char* value) {
  set_has_moneyid();
  if (moneyid_ == &::google::protobuf::internal::kEmptyString) {
    moneyid_ = new ::std::string;
  }
  moneyid_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_moneyid(const char* value, size_t size) {
  set_has_moneyid();
  if (moneyid_ == &::google::protobuf::internal::kEmptyString) {
    moneyid_ = new ::std::string;
  }
  moneyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_moneyid() {
  set_has_moneyid();
  if (moneyid_ == &::google::protobuf::internal::kEmptyString) {
    moneyid_ = new ::std::string;
  }
  return moneyid_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_moneyid() {
  clear_has_moneyid();
  if (moneyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moneyid_;
    moneyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PositionRate = 17;
inline bool INF_QueryFundCondition_Ack::has_positionrate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_positionrate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void INF_QueryFundCondition_Ack::clear_has_positionrate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void INF_QueryFundCondition_Ack::clear_positionrate() {
  if (positionrate_ != &::google::protobuf::internal::kEmptyString) {
    positionrate_->clear();
  }
  clear_has_positionrate();
}
inline const ::std::string& INF_QueryFundCondition_Ack::positionrate() const {
  return *positionrate_;
}
inline void INF_QueryFundCondition_Ack::set_positionrate(const ::std::string& value) {
  set_has_positionrate();
  if (positionrate_ == &::google::protobuf::internal::kEmptyString) {
    positionrate_ = new ::std::string;
  }
  positionrate_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_positionrate(const char* value) {
  set_has_positionrate();
  if (positionrate_ == &::google::protobuf::internal::kEmptyString) {
    positionrate_ = new ::std::string;
  }
  positionrate_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_positionrate(const char* value, size_t size) {
  set_has_positionrate();
  if (positionrate_ == &::google::protobuf::internal::kEmptyString) {
    positionrate_ = new ::std::string;
  }
  positionrate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_positionrate() {
  set_has_positionrate();
  if (positionrate_ == &::google::protobuf::internal::kEmptyString) {
    positionrate_ = new ::std::string;
  }
  return positionrate_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_positionrate() {
  clear_has_positionrate();
  if (positionrate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = positionrate_;
    positionrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string NetAssets = 18;
inline bool INF_QueryFundCondition_Ack::has_netassets() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void INF_QueryFundCondition_Ack::set_has_netassets() {
  _has_bits_[0] |= 0x00020000u;
}
inline void INF_QueryFundCondition_Ack::clear_has_netassets() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void INF_QueryFundCondition_Ack::clear_netassets() {
  if (netassets_ != &::google::protobuf::internal::kEmptyString) {
    netassets_->clear();
  }
  clear_has_netassets();
}
inline const ::std::string& INF_QueryFundCondition_Ack::netassets() const {
  return *netassets_;
}
inline void INF_QueryFundCondition_Ack::set_netassets(const ::std::string& value) {
  set_has_netassets();
  if (netassets_ == &::google::protobuf::internal::kEmptyString) {
    netassets_ = new ::std::string;
  }
  netassets_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_netassets(const char* value) {
  set_has_netassets();
  if (netassets_ == &::google::protobuf::internal::kEmptyString) {
    netassets_ = new ::std::string;
  }
  netassets_->assign(value);
}
inline void INF_QueryFundCondition_Ack::set_netassets(const char* value, size_t size) {
  set_has_netassets();
  if (netassets_ == &::google::protobuf::internal::kEmptyString) {
    netassets_ = new ::std::string;
  }
  netassets_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryFundCondition_Ack::mutable_netassets() {
  set_has_netassets();
  if (netassets_ == &::google::protobuf::internal::kEmptyString) {
    netassets_ = new ::std::string;
  }
  return netassets_;
}
inline ::std::string* INF_QueryFundCondition_Ack::release_netassets() {
  clear_has_netassets();
  if (netassets_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = netassets_;
    netassets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryPosition_Ack

// optional string MarketID = 1;
inline bool INF_QueryPosition_Ack::has_marketid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_marketid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryPosition_Ack::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryPosition_Ack::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_QueryPosition_Ack::marketid() const {
  return *marketid_;
}
inline void INF_QueryPosition_Ack::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryPosition_Ack::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryPosition_Ack::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_QueryPosition_Ack::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 2;
inline bool INF_QueryPosition_Ack::has_securitycode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_securitycode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryPosition_Ack::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryPosition_Ack::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_QueryPosition_Ack::securitycode() const {
  return *securitycode_;
}
inline void INF_QueryPosition_Ack::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryPosition_Ack::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryPosition_Ack::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_QueryPosition_Ack::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityName = 3;
inline bool INF_QueryPosition_Ack::has_securityname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_securityname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryPosition_Ack::clear_has_securityname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryPosition_Ack::clear_securityname() {
  if (securityname_ != &::google::protobuf::internal::kEmptyString) {
    securityname_->clear();
  }
  clear_has_securityname();
}
inline const ::std::string& INF_QueryPosition_Ack::securityname() const {
  return *securityname_;
}
inline void INF_QueryPosition_Ack::set_securityname(const ::std::string& value) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(value);
}
inline void INF_QueryPosition_Ack::set_securityname(const char* value) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(value);
}
inline void INF_QueryPosition_Ack::set_securityname(const char* value, size_t size) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_securityname() {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  return securityname_;
}
inline ::std::string* INF_QueryPosition_Ack::release_securityname() {
  clear_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securityname_;
    securityname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityNum = 4;
inline bool INF_QueryPosition_Ack::has_securitynum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_securitynum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryPosition_Ack::clear_has_securitynum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryPosition_Ack::clear_securitynum() {
  if (securitynum_ != &::google::protobuf::internal::kEmptyString) {
    securitynum_->clear();
  }
  clear_has_securitynum();
}
inline const ::std::string& INF_QueryPosition_Ack::securitynum() const {
  return *securitynum_;
}
inline void INF_QueryPosition_Ack::set_securitynum(const ::std::string& value) {
  set_has_securitynum();
  if (securitynum_ == &::google::protobuf::internal::kEmptyString) {
    securitynum_ = new ::std::string;
  }
  securitynum_->assign(value);
}
inline void INF_QueryPosition_Ack::set_securitynum(const char* value) {
  set_has_securitynum();
  if (securitynum_ == &::google::protobuf::internal::kEmptyString) {
    securitynum_ = new ::std::string;
  }
  securitynum_->assign(value);
}
inline void INF_QueryPosition_Ack::set_securitynum(const char* value, size_t size) {
  set_has_securitynum();
  if (securitynum_ == &::google::protobuf::internal::kEmptyString) {
    securitynum_ = new ::std::string;
  }
  securitynum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_securitynum() {
  set_has_securitynum();
  if (securitynum_ == &::google::protobuf::internal::kEmptyString) {
    securitynum_ = new ::std::string;
  }
  return securitynum_;
}
inline ::std::string* INF_QueryPosition_Ack::release_securitynum() {
  clear_has_securitynum();
  if (securitynum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitynum_;
    securitynum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MarketValue = 5;
inline bool INF_QueryPosition_Ack::has_marketvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_marketvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryPosition_Ack::clear_has_marketvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryPosition_Ack::clear_marketvalue() {
  if (marketvalue_ != &::google::protobuf::internal::kEmptyString) {
    marketvalue_->clear();
  }
  clear_has_marketvalue();
}
inline const ::std::string& INF_QueryPosition_Ack::marketvalue() const {
  return *marketvalue_;
}
inline void INF_QueryPosition_Ack::set_marketvalue(const ::std::string& value) {
  set_has_marketvalue();
  if (marketvalue_ == &::google::protobuf::internal::kEmptyString) {
    marketvalue_ = new ::std::string;
  }
  marketvalue_->assign(value);
}
inline void INF_QueryPosition_Ack::set_marketvalue(const char* value) {
  set_has_marketvalue();
  if (marketvalue_ == &::google::protobuf::internal::kEmptyString) {
    marketvalue_ = new ::std::string;
  }
  marketvalue_->assign(value);
}
inline void INF_QueryPosition_Ack::set_marketvalue(const char* value, size_t size) {
  set_has_marketvalue();
  if (marketvalue_ == &::google::protobuf::internal::kEmptyString) {
    marketvalue_ = new ::std::string;
  }
  marketvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_marketvalue() {
  set_has_marketvalue();
  if (marketvalue_ == &::google::protobuf::internal::kEmptyString) {
    marketvalue_ = new ::std::string;
  }
  return marketvalue_;
}
inline ::std::string* INF_QueryPosition_Ack::release_marketvalue() {
  clear_has_marketvalue();
  if (marketvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketvalue_;
    marketvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CostPrice = 6;
inline bool INF_QueryPosition_Ack::has_costprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_costprice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryPosition_Ack::clear_has_costprice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryPosition_Ack::clear_costprice() {
  if (costprice_ != &::google::protobuf::internal::kEmptyString) {
    costprice_->clear();
  }
  clear_has_costprice();
}
inline const ::std::string& INF_QueryPosition_Ack::costprice() const {
  return *costprice_;
}
inline void INF_QueryPosition_Ack::set_costprice(const ::std::string& value) {
  set_has_costprice();
  if (costprice_ == &::google::protobuf::internal::kEmptyString) {
    costprice_ = new ::std::string;
  }
  costprice_->assign(value);
}
inline void INF_QueryPosition_Ack::set_costprice(const char* value) {
  set_has_costprice();
  if (costprice_ == &::google::protobuf::internal::kEmptyString) {
    costprice_ = new ::std::string;
  }
  costprice_->assign(value);
}
inline void INF_QueryPosition_Ack::set_costprice(const char* value, size_t size) {
  set_has_costprice();
  if (costprice_ == &::google::protobuf::internal::kEmptyString) {
    costprice_ = new ::std::string;
  }
  costprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_costprice() {
  set_has_costprice();
  if (costprice_ == &::google::protobuf::internal::kEmptyString) {
    costprice_ = new ::std::string;
  }
  return costprice_;
}
inline ::std::string* INF_QueryPosition_Ack::release_costprice() {
  clear_has_costprice();
  if (costprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = costprice_;
    costprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string YesterdayPosition = 7;
inline bool INF_QueryPosition_Ack::has_yesterdayposition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_yesterdayposition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryPosition_Ack::clear_has_yesterdayposition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryPosition_Ack::clear_yesterdayposition() {
  if (yesterdayposition_ != &::google::protobuf::internal::kEmptyString) {
    yesterdayposition_->clear();
  }
  clear_has_yesterdayposition();
}
inline const ::std::string& INF_QueryPosition_Ack::yesterdayposition() const {
  return *yesterdayposition_;
}
inline void INF_QueryPosition_Ack::set_yesterdayposition(const ::std::string& value) {
  set_has_yesterdayposition();
  if (yesterdayposition_ == &::google::protobuf::internal::kEmptyString) {
    yesterdayposition_ = new ::std::string;
  }
  yesterdayposition_->assign(value);
}
inline void INF_QueryPosition_Ack::set_yesterdayposition(const char* value) {
  set_has_yesterdayposition();
  if (yesterdayposition_ == &::google::protobuf::internal::kEmptyString) {
    yesterdayposition_ = new ::std::string;
  }
  yesterdayposition_->assign(value);
}
inline void INF_QueryPosition_Ack::set_yesterdayposition(const char* value, size_t size) {
  set_has_yesterdayposition();
  if (yesterdayposition_ == &::google::protobuf::internal::kEmptyString) {
    yesterdayposition_ = new ::std::string;
  }
  yesterdayposition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_yesterdayposition() {
  set_has_yesterdayposition();
  if (yesterdayposition_ == &::google::protobuf::internal::kEmptyString) {
    yesterdayposition_ = new ::std::string;
  }
  return yesterdayposition_;
}
inline ::std::string* INF_QueryPosition_Ack::release_yesterdayposition() {
  clear_has_yesterdayposition();
  if (yesterdayposition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = yesterdayposition_;
    yesterdayposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ValidSecurityNum = 8;
inline bool INF_QueryPosition_Ack::has_validsecuritynum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_validsecuritynum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryPosition_Ack::clear_has_validsecuritynum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryPosition_Ack::clear_validsecuritynum() {
  if (validsecuritynum_ != &::google::protobuf::internal::kEmptyString) {
    validsecuritynum_->clear();
  }
  clear_has_validsecuritynum();
}
inline const ::std::string& INF_QueryPosition_Ack::validsecuritynum() const {
  return *validsecuritynum_;
}
inline void INF_QueryPosition_Ack::set_validsecuritynum(const ::std::string& value) {
  set_has_validsecuritynum();
  if (validsecuritynum_ == &::google::protobuf::internal::kEmptyString) {
    validsecuritynum_ = new ::std::string;
  }
  validsecuritynum_->assign(value);
}
inline void INF_QueryPosition_Ack::set_validsecuritynum(const char* value) {
  set_has_validsecuritynum();
  if (validsecuritynum_ == &::google::protobuf::internal::kEmptyString) {
    validsecuritynum_ = new ::std::string;
  }
  validsecuritynum_->assign(value);
}
inline void INF_QueryPosition_Ack::set_validsecuritynum(const char* value, size_t size) {
  set_has_validsecuritynum();
  if (validsecuritynum_ == &::google::protobuf::internal::kEmptyString) {
    validsecuritynum_ = new ::std::string;
  }
  validsecuritynum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_validsecuritynum() {
  set_has_validsecuritynum();
  if (validsecuritynum_ == &::google::protobuf::internal::kEmptyString) {
    validsecuritynum_ = new ::std::string;
  }
  return validsecuritynum_;
}
inline ::std::string* INF_QueryPosition_Ack::release_validsecuritynum() {
  clear_has_validsecuritynum();
  if (validsecuritynum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = validsecuritynum_;
    validsecuritynum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 9;
inline bool INF_QueryPosition_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryPosition_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryPosition_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_QueryPosition_Ack::respflag() const {
  return *respflag_;
}
inline void INF_QueryPosition_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryPosition_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryPosition_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_QueryPosition_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string StockholderAccount = 10;
inline bool INF_QueryPosition_Ack::has_stockholderaccount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_stockholderaccount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryPosition_Ack::clear_has_stockholderaccount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryPosition_Ack::clear_stockholderaccount() {
  if (stockholderaccount_ != &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_->clear();
  }
  clear_has_stockholderaccount();
}
inline const ::std::string& INF_QueryPosition_Ack::stockholderaccount() const {
  return *stockholderaccount_;
}
inline void INF_QueryPosition_Ack::set_stockholderaccount(const ::std::string& value) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(value);
}
inline void INF_QueryPosition_Ack::set_stockholderaccount(const char* value) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(value);
}
inline void INF_QueryPosition_Ack::set_stockholderaccount(const char* value, size_t size) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_stockholderaccount() {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  return stockholderaccount_;
}
inline ::std::string* INF_QueryPosition_Ack::release_stockholderaccount() {
  clear_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stockholderaccount_;
    stockholderaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FloatProfitLoss = 11;
inline bool INF_QueryPosition_Ack::has_floatprofitloss() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_floatprofitloss() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryPosition_Ack::clear_has_floatprofitloss() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryPosition_Ack::clear_floatprofitloss() {
  if (floatprofitloss_ != &::google::protobuf::internal::kEmptyString) {
    floatprofitloss_->clear();
  }
  clear_has_floatprofitloss();
}
inline const ::std::string& INF_QueryPosition_Ack::floatprofitloss() const {
  return *floatprofitloss_;
}
inline void INF_QueryPosition_Ack::set_floatprofitloss(const ::std::string& value) {
  set_has_floatprofitloss();
  if (floatprofitloss_ == &::google::protobuf::internal::kEmptyString) {
    floatprofitloss_ = new ::std::string;
  }
  floatprofitloss_->assign(value);
}
inline void INF_QueryPosition_Ack::set_floatprofitloss(const char* value) {
  set_has_floatprofitloss();
  if (floatprofitloss_ == &::google::protobuf::internal::kEmptyString) {
    floatprofitloss_ = new ::std::string;
  }
  floatprofitloss_->assign(value);
}
inline void INF_QueryPosition_Ack::set_floatprofitloss(const char* value, size_t size) {
  set_has_floatprofitloss();
  if (floatprofitloss_ == &::google::protobuf::internal::kEmptyString) {
    floatprofitloss_ = new ::std::string;
  }
  floatprofitloss_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_floatprofitloss() {
  set_has_floatprofitloss();
  if (floatprofitloss_ == &::google::protobuf::internal::kEmptyString) {
    floatprofitloss_ = new ::std::string;
  }
  return floatprofitloss_;
}
inline ::std::string* INF_QueryPosition_Ack::release_floatprofitloss() {
  clear_has_floatprofitloss();
  if (floatprofitloss_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = floatprofitloss_;
    floatprofitloss_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string LastestPrice = 12;
inline bool INF_QueryPosition_Ack::has_lastestprice() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_lastestprice() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryPosition_Ack::clear_has_lastestprice() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryPosition_Ack::clear_lastestprice() {
  if (lastestprice_ != &::google::protobuf::internal::kEmptyString) {
    lastestprice_->clear();
  }
  clear_has_lastestprice();
}
inline const ::std::string& INF_QueryPosition_Ack::lastestprice() const {
  return *lastestprice_;
}
inline void INF_QueryPosition_Ack::set_lastestprice(const ::std::string& value) {
  set_has_lastestprice();
  if (lastestprice_ == &::google::protobuf::internal::kEmptyString) {
    lastestprice_ = new ::std::string;
  }
  lastestprice_->assign(value);
}
inline void INF_QueryPosition_Ack::set_lastestprice(const char* value) {
  set_has_lastestprice();
  if (lastestprice_ == &::google::protobuf::internal::kEmptyString) {
    lastestprice_ = new ::std::string;
  }
  lastestprice_->assign(value);
}
inline void INF_QueryPosition_Ack::set_lastestprice(const char* value, size_t size) {
  set_has_lastestprice();
  if (lastestprice_ == &::google::protobuf::internal::kEmptyString) {
    lastestprice_ = new ::std::string;
  }
  lastestprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_lastestprice() {
  set_has_lastestprice();
  if (lastestprice_ == &::google::protobuf::internal::kEmptyString) {
    lastestprice_ = new ::std::string;
  }
  return lastestprice_;
}
inline ::std::string* INF_QueryPosition_Ack::release_lastestprice() {
  clear_has_lastestprice();
  if (lastestprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lastestprice_;
    lastestprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string StockMarketValue = 13;
inline bool INF_QueryPosition_Ack::has_stockmarketvalue() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_stockmarketvalue() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_QueryPosition_Ack::clear_has_stockmarketvalue() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_QueryPosition_Ack::clear_stockmarketvalue() {
  if (stockmarketvalue_ != &::google::protobuf::internal::kEmptyString) {
    stockmarketvalue_->clear();
  }
  clear_has_stockmarketvalue();
}
inline const ::std::string& INF_QueryPosition_Ack::stockmarketvalue() const {
  return *stockmarketvalue_;
}
inline void INF_QueryPosition_Ack::set_stockmarketvalue(const ::std::string& value) {
  set_has_stockmarketvalue();
  if (stockmarketvalue_ == &::google::protobuf::internal::kEmptyString) {
    stockmarketvalue_ = new ::std::string;
  }
  stockmarketvalue_->assign(value);
}
inline void INF_QueryPosition_Ack::set_stockmarketvalue(const char* value) {
  set_has_stockmarketvalue();
  if (stockmarketvalue_ == &::google::protobuf::internal::kEmptyString) {
    stockmarketvalue_ = new ::std::string;
  }
  stockmarketvalue_->assign(value);
}
inline void INF_QueryPosition_Ack::set_stockmarketvalue(const char* value, size_t size) {
  set_has_stockmarketvalue();
  if (stockmarketvalue_ == &::google::protobuf::internal::kEmptyString) {
    stockmarketvalue_ = new ::std::string;
  }
  stockmarketvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_stockmarketvalue() {
  set_has_stockmarketvalue();
  if (stockmarketvalue_ == &::google::protobuf::internal::kEmptyString) {
    stockmarketvalue_ = new ::std::string;
  }
  return stockmarketvalue_;
}
inline ::std::string* INF_QueryPosition_Ack::release_stockmarketvalue() {
  clear_has_stockmarketvalue();
  if (stockmarketvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stockmarketvalue_;
    stockmarketvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CommentDate = 14;
inline bool INF_QueryPosition_Ack::has_commentdate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_commentdate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_QueryPosition_Ack::clear_has_commentdate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_QueryPosition_Ack::clear_commentdate() {
  if (commentdate_ != &::google::protobuf::internal::kEmptyString) {
    commentdate_->clear();
  }
  clear_has_commentdate();
}
inline const ::std::string& INF_QueryPosition_Ack::commentdate() const {
  return *commentdate_;
}
inline void INF_QueryPosition_Ack::set_commentdate(const ::std::string& value) {
  set_has_commentdate();
  if (commentdate_ == &::google::protobuf::internal::kEmptyString) {
    commentdate_ = new ::std::string;
  }
  commentdate_->assign(value);
}
inline void INF_QueryPosition_Ack::set_commentdate(const char* value) {
  set_has_commentdate();
  if (commentdate_ == &::google::protobuf::internal::kEmptyString) {
    commentdate_ = new ::std::string;
  }
  commentdate_->assign(value);
}
inline void INF_QueryPosition_Ack::set_commentdate(const char* value, size_t size) {
  set_has_commentdate();
  if (commentdate_ == &::google::protobuf::internal::kEmptyString) {
    commentdate_ = new ::std::string;
  }
  commentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_commentdate() {
  set_has_commentdate();
  if (commentdate_ == &::google::protobuf::internal::kEmptyString) {
    commentdate_ = new ::std::string;
  }
  return commentdate_;
}
inline ::std::string* INF_QueryPosition_Ack::release_commentdate() {
  clear_has_commentdate();
  if (commentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commentdate_;
    commentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SentenceCommentMsg = 15;
inline bool INF_QueryPosition_Ack::has_sentencecommentmsg() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_sentencecommentmsg() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_QueryPosition_Ack::clear_has_sentencecommentmsg() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_QueryPosition_Ack::clear_sentencecommentmsg() {
  if (sentencecommentmsg_ != &::google::protobuf::internal::kEmptyString) {
    sentencecommentmsg_->clear();
  }
  clear_has_sentencecommentmsg();
}
inline const ::std::string& INF_QueryPosition_Ack::sentencecommentmsg() const {
  return *sentencecommentmsg_;
}
inline void INF_QueryPosition_Ack::set_sentencecommentmsg(const ::std::string& value) {
  set_has_sentencecommentmsg();
  if (sentencecommentmsg_ == &::google::protobuf::internal::kEmptyString) {
    sentencecommentmsg_ = new ::std::string;
  }
  sentencecommentmsg_->assign(value);
}
inline void INF_QueryPosition_Ack::set_sentencecommentmsg(const char* value) {
  set_has_sentencecommentmsg();
  if (sentencecommentmsg_ == &::google::protobuf::internal::kEmptyString) {
    sentencecommentmsg_ = new ::std::string;
  }
  sentencecommentmsg_->assign(value);
}
inline void INF_QueryPosition_Ack::set_sentencecommentmsg(const char* value, size_t size) {
  set_has_sentencecommentmsg();
  if (sentencecommentmsg_ == &::google::protobuf::internal::kEmptyString) {
    sentencecommentmsg_ = new ::std::string;
  }
  sentencecommentmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_sentencecommentmsg() {
  set_has_sentencecommentmsg();
  if (sentencecommentmsg_ == &::google::protobuf::internal::kEmptyString) {
    sentencecommentmsg_ = new ::std::string;
  }
  return sentencecommentmsg_;
}
inline ::std::string* INF_QueryPosition_Ack::release_sentencecommentmsg() {
  clear_has_sentencecommentmsg();
  if (sentencecommentmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sentencecommentmsg_;
    sentencecommentmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string NationalDebtNetPrice = 16;
inline bool INF_QueryPosition_Ack::has_nationaldebtnetprice() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_nationaldebtnetprice() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_QueryPosition_Ack::clear_has_nationaldebtnetprice() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_QueryPosition_Ack::clear_nationaldebtnetprice() {
  if (nationaldebtnetprice_ != &::google::protobuf::internal::kEmptyString) {
    nationaldebtnetprice_->clear();
  }
  clear_has_nationaldebtnetprice();
}
inline const ::std::string& INF_QueryPosition_Ack::nationaldebtnetprice() const {
  return *nationaldebtnetprice_;
}
inline void INF_QueryPosition_Ack::set_nationaldebtnetprice(const ::std::string& value) {
  set_has_nationaldebtnetprice();
  if (nationaldebtnetprice_ == &::google::protobuf::internal::kEmptyString) {
    nationaldebtnetprice_ = new ::std::string;
  }
  nationaldebtnetprice_->assign(value);
}
inline void INF_QueryPosition_Ack::set_nationaldebtnetprice(const char* value) {
  set_has_nationaldebtnetprice();
  if (nationaldebtnetprice_ == &::google::protobuf::internal::kEmptyString) {
    nationaldebtnetprice_ = new ::std::string;
  }
  nationaldebtnetprice_->assign(value);
}
inline void INF_QueryPosition_Ack::set_nationaldebtnetprice(const char* value, size_t size) {
  set_has_nationaldebtnetprice();
  if (nationaldebtnetprice_ == &::google::protobuf::internal::kEmptyString) {
    nationaldebtnetprice_ = new ::std::string;
  }
  nationaldebtnetprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_nationaldebtnetprice() {
  set_has_nationaldebtnetprice();
  if (nationaldebtnetprice_ == &::google::protobuf::internal::kEmptyString) {
    nationaldebtnetprice_ = new ::std::string;
  }
  return nationaldebtnetprice_;
}
inline ::std::string* INF_QueryPosition_Ack::release_nationaldebtnetprice() {
  clear_has_nationaldebtnetprice();
  if (nationaldebtnetprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nationaldebtnetprice_;
    nationaldebtnetprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Interest = 17;
inline bool INF_QueryPosition_Ack::has_interest() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_interest() {
  _has_bits_[0] |= 0x00010000u;
}
inline void INF_QueryPosition_Ack::clear_has_interest() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void INF_QueryPosition_Ack::clear_interest() {
  if (interest_ != &::google::protobuf::internal::kEmptyString) {
    interest_->clear();
  }
  clear_has_interest();
}
inline const ::std::string& INF_QueryPosition_Ack::interest() const {
  return *interest_;
}
inline void INF_QueryPosition_Ack::set_interest(const ::std::string& value) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::kEmptyString) {
    interest_ = new ::std::string;
  }
  interest_->assign(value);
}
inline void INF_QueryPosition_Ack::set_interest(const char* value) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::kEmptyString) {
    interest_ = new ::std::string;
  }
  interest_->assign(value);
}
inline void INF_QueryPosition_Ack::set_interest(const char* value, size_t size) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::kEmptyString) {
    interest_ = new ::std::string;
  }
  interest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_interest() {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::kEmptyString) {
    interest_ = new ::std::string;
  }
  return interest_;
}
inline ::std::string* INF_QueryPosition_Ack::release_interest() {
  clear_has_interest();
  if (interest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = interest_;
    interest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string AverageBuyPrice = 18;
inline bool INF_QueryPosition_Ack::has_averagebuyprice() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_averagebuyprice() {
  _has_bits_[0] |= 0x00020000u;
}
inline void INF_QueryPosition_Ack::clear_has_averagebuyprice() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void INF_QueryPosition_Ack::clear_averagebuyprice() {
  if (averagebuyprice_ != &::google::protobuf::internal::kEmptyString) {
    averagebuyprice_->clear();
  }
  clear_has_averagebuyprice();
}
inline const ::std::string& INF_QueryPosition_Ack::averagebuyprice() const {
  return *averagebuyprice_;
}
inline void INF_QueryPosition_Ack::set_averagebuyprice(const ::std::string& value) {
  set_has_averagebuyprice();
  if (averagebuyprice_ == &::google::protobuf::internal::kEmptyString) {
    averagebuyprice_ = new ::std::string;
  }
  averagebuyprice_->assign(value);
}
inline void INF_QueryPosition_Ack::set_averagebuyprice(const char* value) {
  set_has_averagebuyprice();
  if (averagebuyprice_ == &::google::protobuf::internal::kEmptyString) {
    averagebuyprice_ = new ::std::string;
  }
  averagebuyprice_->assign(value);
}
inline void INF_QueryPosition_Ack::set_averagebuyprice(const char* value, size_t size) {
  set_has_averagebuyprice();
  if (averagebuyprice_ == &::google::protobuf::internal::kEmptyString) {
    averagebuyprice_ = new ::std::string;
  }
  averagebuyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_averagebuyprice() {
  set_has_averagebuyprice();
  if (averagebuyprice_ == &::google::protobuf::internal::kEmptyString) {
    averagebuyprice_ = new ::std::string;
  }
  return averagebuyprice_;
}
inline ::std::string* INF_QueryPosition_Ack::release_averagebuyprice() {
  clear_has_averagebuyprice();
  if (averagebuyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = averagebuyprice_;
    averagebuyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string LiquidCostPrice = 19;
inline bool INF_QueryPosition_Ack::has_liquidcostprice() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_liquidcostprice() {
  _has_bits_[0] |= 0x00040000u;
}
inline void INF_QueryPosition_Ack::clear_has_liquidcostprice() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void INF_QueryPosition_Ack::clear_liquidcostprice() {
  if (liquidcostprice_ != &::google::protobuf::internal::kEmptyString) {
    liquidcostprice_->clear();
  }
  clear_has_liquidcostprice();
}
inline const ::std::string& INF_QueryPosition_Ack::liquidcostprice() const {
  return *liquidcostprice_;
}
inline void INF_QueryPosition_Ack::set_liquidcostprice(const ::std::string& value) {
  set_has_liquidcostprice();
  if (liquidcostprice_ == &::google::protobuf::internal::kEmptyString) {
    liquidcostprice_ = new ::std::string;
  }
  liquidcostprice_->assign(value);
}
inline void INF_QueryPosition_Ack::set_liquidcostprice(const char* value) {
  set_has_liquidcostprice();
  if (liquidcostprice_ == &::google::protobuf::internal::kEmptyString) {
    liquidcostprice_ = new ::std::string;
  }
  liquidcostprice_->assign(value);
}
inline void INF_QueryPosition_Ack::set_liquidcostprice(const char* value, size_t size) {
  set_has_liquidcostprice();
  if (liquidcostprice_ == &::google::protobuf::internal::kEmptyString) {
    liquidcostprice_ = new ::std::string;
  }
  liquidcostprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_liquidcostprice() {
  set_has_liquidcostprice();
  if (liquidcostprice_ == &::google::protobuf::internal::kEmptyString) {
    liquidcostprice_ = new ::std::string;
  }
  return liquidcostprice_;
}
inline ::std::string* INF_QueryPosition_Ack::release_liquidcostprice() {
  clear_has_liquidcostprice();
  if (liquidcostprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = liquidcostprice_;
    liquidcostprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BeginStock = 20;
inline bool INF_QueryPosition_Ack::has_beginstock() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_beginstock() {
  _has_bits_[0] |= 0x00080000u;
}
inline void INF_QueryPosition_Ack::clear_has_beginstock() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void INF_QueryPosition_Ack::clear_beginstock() {
  if (beginstock_ != &::google::protobuf::internal::kEmptyString) {
    beginstock_->clear();
  }
  clear_has_beginstock();
}
inline const ::std::string& INF_QueryPosition_Ack::beginstock() const {
  return *beginstock_;
}
inline void INF_QueryPosition_Ack::set_beginstock(const ::std::string& value) {
  set_has_beginstock();
  if (beginstock_ == &::google::protobuf::internal::kEmptyString) {
    beginstock_ = new ::std::string;
  }
  beginstock_->assign(value);
}
inline void INF_QueryPosition_Ack::set_beginstock(const char* value) {
  set_has_beginstock();
  if (beginstock_ == &::google::protobuf::internal::kEmptyString) {
    beginstock_ = new ::std::string;
  }
  beginstock_->assign(value);
}
inline void INF_QueryPosition_Ack::set_beginstock(const char* value, size_t size) {
  set_has_beginstock();
  if (beginstock_ == &::google::protobuf::internal::kEmptyString) {
    beginstock_ = new ::std::string;
  }
  beginstock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_beginstock() {
  set_has_beginstock();
  if (beginstock_ == &::google::protobuf::internal::kEmptyString) {
    beginstock_ = new ::std::string;
  }
  return beginstock_;
}
inline ::std::string* INF_QueryPosition_Ack::release_beginstock() {
  clear_has_beginstock();
  if (beginstock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beginstock_;
    beginstock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OverPositionBalances = 21;
inline bool INF_QueryPosition_Ack::has_overpositionbalances() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void INF_QueryPosition_Ack::set_has_overpositionbalances() {
  _has_bits_[0] |= 0x00100000u;
}
inline void INF_QueryPosition_Ack::clear_has_overpositionbalances() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void INF_QueryPosition_Ack::clear_overpositionbalances() {
  if (overpositionbalances_ != &::google::protobuf::internal::kEmptyString) {
    overpositionbalances_->clear();
  }
  clear_has_overpositionbalances();
}
inline const ::std::string& INF_QueryPosition_Ack::overpositionbalances() const {
  return *overpositionbalances_;
}
inline void INF_QueryPosition_Ack::set_overpositionbalances(const ::std::string& value) {
  set_has_overpositionbalances();
  if (overpositionbalances_ == &::google::protobuf::internal::kEmptyString) {
    overpositionbalances_ = new ::std::string;
  }
  overpositionbalances_->assign(value);
}
inline void INF_QueryPosition_Ack::set_overpositionbalances(const char* value) {
  set_has_overpositionbalances();
  if (overpositionbalances_ == &::google::protobuf::internal::kEmptyString) {
    overpositionbalances_ = new ::std::string;
  }
  overpositionbalances_->assign(value);
}
inline void INF_QueryPosition_Ack::set_overpositionbalances(const char* value, size_t size) {
  set_has_overpositionbalances();
  if (overpositionbalances_ == &::google::protobuf::internal::kEmptyString) {
    overpositionbalances_ = new ::std::string;
  }
  overpositionbalances_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryPosition_Ack::mutable_overpositionbalances() {
  set_has_overpositionbalances();
  if (overpositionbalances_ == &::google::protobuf::internal::kEmptyString) {
    overpositionbalances_ = new ::std::string;
  }
  return overpositionbalances_;
}
inline ::std::string* INF_QueryPosition_Ack::release_overpositionbalances() {
  clear_has_overpositionbalances();
  if (overpositionbalances_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = overpositionbalances_;
    overpositionbalances_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_QueryCJMX_Ack

// optional string MarketID = 1;
inline bool INF_QueryCJMX_Ack::has_marketid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_marketid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_QueryCJMX_Ack::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_QueryCJMX_Ack::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& INF_QueryCJMX_Ack::marketid() const {
  return *marketid_;
}
inline void INF_QueryCJMX_Ack::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BSflag = 2;
inline bool INF_QueryCJMX_Ack::has_bsflag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_bsflag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_QueryCJMX_Ack::clear_has_bsflag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_QueryCJMX_Ack::clear_bsflag() {
  if (bsflag_ != &::google::protobuf::internal::kEmptyString) {
    bsflag_->clear();
  }
  clear_has_bsflag();
}
inline const ::std::string& INF_QueryCJMX_Ack::bsflag() const {
  return *bsflag_;
}
inline void INF_QueryCJMX_Ack::set_bsflag(const ::std::string& value) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_bsflag(const char* value) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_bsflag(const char* value, size_t size) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_bsflag() {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  return bsflag_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_bsflag() {
  clear_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bsflag_;
    bsflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjType = 3;
inline bool INF_QueryCJMX_Ack::has_cjtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_cjtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_QueryCJMX_Ack::clear_has_cjtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_QueryCJMX_Ack::clear_cjtype() {
  if (cjtype_ != &::google::protobuf::internal::kEmptyString) {
    cjtype_->clear();
  }
  clear_has_cjtype();
}
inline const ::std::string& INF_QueryCJMX_Ack::cjtype() const {
  return *cjtype_;
}
inline void INF_QueryCJMX_Ack::set_cjtype(const ::std::string& value) {
  set_has_cjtype();
  if (cjtype_ == &::google::protobuf::internal::kEmptyString) {
    cjtype_ = new ::std::string;
  }
  cjtype_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjtype(const char* value) {
  set_has_cjtype();
  if (cjtype_ == &::google::protobuf::internal::kEmptyString) {
    cjtype_ = new ::std::string;
  }
  cjtype_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjtype(const char* value, size_t size) {
  set_has_cjtype();
  if (cjtype_ == &::google::protobuf::internal::kEmptyString) {
    cjtype_ = new ::std::string;
  }
  cjtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_cjtype() {
  set_has_cjtype();
  if (cjtype_ == &::google::protobuf::internal::kEmptyString) {
    cjtype_ = new ::std::string;
  }
  return cjtype_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_cjtype() {
  clear_has_cjtype();
  if (cjtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjtype_;
    cjtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityCode = 4;
inline bool INF_QueryCJMX_Ack::has_securitycode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_securitycode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_QueryCJMX_Ack::clear_has_securitycode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_QueryCJMX_Ack::clear_securitycode() {
  if (securitycode_ != &::google::protobuf::internal::kEmptyString) {
    securitycode_->clear();
  }
  clear_has_securitycode();
}
inline const ::std::string& INF_QueryCJMX_Ack::securitycode() const {
  return *securitycode_;
}
inline void INF_QueryCJMX_Ack::set_securitycode(const ::std::string& value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_securitycode(const char* value) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_securitycode(const char* value, size_t size) {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  securitycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_securitycode() {
  set_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    securitycode_ = new ::std::string;
  }
  return securitycode_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_securitycode() {
  clear_has_securitycode();
  if (securitycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitycode_;
    securitycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityName = 5;
inline bool INF_QueryCJMX_Ack::has_securityname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_securityname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_QueryCJMX_Ack::clear_has_securityname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_QueryCJMX_Ack::clear_securityname() {
  if (securityname_ != &::google::protobuf::internal::kEmptyString) {
    securityname_->clear();
  }
  clear_has_securityname();
}
inline const ::std::string& INF_QueryCJMX_Ack::securityname() const {
  return *securityname_;
}
inline void INF_QueryCJMX_Ack::set_securityname(const ::std::string& value) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_securityname(const char* value) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_securityname(const char* value, size_t size) {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  securityname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_securityname() {
  set_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    securityname_ = new ::std::string;
  }
  return securityname_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_securityname() {
  clear_has_securityname();
  if (securityname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securityname_;
    securityname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjNum = 6;
inline bool INF_QueryCJMX_Ack::has_cjnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_cjnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_QueryCJMX_Ack::clear_has_cjnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_QueryCJMX_Ack::clear_cjnum() {
  if (cjnum_ != &::google::protobuf::internal::kEmptyString) {
    cjnum_->clear();
  }
  clear_has_cjnum();
}
inline const ::std::string& INF_QueryCJMX_Ack::cjnum() const {
  return *cjnum_;
}
inline void INF_QueryCJMX_Ack::set_cjnum(const ::std::string& value) {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  cjnum_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjnum(const char* value) {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  cjnum_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjnum(const char* value, size_t size) {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  cjnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_cjnum() {
  set_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    cjnum_ = new ::std::string;
  }
  return cjnum_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_cjnum() {
  clear_has_cjnum();
  if (cjnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjnum_;
    cjnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjPrice = 7;
inline bool INF_QueryCJMX_Ack::has_cjprice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_cjprice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_QueryCJMX_Ack::clear_has_cjprice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_QueryCJMX_Ack::clear_cjprice() {
  if (cjprice_ != &::google::protobuf::internal::kEmptyString) {
    cjprice_->clear();
  }
  clear_has_cjprice();
}
inline const ::std::string& INF_QueryCJMX_Ack::cjprice() const {
  return *cjprice_;
}
inline void INF_QueryCJMX_Ack::set_cjprice(const ::std::string& value) {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  cjprice_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjprice(const char* value) {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  cjprice_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjprice(const char* value, size_t size) {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  cjprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_cjprice() {
  set_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    cjprice_ = new ::std::string;
  }
  return cjprice_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_cjprice() {
  clear_has_cjprice();
  if (cjprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjprice_;
    cjprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjFund = 8;
inline bool INF_QueryCJMX_Ack::has_cjfund() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_cjfund() {
  _has_bits_[0] |= 0x00000080u;
}
inline void INF_QueryCJMX_Ack::clear_has_cjfund() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void INF_QueryCJMX_Ack::clear_cjfund() {
  if (cjfund_ != &::google::protobuf::internal::kEmptyString) {
    cjfund_->clear();
  }
  clear_has_cjfund();
}
inline const ::std::string& INF_QueryCJMX_Ack::cjfund() const {
  return *cjfund_;
}
inline void INF_QueryCJMX_Ack::set_cjfund(const ::std::string& value) {
  set_has_cjfund();
  if (cjfund_ == &::google::protobuf::internal::kEmptyString) {
    cjfund_ = new ::std::string;
  }
  cjfund_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjfund(const char* value) {
  set_has_cjfund();
  if (cjfund_ == &::google::protobuf::internal::kEmptyString) {
    cjfund_ = new ::std::string;
  }
  cjfund_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjfund(const char* value, size_t size) {
  set_has_cjfund();
  if (cjfund_ == &::google::protobuf::internal::kEmptyString) {
    cjfund_ = new ::std::string;
  }
  cjfund_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_cjfund() {
  set_has_cjfund();
  if (cjfund_ == &::google::protobuf::internal::kEmptyString) {
    cjfund_ = new ::std::string;
  }
  return cjfund_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_cjfund() {
  clear_has_cjfund();
  if (cjfund_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjfund_;
    cjfund_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustSerial = 9;
inline bool INF_QueryCJMX_Ack::has_entrustserial() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_entrustserial() {
  _has_bits_[0] |= 0x00000100u;
}
inline void INF_QueryCJMX_Ack::clear_has_entrustserial() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void INF_QueryCJMX_Ack::clear_entrustserial() {
  if (entrustserial_ != &::google::protobuf::internal::kEmptyString) {
    entrustserial_->clear();
  }
  clear_has_entrustserial();
}
inline const ::std::string& INF_QueryCJMX_Ack::entrustserial() const {
  return *entrustserial_;
}
inline void INF_QueryCJMX_Ack::set_entrustserial(const ::std::string& value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_entrustserial(const char* value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_entrustserial(const char* value, size_t size) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_entrustserial() {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  return entrustserial_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_entrustserial() {
  clear_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustserial_;
    entrustserial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjDate = 10;
inline bool INF_QueryCJMX_Ack::has_cjdate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_cjdate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void INF_QueryCJMX_Ack::clear_has_cjdate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void INF_QueryCJMX_Ack::clear_cjdate() {
  if (cjdate_ != &::google::protobuf::internal::kEmptyString) {
    cjdate_->clear();
  }
  clear_has_cjdate();
}
inline const ::std::string& INF_QueryCJMX_Ack::cjdate() const {
  return *cjdate_;
}
inline void INF_QueryCJMX_Ack::set_cjdate(const ::std::string& value) {
  set_has_cjdate();
  if (cjdate_ == &::google::protobuf::internal::kEmptyString) {
    cjdate_ = new ::std::string;
  }
  cjdate_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjdate(const char* value) {
  set_has_cjdate();
  if (cjdate_ == &::google::protobuf::internal::kEmptyString) {
    cjdate_ = new ::std::string;
  }
  cjdate_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjdate(const char* value, size_t size) {
  set_has_cjdate();
  if (cjdate_ == &::google::protobuf::internal::kEmptyString) {
    cjdate_ = new ::std::string;
  }
  cjdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_cjdate() {
  set_has_cjdate();
  if (cjdate_ == &::google::protobuf::internal::kEmptyString) {
    cjdate_ = new ::std::string;
  }
  return cjdate_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_cjdate() {
  clear_has_cjdate();
  if (cjdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjdate_;
    cjdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PageStartPos = 11;
inline bool INF_QueryCJMX_Ack::has_pagestartpos() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_pagestartpos() {
  _has_bits_[0] |= 0x00000400u;
}
inline void INF_QueryCJMX_Ack::clear_has_pagestartpos() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void INF_QueryCJMX_Ack::clear_pagestartpos() {
  if (pagestartpos_ != &::google::protobuf::internal::kEmptyString) {
    pagestartpos_->clear();
  }
  clear_has_pagestartpos();
}
inline const ::std::string& INF_QueryCJMX_Ack::pagestartpos() const {
  return *pagestartpos_;
}
inline void INF_QueryCJMX_Ack::set_pagestartpos(const ::std::string& value) {
  set_has_pagestartpos();
  if (pagestartpos_ == &::google::protobuf::internal::kEmptyString) {
    pagestartpos_ = new ::std::string;
  }
  pagestartpos_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_pagestartpos(const char* value) {
  set_has_pagestartpos();
  if (pagestartpos_ == &::google::protobuf::internal::kEmptyString) {
    pagestartpos_ = new ::std::string;
  }
  pagestartpos_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_pagestartpos(const char* value, size_t size) {
  set_has_pagestartpos();
  if (pagestartpos_ == &::google::protobuf::internal::kEmptyString) {
    pagestartpos_ = new ::std::string;
  }
  pagestartpos_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_pagestartpos() {
  set_has_pagestartpos();
  if (pagestartpos_ == &::google::protobuf::internal::kEmptyString) {
    pagestartpos_ = new ::std::string;
  }
  return pagestartpos_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_pagestartpos() {
  clear_has_pagestartpos();
  if (pagestartpos_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pagestartpos_;
    pagestartpos_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjSerial = 12;
inline bool INF_QueryCJMX_Ack::has_cjserial() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_cjserial() {
  _has_bits_[0] |= 0x00000800u;
}
inline void INF_QueryCJMX_Ack::clear_has_cjserial() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void INF_QueryCJMX_Ack::clear_cjserial() {
  if (cjserial_ != &::google::protobuf::internal::kEmptyString) {
    cjserial_->clear();
  }
  clear_has_cjserial();
}
inline const ::std::string& INF_QueryCJMX_Ack::cjserial() const {
  return *cjserial_;
}
inline void INF_QueryCJMX_Ack::set_cjserial(const ::std::string& value) {
  set_has_cjserial();
  if (cjserial_ == &::google::protobuf::internal::kEmptyString) {
    cjserial_ = new ::std::string;
  }
  cjserial_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjserial(const char* value) {
  set_has_cjserial();
  if (cjserial_ == &::google::protobuf::internal::kEmptyString) {
    cjserial_ = new ::std::string;
  }
  cjserial_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjserial(const char* value, size_t size) {
  set_has_cjserial();
  if (cjserial_ == &::google::protobuf::internal::kEmptyString) {
    cjserial_ = new ::std::string;
  }
  cjserial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_cjserial() {
  set_has_cjserial();
  if (cjserial_ == &::google::protobuf::internal::kEmptyString) {
    cjserial_ = new ::std::string;
  }
  return cjserial_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_cjserial() {
  clear_has_cjserial();
  if (cjserial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjserial_;
    cjserial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Valid = 13;
inline bool INF_QueryCJMX_Ack::has_valid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_valid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void INF_QueryCJMX_Ack::clear_has_valid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void INF_QueryCJMX_Ack::clear_valid() {
  if (valid_ != &::google::protobuf::internal::kEmptyString) {
    valid_->clear();
  }
  clear_has_valid();
}
inline const ::std::string& INF_QueryCJMX_Ack::valid() const {
  return *valid_;
}
inline void INF_QueryCJMX_Ack::set_valid(const ::std::string& value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_valid(const char* value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_valid(const char* value, size_t size) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_valid() {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  return valid_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_valid() {
  clear_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_;
    valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 14;
inline bool INF_QueryCJMX_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00002000u;
}
inline void INF_QueryCJMX_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void INF_QueryCJMX_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_QueryCJMX_Ack::respflag() const {
  return *respflag_;
}
inline void INF_QueryCJMX_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Date = 15;
inline bool INF_QueryCJMX_Ack::has_date() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_date() {
  _has_bits_[0] |= 0x00004000u;
}
inline void INF_QueryCJMX_Ack::clear_has_date() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void INF_QueryCJMX_Ack::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& INF_QueryCJMX_Ack::date() const {
  return *date_;
}
inline void INF_QueryCJMX_Ack::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SerialNo = 16;
inline bool INF_QueryCJMX_Ack::has_serialno() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_serialno() {
  _has_bits_[0] |= 0x00008000u;
}
inline void INF_QueryCJMX_Ack::clear_has_serialno() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void INF_QueryCJMX_Ack::clear_serialno() {
  if (serialno_ != &::google::protobuf::internal::kEmptyString) {
    serialno_->clear();
  }
  clear_has_serialno();
}
inline const ::std::string& INF_QueryCJMX_Ack::serialno() const {
  return *serialno_;
}
inline void INF_QueryCJMX_Ack::set_serialno(const ::std::string& value) {
  set_has_serialno();
  if (serialno_ == &::google::protobuf::internal::kEmptyString) {
    serialno_ = new ::std::string;
  }
  serialno_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_serialno(const char* value) {
  set_has_serialno();
  if (serialno_ == &::google::protobuf::internal::kEmptyString) {
    serialno_ = new ::std::string;
  }
  serialno_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_serialno(const char* value, size_t size) {
  set_has_serialno();
  if (serialno_ == &::google::protobuf::internal::kEmptyString) {
    serialno_ = new ::std::string;
  }
  serialno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_serialno() {
  set_has_serialno();
  if (serialno_ == &::google::protobuf::internal::kEmptyString) {
    serialno_ = new ::std::string;
  }
  return serialno_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_serialno() {
  clear_has_serialno();
  if (serialno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialno_;
    serialno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string StockholderAccount = 17;
inline bool INF_QueryCJMX_Ack::has_stockholderaccount() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_stockholderaccount() {
  _has_bits_[0] |= 0x00010000u;
}
inline void INF_QueryCJMX_Ack::clear_has_stockholderaccount() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void INF_QueryCJMX_Ack::clear_stockholderaccount() {
  if (stockholderaccount_ != &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_->clear();
  }
  clear_has_stockholderaccount();
}
inline const ::std::string& INF_QueryCJMX_Ack::stockholderaccount() const {
  return *stockholderaccount_;
}
inline void INF_QueryCJMX_Ack::set_stockholderaccount(const ::std::string& value) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_stockholderaccount(const char* value) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_stockholderaccount(const char* value, size_t size) {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  stockholderaccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_stockholderaccount() {
  set_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    stockholderaccount_ = new ::std::string;
  }
  return stockholderaccount_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_stockholderaccount() {
  clear_has_stockholderaccount();
  if (stockholderaccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stockholderaccount_;
    stockholderaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BSName = 18;
inline bool INF_QueryCJMX_Ack::has_bsname() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_bsname() {
  _has_bits_[0] |= 0x00020000u;
}
inline void INF_QueryCJMX_Ack::clear_has_bsname() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void INF_QueryCJMX_Ack::clear_bsname() {
  if (bsname_ != &::google::protobuf::internal::kEmptyString) {
    bsname_->clear();
  }
  clear_has_bsname();
}
inline const ::std::string& INF_QueryCJMX_Ack::bsname() const {
  return *bsname_;
}
inline void INF_QueryCJMX_Ack::set_bsname(const ::std::string& value) {
  set_has_bsname();
  if (bsname_ == &::google::protobuf::internal::kEmptyString) {
    bsname_ = new ::std::string;
  }
  bsname_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_bsname(const char* value) {
  set_has_bsname();
  if (bsname_ == &::google::protobuf::internal::kEmptyString) {
    bsname_ = new ::std::string;
  }
  bsname_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_bsname(const char* value, size_t size) {
  set_has_bsname();
  if (bsname_ == &::google::protobuf::internal::kEmptyString) {
    bsname_ = new ::std::string;
  }
  bsname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_bsname() {
  set_has_bsname();
  if (bsname_ == &::google::protobuf::internal::kEmptyString) {
    bsname_ = new ::std::string;
  }
  return bsname_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_bsname() {
  clear_has_bsname();
  if (bsname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bsname_;
    bsname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjTypeName = 19;
inline bool INF_QueryCJMX_Ack::has_cjtypename() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_cjtypename() {
  _has_bits_[0] |= 0x00040000u;
}
inline void INF_QueryCJMX_Ack::clear_has_cjtypename() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void INF_QueryCJMX_Ack::clear_cjtypename() {
  if (cjtypename_ != &::google::protobuf::internal::kEmptyString) {
    cjtypename_->clear();
  }
  clear_has_cjtypename();
}
inline const ::std::string& INF_QueryCJMX_Ack::cjtypename() const {
  return *cjtypename_;
}
inline void INF_QueryCJMX_Ack::set_cjtypename(const ::std::string& value) {
  set_has_cjtypename();
  if (cjtypename_ == &::google::protobuf::internal::kEmptyString) {
    cjtypename_ = new ::std::string;
  }
  cjtypename_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjtypename(const char* value) {
  set_has_cjtypename();
  if (cjtypename_ == &::google::protobuf::internal::kEmptyString) {
    cjtypename_ = new ::std::string;
  }
  cjtypename_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjtypename(const char* value, size_t size) {
  set_has_cjtypename();
  if (cjtypename_ == &::google::protobuf::internal::kEmptyString) {
    cjtypename_ = new ::std::string;
  }
  cjtypename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_cjtypename() {
  set_has_cjtypename();
  if (cjtypename_ == &::google::protobuf::internal::kEmptyString) {
    cjtypename_ = new ::std::string;
  }
  return cjtypename_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_cjtypename() {
  clear_has_cjtypename();
  if (cjtypename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjtypename_;
    cjtypename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjPenNum = 20;
inline bool INF_QueryCJMX_Ack::has_cjpennum() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_cjpennum() {
  _has_bits_[0] |= 0x00080000u;
}
inline void INF_QueryCJMX_Ack::clear_has_cjpennum() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void INF_QueryCJMX_Ack::clear_cjpennum() {
  if (cjpennum_ != &::google::protobuf::internal::kEmptyString) {
    cjpennum_->clear();
  }
  clear_has_cjpennum();
}
inline const ::std::string& INF_QueryCJMX_Ack::cjpennum() const {
  return *cjpennum_;
}
inline void INF_QueryCJMX_Ack::set_cjpennum(const ::std::string& value) {
  set_has_cjpennum();
  if (cjpennum_ == &::google::protobuf::internal::kEmptyString) {
    cjpennum_ = new ::std::string;
  }
  cjpennum_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjpennum(const char* value) {
  set_has_cjpennum();
  if (cjpennum_ == &::google::protobuf::internal::kEmptyString) {
    cjpennum_ = new ::std::string;
  }
  cjpennum_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_cjpennum(const char* value, size_t size) {
  set_has_cjpennum();
  if (cjpennum_ == &::google::protobuf::internal::kEmptyString) {
    cjpennum_ = new ::std::string;
  }
  cjpennum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_cjpennum() {
  set_has_cjpennum();
  if (cjpennum_ == &::google::protobuf::internal::kEmptyString) {
    cjpennum_ = new ::std::string;
  }
  return cjpennum_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_cjpennum() {
  clear_has_cjpennum();
  if (cjpennum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjpennum_;
    cjpennum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string EntrustType = 21;
inline bool INF_QueryCJMX_Ack::has_entrusttype() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_entrusttype() {
  _has_bits_[0] |= 0x00100000u;
}
inline void INF_QueryCJMX_Ack::clear_has_entrusttype() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void INF_QueryCJMX_Ack::clear_entrusttype() {
  if (entrusttype_ != &::google::protobuf::internal::kEmptyString) {
    entrusttype_->clear();
  }
  clear_has_entrusttype();
}
inline const ::std::string& INF_QueryCJMX_Ack::entrusttype() const {
  return *entrusttype_;
}
inline void INF_QueryCJMX_Ack::set_entrusttype(const ::std::string& value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_entrusttype(const char* value) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_entrusttype(const char* value, size_t size) {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  entrusttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_entrusttype() {
  set_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    entrusttype_ = new ::std::string;
  }
  return entrusttype_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_entrusttype() {
  clear_has_entrusttype();
  if (entrusttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrusttype_;
    entrusttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DeclareNo = 22;
inline bool INF_QueryCJMX_Ack::has_declareno() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void INF_QueryCJMX_Ack::set_has_declareno() {
  _has_bits_[0] |= 0x00200000u;
}
inline void INF_QueryCJMX_Ack::clear_has_declareno() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void INF_QueryCJMX_Ack::clear_declareno() {
  if (declareno_ != &::google::protobuf::internal::kEmptyString) {
    declareno_->clear();
  }
  clear_has_declareno();
}
inline const ::std::string& INF_QueryCJMX_Ack::declareno() const {
  return *declareno_;
}
inline void INF_QueryCJMX_Ack::set_declareno(const ::std::string& value) {
  set_has_declareno();
  if (declareno_ == &::google::protobuf::internal::kEmptyString) {
    declareno_ = new ::std::string;
  }
  declareno_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_declareno(const char* value) {
  set_has_declareno();
  if (declareno_ == &::google::protobuf::internal::kEmptyString) {
    declareno_ = new ::std::string;
  }
  declareno_->assign(value);
}
inline void INF_QueryCJMX_Ack::set_declareno(const char* value, size_t size) {
  set_has_declareno();
  if (declareno_ == &::google::protobuf::internal::kEmptyString) {
    declareno_ = new ::std::string;
  }
  declareno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_QueryCJMX_Ack::mutable_declareno() {
  set_has_declareno();
  if (declareno_ == &::google::protobuf::internal::kEmptyString) {
    declareno_ = new ::std::string;
  }
  return declareno_;
}
inline ::std::string* INF_QueryCJMX_Ack::release_declareno() {
  clear_has_declareno();
  if (declareno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = declareno_;
    declareno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_ETFPurRedem_Ack

// optional string EntrustSerial = 1;
inline bool INF_ETFPurRedem_Ack::has_entrustserial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_ETFPurRedem_Ack::set_has_entrustserial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_ETFPurRedem_Ack::clear_has_entrustserial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_ETFPurRedem_Ack::clear_entrustserial() {
  if (entrustserial_ != &::google::protobuf::internal::kEmptyString) {
    entrustserial_->clear();
  }
  clear_has_entrustserial();
}
inline const ::std::string& INF_ETFPurRedem_Ack::entrustserial() const {
  return *entrustserial_;
}
inline void INF_ETFPurRedem_Ack::set_entrustserial(const ::std::string& value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_ETFPurRedem_Ack::set_entrustserial(const char* value) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(value);
}
inline void INF_ETFPurRedem_Ack::set_entrustserial(const char* value, size_t size) {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  entrustserial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Ack::mutable_entrustserial() {
  set_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    entrustserial_ = new ::std::string;
  }
  return entrustserial_;
}
inline ::std::string* INF_ETFPurRedem_Ack::release_entrustserial() {
  clear_has_entrustserial();
  if (entrustserial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entrustserial_;
    entrustserial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Valid = 2;
inline bool INF_ETFPurRedem_Ack::has_valid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_ETFPurRedem_Ack::set_has_valid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_ETFPurRedem_Ack::clear_has_valid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_ETFPurRedem_Ack::clear_valid() {
  if (valid_ != &::google::protobuf::internal::kEmptyString) {
    valid_->clear();
  }
  clear_has_valid();
}
inline const ::std::string& INF_ETFPurRedem_Ack::valid() const {
  return *valid_;
}
inline void INF_ETFPurRedem_Ack::set_valid(const ::std::string& value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_ETFPurRedem_Ack::set_valid(const char* value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void INF_ETFPurRedem_Ack::set_valid(const char* value, size_t size) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Ack::mutable_valid() {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  return valid_;
}
inline ::std::string* INF_ETFPurRedem_Ack::release_valid() {
  clear_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_;
    valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RespFlag = 3;
inline bool INF_ETFPurRedem_Ack::has_respflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_ETFPurRedem_Ack::set_has_respflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_ETFPurRedem_Ack::clear_has_respflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_ETFPurRedem_Ack::clear_respflag() {
  if (respflag_ != &::google::protobuf::internal::kEmptyString) {
    respflag_->clear();
  }
  clear_has_respflag();
}
inline const ::std::string& INF_ETFPurRedem_Ack::respflag() const {
  return *respflag_;
}
inline void INF_ETFPurRedem_Ack::set_respflag(const ::std::string& value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_ETFPurRedem_Ack::set_respflag(const char* value) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(value);
}
inline void INF_ETFPurRedem_Ack::set_respflag(const char* value, size_t size) {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  respflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Ack::mutable_respflag() {
  set_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    respflag_ = new ::std::string;
  }
  return respflag_;
}
inline ::std::string* INF_ETFPurRedem_Ack::release_respflag() {
  clear_has_respflag();
  if (respflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = respflag_;
    respflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IsSuccess = 4;
inline bool INF_ETFPurRedem_Ack::has_issuccess() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_ETFPurRedem_Ack::set_has_issuccess() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_ETFPurRedem_Ack::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_ETFPurRedem_Ack::clear_issuccess() {
  if (issuccess_ != &::google::protobuf::internal::kEmptyString) {
    issuccess_->clear();
  }
  clear_has_issuccess();
}
inline const ::std::string& INF_ETFPurRedem_Ack::issuccess() const {
  return *issuccess_;
}
inline void INF_ETFPurRedem_Ack::set_issuccess(const ::std::string& value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_ETFPurRedem_Ack::set_issuccess(const char* value) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(value);
}
inline void INF_ETFPurRedem_Ack::set_issuccess(const char* value, size_t size) {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  issuccess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_ETFPurRedem_Ack::mutable_issuccess() {
  set_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    issuccess_ = new ::std::string;
  }
  return issuccess_;
}
inline ::std::string* INF_ETFPurRedem_Ack::release_issuccess() {
  clear_has_issuccess();
  if (issuccess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issuccess_;
    issuccess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StockLoginResp

// optional int32 funcid = 1 [default = 11100001];
inline bool StockLoginResp::has_funcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StockLoginResp::set_has_funcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StockLoginResp::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StockLoginResp::clear_funcid() {
  funcid_ = 11100001;
  clear_has_funcid();
}
inline ::google::protobuf::int32 StockLoginResp::funcid() const {
  return funcid_;
}
inline void StockLoginResp::set_funcid(::google::protobuf::int32 value) {
  set_has_funcid();
  funcid_ = value;
}

// required string fund_account = 2;
inline bool StockLoginResp::has_fund_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StockLoginResp::set_has_fund_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StockLoginResp::clear_has_fund_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StockLoginResp::clear_fund_account() {
  if (fund_account_ != &::google::protobuf::internal::kEmptyString) {
    fund_account_->clear();
  }
  clear_has_fund_account();
}
inline const ::std::string& StockLoginResp::fund_account() const {
  return *fund_account_;
}
inline void StockLoginResp::set_fund_account(const ::std::string& value) {
  set_has_fund_account();
  if (fund_account_ == &::google::protobuf::internal::kEmptyString) {
    fund_account_ = new ::std::string;
  }
  fund_account_->assign(value);
}
inline void StockLoginResp::set_fund_account(const char* value) {
  set_has_fund_account();
  if (fund_account_ == &::google::protobuf::internal::kEmptyString) {
    fund_account_ = new ::std::string;
  }
  fund_account_->assign(value);
}
inline void StockLoginResp::set_fund_account(const char* value, size_t size) {
  set_has_fund_account();
  if (fund_account_ == &::google::protobuf::internal::kEmptyString) {
    fund_account_ = new ::std::string;
  }
  fund_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StockLoginResp::mutable_fund_account() {
  set_has_fund_account();
  if (fund_account_ == &::google::protobuf::internal::kEmptyString) {
    fund_account_ = new ::std::string;
  }
  return fund_account_;
}
inline ::std::string* StockLoginResp::release_fund_account() {
  clear_has_fund_account();
  if (fund_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fund_account_;
    fund_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ACCOUNT_INFO

// optional double acc_ava = 1;
inline bool ACCOUNT_INFO::has_acc_ava() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACCOUNT_INFO::set_has_acc_ava() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACCOUNT_INFO::clear_has_acc_ava() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACCOUNT_INFO::clear_acc_ava() {
  acc_ava_ = 0;
  clear_has_acc_ava();
}
inline double ACCOUNT_INFO::acc_ava() const {
  return acc_ava_;
}
inline void ACCOUNT_INFO::set_acc_ava(double value) {
  set_has_acc_ava();
  acc_ava_ = value;
}

// optional double acc_prelock = 2;
inline bool ACCOUNT_INFO::has_acc_prelock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACCOUNT_INFO::set_has_acc_prelock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACCOUNT_INFO::clear_has_acc_prelock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACCOUNT_INFO::clear_acc_prelock() {
  acc_prelock_ = 0;
  clear_has_acc_prelock();
}
inline double ACCOUNT_INFO::acc_prelock() const {
  return acc_prelock_;
}
inline void ACCOUNT_INFO::set_acc_prelock(double value) {
  set_has_acc_prelock();
  acc_prelock_ = value;
}

// optional double acc_lock = 3;
inline bool ACCOUNT_INFO::has_acc_lock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACCOUNT_INFO::set_has_acc_lock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACCOUNT_INFO::clear_has_acc_lock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACCOUNT_INFO::clear_acc_lock() {
  acc_lock_ = 0;
  clear_has_acc_lock();
}
inline double ACCOUNT_INFO::acc_lock() const {
  return acc_lock_;
}
inline void ACCOUNT_INFO::set_acc_lock(double value) {
  set_has_acc_lock();
  acc_lock_ = value;
}

// -------------------------------------------------------------------

// STOCK_INFO

// optional string stk_code = 1;
inline bool STOCK_INFO::has_stk_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void STOCK_INFO::set_has_stk_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void STOCK_INFO::clear_has_stk_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void STOCK_INFO::clear_stk_code() {
  if (stk_code_ != &::google::protobuf::internal::kEmptyString) {
    stk_code_->clear();
  }
  clear_has_stk_code();
}
inline const ::std::string& STOCK_INFO::stk_code() const {
  return *stk_code_;
}
inline void STOCK_INFO::set_stk_code(const ::std::string& value) {
  set_has_stk_code();
  if (stk_code_ == &::google::protobuf::internal::kEmptyString) {
    stk_code_ = new ::std::string;
  }
  stk_code_->assign(value);
}
inline void STOCK_INFO::set_stk_code(const char* value) {
  set_has_stk_code();
  if (stk_code_ == &::google::protobuf::internal::kEmptyString) {
    stk_code_ = new ::std::string;
  }
  stk_code_->assign(value);
}
inline void STOCK_INFO::set_stk_code(const char* value, size_t size) {
  set_has_stk_code();
  if (stk_code_ == &::google::protobuf::internal::kEmptyString) {
    stk_code_ = new ::std::string;
  }
  stk_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* STOCK_INFO::mutable_stk_code() {
  set_has_stk_code();
  if (stk_code_ == &::google::protobuf::internal::kEmptyString) {
    stk_code_ = new ::std::string;
  }
  return stk_code_;
}
inline ::std::string* STOCK_INFO::release_stk_code() {
  clear_has_stk_code();
  if (stk_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stk_code_;
    stk_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 stk_ava = 2;
inline bool STOCK_INFO::has_stk_ava() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void STOCK_INFO::set_has_stk_ava() {
  _has_bits_[0] |= 0x00000002u;
}
inline void STOCK_INFO::clear_has_stk_ava() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void STOCK_INFO::clear_stk_ava() {
  stk_ava_ = GOOGLE_LONGLONG(0);
  clear_has_stk_ava();
}
inline ::google::protobuf::int64 STOCK_INFO::stk_ava() const {
  return stk_ava_;
}
inline void STOCK_INFO::set_stk_ava(::google::protobuf::int64 value) {
  set_has_stk_ava();
  stk_ava_ = value;
}

// optional int64 stk_prelock = 3;
inline bool STOCK_INFO::has_stk_prelock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void STOCK_INFO::set_has_stk_prelock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void STOCK_INFO::clear_has_stk_prelock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void STOCK_INFO::clear_stk_prelock() {
  stk_prelock_ = GOOGLE_LONGLONG(0);
  clear_has_stk_prelock();
}
inline ::google::protobuf::int64 STOCK_INFO::stk_prelock() const {
  return stk_prelock_;
}
inline void STOCK_INFO::set_stk_prelock(::google::protobuf::int64 value) {
  set_has_stk_prelock();
  stk_prelock_ = value;
}

// optional int64 stk_lock = 4;
inline bool STOCK_INFO::has_stk_lock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void STOCK_INFO::set_has_stk_lock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void STOCK_INFO::clear_has_stk_lock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void STOCK_INFO::clear_stk_lock() {
  stk_lock_ = GOOGLE_LONGLONG(0);
  clear_has_stk_lock();
}
inline ::google::protobuf::int64 STOCK_INFO::stk_lock() const {
  return stk_lock_;
}
inline void STOCK_INFO::set_stk_lock(::google::protobuf::int64 value) {
  set_has_stk_lock();
  stk_lock_ = value;
}

// -------------------------------------------------------------------

// ETF_INFO

// optional string etf_code = 1;
inline bool ETF_INFO::has_etf_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ETF_INFO::set_has_etf_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ETF_INFO::clear_has_etf_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ETF_INFO::clear_etf_code() {
  if (etf_code_ != &::google::protobuf::internal::kEmptyString) {
    etf_code_->clear();
  }
  clear_has_etf_code();
}
inline const ::std::string& ETF_INFO::etf_code() const {
  return *etf_code_;
}
inline void ETF_INFO::set_etf_code(const ::std::string& value) {
  set_has_etf_code();
  if (etf_code_ == &::google::protobuf::internal::kEmptyString) {
    etf_code_ = new ::std::string;
  }
  etf_code_->assign(value);
}
inline void ETF_INFO::set_etf_code(const char* value) {
  set_has_etf_code();
  if (etf_code_ == &::google::protobuf::internal::kEmptyString) {
    etf_code_ = new ::std::string;
  }
  etf_code_->assign(value);
}
inline void ETF_INFO::set_etf_code(const char* value, size_t size) {
  set_has_etf_code();
  if (etf_code_ == &::google::protobuf::internal::kEmptyString) {
    etf_code_ = new ::std::string;
  }
  etf_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_INFO::mutable_etf_code() {
  set_has_etf_code();
  if (etf_code_ == &::google::protobuf::internal::kEmptyString) {
    etf_code_ = new ::std::string;
  }
  return etf_code_;
}
inline ::std::string* ETF_INFO::release_etf_code() {
  clear_has_etf_code();
  if (etf_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etf_code_;
    etf_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 etf_ava = 2;
inline bool ETF_INFO::has_etf_ava() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ETF_INFO::set_has_etf_ava() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ETF_INFO::clear_has_etf_ava() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ETF_INFO::clear_etf_ava() {
  etf_ava_ = GOOGLE_LONGLONG(0);
  clear_has_etf_ava();
}
inline ::google::protobuf::int64 ETF_INFO::etf_ava() const {
  return etf_ava_;
}
inline void ETF_INFO::set_etf_ava(::google::protobuf::int64 value) {
  set_has_etf_ava();
  etf_ava_ = value;
}

// optional int64 etf_prelock = 3;
inline bool ETF_INFO::has_etf_prelock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ETF_INFO::set_has_etf_prelock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ETF_INFO::clear_has_etf_prelock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ETF_INFO::clear_etf_prelock() {
  etf_prelock_ = GOOGLE_LONGLONG(0);
  clear_has_etf_prelock();
}
inline ::google::protobuf::int64 ETF_INFO::etf_prelock() const {
  return etf_prelock_;
}
inline void ETF_INFO::set_etf_prelock(::google::protobuf::int64 value) {
  set_has_etf_prelock();
  etf_prelock_ = value;
}

// optional int64 etf_lock = 4;
inline bool ETF_INFO::has_etf_lock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ETF_INFO::set_has_etf_lock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ETF_INFO::clear_has_etf_lock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ETF_INFO::clear_etf_lock() {
  etf_lock_ = GOOGLE_LONGLONG(0);
  clear_has_etf_lock();
}
inline ::google::protobuf::int64 ETF_INFO::etf_lock() const {
  return etf_lock_;
}
inline void ETF_INFO::set_etf_lock(::google::protobuf::int64 value) {
  set_has_etf_lock();
  etf_lock_ = value;
}

// -------------------------------------------------------------------

// LOGIN_REQ

// optional int32 funcid = 1 [default = 13000001];
inline bool LOGIN_REQ::has_funcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LOGIN_REQ::set_has_funcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LOGIN_REQ::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LOGIN_REQ::clear_funcid() {
  funcid_ = 13000001;
  clear_has_funcid();
}
inline ::google::protobuf::int32 LOGIN_REQ::funcid() const {
  return funcid_;
}
inline void LOGIN_REQ::set_funcid(::google::protobuf::int32 value) {
  set_has_funcid();
  funcid_ = value;
}

// optional string password = 2;
inline bool LOGIN_REQ::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LOGIN_REQ::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LOGIN_REQ::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LOGIN_REQ::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LOGIN_REQ::password() const {
  return *password_;
}
inline void LOGIN_REQ::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LOGIN_REQ::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LOGIN_REQ::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LOGIN_REQ::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LOGIN_REQ::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LOGIN_ACK

// optional int32 funcid = 1 [default = 13100001];
inline bool LOGIN_ACK::has_funcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LOGIN_ACK::set_has_funcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LOGIN_ACK::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LOGIN_ACK::clear_funcid() {
  funcid_ = 13100001;
  clear_has_funcid();
}
inline ::google::protobuf::int32 LOGIN_ACK::funcid() const {
  return funcid_;
}
inline void LOGIN_ACK::set_funcid(::google::protobuf::int32 value) {
  set_has_funcid();
  funcid_ = value;
}

// required string fund_account = 2;
inline bool LOGIN_ACK::has_fund_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LOGIN_ACK::set_has_fund_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LOGIN_ACK::clear_has_fund_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LOGIN_ACK::clear_fund_account() {
  if (fund_account_ != &::google::protobuf::internal::kEmptyString) {
    fund_account_->clear();
  }
  clear_has_fund_account();
}
inline const ::std::string& LOGIN_ACK::fund_account() const {
  return *fund_account_;
}
inline void LOGIN_ACK::set_fund_account(const ::std::string& value) {
  set_has_fund_account();
  if (fund_account_ == &::google::protobuf::internal::kEmptyString) {
    fund_account_ = new ::std::string;
  }
  fund_account_->assign(value);
}
inline void LOGIN_ACK::set_fund_account(const char* value) {
  set_has_fund_account();
  if (fund_account_ == &::google::protobuf::internal::kEmptyString) {
    fund_account_ = new ::std::string;
  }
  fund_account_->assign(value);
}
inline void LOGIN_ACK::set_fund_account(const char* value, size_t size) {
  set_has_fund_account();
  if (fund_account_ == &::google::protobuf::internal::kEmptyString) {
    fund_account_ = new ::std::string;
  }
  fund_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LOGIN_ACK::mutable_fund_account() {
  set_has_fund_account();
  if (fund_account_ == &::google::protobuf::internal::kEmptyString) {
    fund_account_ = new ::std::string;
  }
  return fund_account_;
}
inline ::std::string* LOGIN_ACK::release_fund_account() {
  clear_has_fund_account();
  if (fund_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fund_account_;
    fund_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sesstion_id = 3;
inline bool LOGIN_ACK::has_sesstion_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LOGIN_ACK::set_has_sesstion_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LOGIN_ACK::clear_has_sesstion_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LOGIN_ACK::clear_sesstion_id() {
  if (sesstion_id_ != &::google::protobuf::internal::kEmptyString) {
    sesstion_id_->clear();
  }
  clear_has_sesstion_id();
}
inline const ::std::string& LOGIN_ACK::sesstion_id() const {
  return *sesstion_id_;
}
inline void LOGIN_ACK::set_sesstion_id(const ::std::string& value) {
  set_has_sesstion_id();
  if (sesstion_id_ == &::google::protobuf::internal::kEmptyString) {
    sesstion_id_ = new ::std::string;
  }
  sesstion_id_->assign(value);
}
inline void LOGIN_ACK::set_sesstion_id(const char* value) {
  set_has_sesstion_id();
  if (sesstion_id_ == &::google::protobuf::internal::kEmptyString) {
    sesstion_id_ = new ::std::string;
  }
  sesstion_id_->assign(value);
}
inline void LOGIN_ACK::set_sesstion_id(const char* value, size_t size) {
  set_has_sesstion_id();
  if (sesstion_id_ == &::google::protobuf::internal::kEmptyString) {
    sesstion_id_ = new ::std::string;
  }
  sesstion_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LOGIN_ACK::mutable_sesstion_id() {
  set_has_sesstion_id();
  if (sesstion_id_ == &::google::protobuf::internal::kEmptyString) {
    sesstion_id_ = new ::std::string;
  }
  return sesstion_id_;
}
inline ::std::string* LOGIN_ACK::release_sesstion_id() {
  clear_has_sesstion_id();
  if (sesstion_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sesstion_id_;
    sesstion_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// INF_Account

// optional string account_id = 1;
inline bool INF_Account::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_Account::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_Account::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_Account::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& INF_Account::account_id() const {
  return *account_id_;
}
inline void INF_Account::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void INF_Account::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void INF_Account::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* INF_Account::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* INF_Account::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 query_update_flg = 2;
inline bool INF_Account::has_query_update_flg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_Account::set_has_query_update_flg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_Account::clear_has_query_update_flg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_Account::clear_query_update_flg() {
  query_update_flg_ = 0;
  clear_has_query_update_flg();
}
inline ::google::protobuf::int32 INF_Account::query_update_flg() const {
  return query_update_flg_;
}
inline void INF_Account::set_query_update_flg(::google::protobuf::int32 value) {
  set_has_query_update_flg();
  query_update_flg_ = value;
}

// optional .ACCOUNT_INFO acc = 3;
inline bool INF_Account::has_acc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void INF_Account::set_has_acc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void INF_Account::clear_has_acc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void INF_Account::clear_acc() {
  if (acc_ != NULL) acc_->::ACCOUNT_INFO::Clear();
  clear_has_acc();
}
inline const ::ACCOUNT_INFO& INF_Account::acc() const {
  return acc_ != NULL ? *acc_ : *default_instance_->acc_;
}
inline ::ACCOUNT_INFO* INF_Account::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) acc_ = new ::ACCOUNT_INFO;
  return acc_;
}
inline ::ACCOUNT_INFO* INF_Account::release_acc() {
  clear_has_acc();
  ::ACCOUNT_INFO* temp = acc_;
  acc_ = NULL;
  return temp;
}

// optional .STOCK_INFO stk = 4;
inline bool INF_Account::has_stk() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void INF_Account::set_has_stk() {
  _has_bits_[0] |= 0x00000008u;
}
inline void INF_Account::clear_has_stk() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void INF_Account::clear_stk() {
  if (stk_ != NULL) stk_->::STOCK_INFO::Clear();
  clear_has_stk();
}
inline const ::STOCK_INFO& INF_Account::stk() const {
  return stk_ != NULL ? *stk_ : *default_instance_->stk_;
}
inline ::STOCK_INFO* INF_Account::mutable_stk() {
  set_has_stk();
  if (stk_ == NULL) stk_ = new ::STOCK_INFO;
  return stk_;
}
inline ::STOCK_INFO* INF_Account::release_stk() {
  clear_has_stk();
  ::STOCK_INFO* temp = stk_;
  stk_ = NULL;
  return temp;
}

// optional .ETF_INFO etf = 5;
inline bool INF_Account::has_etf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void INF_Account::set_has_etf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void INF_Account::clear_has_etf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void INF_Account::clear_etf() {
  if (etf_ != NULL) etf_->::ETF_INFO::Clear();
  clear_has_etf();
}
inline const ::ETF_INFO& INF_Account::etf() const {
  return etf_ != NULL ? *etf_ : *default_instance_->etf_;
}
inline ::ETF_INFO* INF_Account::mutable_etf() {
  set_has_etf();
  if (etf_ == NULL) etf_ = new ::ETF_INFO;
  return etf_;
}
inline ::ETF_INFO* INF_Account::release_etf() {
  clear_has_etf();
  ::ETF_INFO* temp = etf_;
  etf_ = NULL;
  return temp;
}

// optional .LOGIN_ACK login_ack = 6;
inline bool INF_Account::has_login_ack() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void INF_Account::set_has_login_ack() {
  _has_bits_[0] |= 0x00000020u;
}
inline void INF_Account::clear_has_login_ack() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void INF_Account::clear_login_ack() {
  if (login_ack_ != NULL) login_ack_->::LOGIN_ACK::Clear();
  clear_has_login_ack();
}
inline const ::LOGIN_ACK& INF_Account::login_ack() const {
  return login_ack_ != NULL ? *login_ack_ : *default_instance_->login_ack_;
}
inline ::LOGIN_ACK* INF_Account::mutable_login_ack() {
  set_has_login_ack();
  if (login_ack_ == NULL) login_ack_ = new ::LOGIN_ACK;
  return login_ack_;
}
inline ::LOGIN_ACK* INF_Account::release_login_ack() {
  clear_has_login_ack();
  ::LOGIN_ACK* temp = login_ack_;
  login_ack_ = NULL;
  return temp;
}

// optional .LOGIN_REQ login_req = 7;
inline bool INF_Account::has_login_req() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void INF_Account::set_has_login_req() {
  _has_bits_[0] |= 0x00000040u;
}
inline void INF_Account::clear_has_login_req() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void INF_Account::clear_login_req() {
  if (login_req_ != NULL) login_req_->::LOGIN_REQ::Clear();
  clear_has_login_req();
}
inline const ::LOGIN_REQ& INF_Account::login_req() const {
  return login_req_ != NULL ? *login_req_ : *default_instance_->login_req_;
}
inline ::LOGIN_REQ* INF_Account::mutable_login_req() {
  set_has_login_req();
  if (login_req_ == NULL) login_req_ = new ::LOGIN_REQ;
  return login_req_;
}
inline ::LOGIN_REQ* INF_Account::release_login_req() {
  clear_has_login_req();
  ::LOGIN_REQ* temp = login_req_;
  login_req_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// INF_ETF_Message

// optional .ETF_Message_req Etf_req = 1;
inline bool INF_ETF_Message::has_etf_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void INF_ETF_Message::set_has_etf_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void INF_ETF_Message::clear_has_etf_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void INF_ETF_Message::clear_etf_req() {
  if (etf_req_ != NULL) etf_req_->::ETF_Message_req::Clear();
  clear_has_etf_req();
}
inline const ::ETF_Message_req& INF_ETF_Message::etf_req() const {
  return etf_req_ != NULL ? *etf_req_ : *default_instance_->etf_req_;
}
inline ::ETF_Message_req* INF_ETF_Message::mutable_etf_req() {
  set_has_etf_req();
  if (etf_req_ == NULL) etf_req_ = new ::ETF_Message_req;
  return etf_req_;
}
inline ::ETF_Message_req* INF_ETF_Message::release_etf_req() {
  clear_has_etf_req();
  ::ETF_Message_req* temp = etf_req_;
  etf_req_ = NULL;
  return temp;
}

// optional .ETF_Message_ack Etf_ack = 2;
inline bool INF_ETF_Message::has_etf_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void INF_ETF_Message::set_has_etf_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void INF_ETF_Message::clear_has_etf_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void INF_ETF_Message::clear_etf_ack() {
  if (etf_ack_ != NULL) etf_ack_->::ETF_Message_ack::Clear();
  clear_has_etf_ack();
}
inline const ::ETF_Message_ack& INF_ETF_Message::etf_ack() const {
  return etf_ack_ != NULL ? *etf_ack_ : *default_instance_->etf_ack_;
}
inline ::ETF_Message_ack* INF_ETF_Message::mutable_etf_ack() {
  set_has_etf_ack();
  if (etf_ack_ == NULL) etf_ack_ = new ::ETF_Message_ack;
  return etf_ack_;
}
inline ::ETF_Message_ack* INF_ETF_Message::release_etf_ack() {
  clear_has_etf_ack();
  ::ETF_Message_ack* temp = etf_ack_;
  etf_ack_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ETF_Message_req

// optional string ETF_WT_NO = 1;
inline bool ETF_Message_req::has_etf_wt_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ETF_Message_req::set_has_etf_wt_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ETF_Message_req::clear_has_etf_wt_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ETF_Message_req::clear_etf_wt_no() {
  if (etf_wt_no_ != &::google::protobuf::internal::kEmptyString) {
    etf_wt_no_->clear();
  }
  clear_has_etf_wt_no();
}
inline const ::std::string& ETF_Message_req::etf_wt_no() const {
  return *etf_wt_no_;
}
inline void ETF_Message_req::set_etf_wt_no(const ::std::string& value) {
  set_has_etf_wt_no();
  if (etf_wt_no_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_no_ = new ::std::string;
  }
  etf_wt_no_->assign(value);
}
inline void ETF_Message_req::set_etf_wt_no(const char* value) {
  set_has_etf_wt_no();
  if (etf_wt_no_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_no_ = new ::std::string;
  }
  etf_wt_no_->assign(value);
}
inline void ETF_Message_req::set_etf_wt_no(const char* value, size_t size) {
  set_has_etf_wt_no();
  if (etf_wt_no_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_no_ = new ::std::string;
  }
  etf_wt_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_req::mutable_etf_wt_no() {
  set_has_etf_wt_no();
  if (etf_wt_no_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_no_ = new ::std::string;
  }
  return etf_wt_no_;
}
inline ::std::string* ETF_Message_req::release_etf_wt_no() {
  clear_has_etf_wt_no();
  if (etf_wt_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etf_wt_no_;
    etf_wt_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ETF_Message_ack

// optional string Valid = 1;
inline bool ETF_Message_ack::has_valid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ETF_Message_ack::set_has_valid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ETF_Message_ack::clear_has_valid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ETF_Message_ack::clear_valid() {
  if (valid_ != &::google::protobuf::internal::kEmptyString) {
    valid_->clear();
  }
  clear_has_valid();
}
inline const ::std::string& ETF_Message_ack::valid() const {
  return *valid_;
}
inline void ETF_Message_ack::set_valid(const ::std::string& value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void ETF_Message_ack::set_valid(const char* value) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(value);
}
inline void ETF_Message_ack::set_valid(const char* value, size_t size) {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  valid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_valid() {
  set_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    valid_ = new ::std::string;
  }
  return valid_;
}
inline ::std::string* ETF_Message_ack::release_valid() {
  clear_has_valid();
  if (valid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_;
    valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFCode = 2;
inline bool ETF_Message_ack::has_etfcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ETF_Message_ack::set_has_etfcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ETF_Message_ack::clear_has_etfcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ETF_Message_ack::clear_etfcode() {
  if (etfcode_ != &::google::protobuf::internal::kEmptyString) {
    etfcode_->clear();
  }
  clear_has_etfcode();
}
inline const ::std::string& ETF_Message_ack::etfcode() const {
  return *etfcode_;
}
inline void ETF_Message_ack::set_etfcode(const ::std::string& value) {
  set_has_etfcode();
  if (etfcode_ == &::google::protobuf::internal::kEmptyString) {
    etfcode_ = new ::std::string;
  }
  etfcode_->assign(value);
}
inline void ETF_Message_ack::set_etfcode(const char* value) {
  set_has_etfcode();
  if (etfcode_ == &::google::protobuf::internal::kEmptyString) {
    etfcode_ = new ::std::string;
  }
  etfcode_->assign(value);
}
inline void ETF_Message_ack::set_etfcode(const char* value, size_t size) {
  set_has_etfcode();
  if (etfcode_ == &::google::protobuf::internal::kEmptyString) {
    etfcode_ = new ::std::string;
  }
  etfcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_etfcode() {
  set_has_etfcode();
  if (etfcode_ == &::google::protobuf::internal::kEmptyString) {
    etfcode_ = new ::std::string;
  }
  return etfcode_;
}
inline ::std::string* ETF_Message_ack::release_etfcode() {
  clear_has_etfcode();
  if (etfcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfcode_;
    etfcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETFName = 3;
inline bool ETF_Message_ack::has_etfname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ETF_Message_ack::set_has_etfname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ETF_Message_ack::clear_has_etfname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ETF_Message_ack::clear_etfname() {
  if (etfname_ != &::google::protobuf::internal::kEmptyString) {
    etfname_->clear();
  }
  clear_has_etfname();
}
inline const ::std::string& ETF_Message_ack::etfname() const {
  return *etfname_;
}
inline void ETF_Message_ack::set_etfname(const ::std::string& value) {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  etfname_->assign(value);
}
inline void ETF_Message_ack::set_etfname(const char* value) {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  etfname_->assign(value);
}
inline void ETF_Message_ack::set_etfname(const char* value, size_t size) {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  etfname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_etfname() {
  set_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    etfname_ = new ::std::string;
  }
  return etfname_;
}
inline ::std::string* ETF_Message_ack::release_etfname() {
  clear_has_etfname();
  if (etfname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etfname_;
    etfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETF_WT_Num = 4;
inline bool ETF_Message_ack::has_etf_wt_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ETF_Message_ack::set_has_etf_wt_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ETF_Message_ack::clear_has_etf_wt_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ETF_Message_ack::clear_etf_wt_num() {
  if (etf_wt_num_ != &::google::protobuf::internal::kEmptyString) {
    etf_wt_num_->clear();
  }
  clear_has_etf_wt_num();
}
inline const ::std::string& ETF_Message_ack::etf_wt_num() const {
  return *etf_wt_num_;
}
inline void ETF_Message_ack::set_etf_wt_num(const ::std::string& value) {
  set_has_etf_wt_num();
  if (etf_wt_num_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_num_ = new ::std::string;
  }
  etf_wt_num_->assign(value);
}
inline void ETF_Message_ack::set_etf_wt_num(const char* value) {
  set_has_etf_wt_num();
  if (etf_wt_num_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_num_ = new ::std::string;
  }
  etf_wt_num_->assign(value);
}
inline void ETF_Message_ack::set_etf_wt_num(const char* value, size_t size) {
  set_has_etf_wt_num();
  if (etf_wt_num_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_num_ = new ::std::string;
  }
  etf_wt_num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_etf_wt_num() {
  set_has_etf_wt_num();
  if (etf_wt_num_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_num_ = new ::std::string;
  }
  return etf_wt_num_;
}
inline ::std::string* ETF_Message_ack::release_etf_wt_num() {
  clear_has_etf_wt_num();
  if (etf_wt_num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etf_wt_num_;
    etf_wt_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETF_WT_Price = 5;
inline bool ETF_Message_ack::has_etf_wt_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ETF_Message_ack::set_has_etf_wt_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ETF_Message_ack::clear_has_etf_wt_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ETF_Message_ack::clear_etf_wt_price() {
  if (etf_wt_price_ != &::google::protobuf::internal::kEmptyString) {
    etf_wt_price_->clear();
  }
  clear_has_etf_wt_price();
}
inline const ::std::string& ETF_Message_ack::etf_wt_price() const {
  return *etf_wt_price_;
}
inline void ETF_Message_ack::set_etf_wt_price(const ::std::string& value) {
  set_has_etf_wt_price();
  if (etf_wt_price_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_price_ = new ::std::string;
  }
  etf_wt_price_->assign(value);
}
inline void ETF_Message_ack::set_etf_wt_price(const char* value) {
  set_has_etf_wt_price();
  if (etf_wt_price_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_price_ = new ::std::string;
  }
  etf_wt_price_->assign(value);
}
inline void ETF_Message_ack::set_etf_wt_price(const char* value, size_t size) {
  set_has_etf_wt_price();
  if (etf_wt_price_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_price_ = new ::std::string;
  }
  etf_wt_price_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_etf_wt_price() {
  set_has_etf_wt_price();
  if (etf_wt_price_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_price_ = new ::std::string;
  }
  return etf_wt_price_;
}
inline ::std::string* ETF_Message_ack::release_etf_wt_price() {
  clear_has_etf_wt_price();
  if (etf_wt_price_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etf_wt_price_;
    etf_wt_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETF_WT_Serial = 6;
inline bool ETF_Message_ack::has_etf_wt_serial() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ETF_Message_ack::set_has_etf_wt_serial() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ETF_Message_ack::clear_has_etf_wt_serial() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ETF_Message_ack::clear_etf_wt_serial() {
  if (etf_wt_serial_ != &::google::protobuf::internal::kEmptyString) {
    etf_wt_serial_->clear();
  }
  clear_has_etf_wt_serial();
}
inline const ::std::string& ETF_Message_ack::etf_wt_serial() const {
  return *etf_wt_serial_;
}
inline void ETF_Message_ack::set_etf_wt_serial(const ::std::string& value) {
  set_has_etf_wt_serial();
  if (etf_wt_serial_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_serial_ = new ::std::string;
  }
  etf_wt_serial_->assign(value);
}
inline void ETF_Message_ack::set_etf_wt_serial(const char* value) {
  set_has_etf_wt_serial();
  if (etf_wt_serial_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_serial_ = new ::std::string;
  }
  etf_wt_serial_->assign(value);
}
inline void ETF_Message_ack::set_etf_wt_serial(const char* value, size_t size) {
  set_has_etf_wt_serial();
  if (etf_wt_serial_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_serial_ = new ::std::string;
  }
  etf_wt_serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_etf_wt_serial() {
  set_has_etf_wt_serial();
  if (etf_wt_serial_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_serial_ = new ::std::string;
  }
  return etf_wt_serial_;
}
inline ::std::string* ETF_Message_ack::release_etf_wt_serial() {
  clear_has_etf_wt_serial();
  if (etf_wt_serial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etf_wt_serial_;
    etf_wt_serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETF_CJ_Num = 7;
inline bool ETF_Message_ack::has_etf_cj_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ETF_Message_ack::set_has_etf_cj_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ETF_Message_ack::clear_has_etf_cj_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ETF_Message_ack::clear_etf_cj_num() {
  if (etf_cj_num_ != &::google::protobuf::internal::kEmptyString) {
    etf_cj_num_->clear();
  }
  clear_has_etf_cj_num();
}
inline const ::std::string& ETF_Message_ack::etf_cj_num() const {
  return *etf_cj_num_;
}
inline void ETF_Message_ack::set_etf_cj_num(const ::std::string& value) {
  set_has_etf_cj_num();
  if (etf_cj_num_ == &::google::protobuf::internal::kEmptyString) {
    etf_cj_num_ = new ::std::string;
  }
  etf_cj_num_->assign(value);
}
inline void ETF_Message_ack::set_etf_cj_num(const char* value) {
  set_has_etf_cj_num();
  if (etf_cj_num_ == &::google::protobuf::internal::kEmptyString) {
    etf_cj_num_ = new ::std::string;
  }
  etf_cj_num_->assign(value);
}
inline void ETF_Message_ack::set_etf_cj_num(const char* value, size_t size) {
  set_has_etf_cj_num();
  if (etf_cj_num_ == &::google::protobuf::internal::kEmptyString) {
    etf_cj_num_ = new ::std::string;
  }
  etf_cj_num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_etf_cj_num() {
  set_has_etf_cj_num();
  if (etf_cj_num_ == &::google::protobuf::internal::kEmptyString) {
    etf_cj_num_ = new ::std::string;
  }
  return etf_cj_num_;
}
inline ::std::string* ETF_Message_ack::release_etf_cj_num() {
  clear_has_etf_cj_num();
  if (etf_cj_num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etf_cj_num_;
    etf_cj_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETF_WT_Time = 8;
inline bool ETF_Message_ack::has_etf_wt_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ETF_Message_ack::set_has_etf_wt_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ETF_Message_ack::clear_has_etf_wt_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ETF_Message_ack::clear_etf_wt_time() {
  if (etf_wt_time_ != &::google::protobuf::internal::kEmptyString) {
    etf_wt_time_->clear();
  }
  clear_has_etf_wt_time();
}
inline const ::std::string& ETF_Message_ack::etf_wt_time() const {
  return *etf_wt_time_;
}
inline void ETF_Message_ack::set_etf_wt_time(const ::std::string& value) {
  set_has_etf_wt_time();
  if (etf_wt_time_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_time_ = new ::std::string;
  }
  etf_wt_time_->assign(value);
}
inline void ETF_Message_ack::set_etf_wt_time(const char* value) {
  set_has_etf_wt_time();
  if (etf_wt_time_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_time_ = new ::std::string;
  }
  etf_wt_time_->assign(value);
}
inline void ETF_Message_ack::set_etf_wt_time(const char* value, size_t size) {
  set_has_etf_wt_time();
  if (etf_wt_time_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_time_ = new ::std::string;
  }
  etf_wt_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_etf_wt_time() {
  set_has_etf_wt_time();
  if (etf_wt_time_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_time_ = new ::std::string;
  }
  return etf_wt_time_;
}
inline ::std::string* ETF_Message_ack::release_etf_wt_time() {
  clear_has_etf_wt_time();
  if (etf_wt_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etf_wt_time_;
    etf_wt_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MarketID = 9;
inline bool ETF_Message_ack::has_marketid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ETF_Message_ack::set_has_marketid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ETF_Message_ack::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ETF_Message_ack::clear_marketid() {
  if (marketid_ != &::google::protobuf::internal::kEmptyString) {
    marketid_->clear();
  }
  clear_has_marketid();
}
inline const ::std::string& ETF_Message_ack::marketid() const {
  return *marketid_;
}
inline void ETF_Message_ack::set_marketid(const ::std::string& value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void ETF_Message_ack::set_marketid(const char* value) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(value);
}
inline void ETF_Message_ack::set_marketid(const char* value, size_t size) {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  marketid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_marketid() {
  set_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    marketid_ = new ::std::string;
  }
  return marketid_;
}
inline ::std::string* ETF_Message_ack::release_marketid() {
  clear_has_marketid();
  if (marketid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketid_;
    marketid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BSflag = 10;
inline bool ETF_Message_ack::has_bsflag() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ETF_Message_ack::set_has_bsflag() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ETF_Message_ack::clear_has_bsflag() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ETF_Message_ack::clear_bsflag() {
  if (bsflag_ != &::google::protobuf::internal::kEmptyString) {
    bsflag_->clear();
  }
  clear_has_bsflag();
}
inline const ::std::string& ETF_Message_ack::bsflag() const {
  return *bsflag_;
}
inline void ETF_Message_ack::set_bsflag(const ::std::string& value) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(value);
}
inline void ETF_Message_ack::set_bsflag(const char* value) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(value);
}
inline void ETF_Message_ack::set_bsflag(const char* value, size_t size) {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  bsflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_bsflag() {
  set_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    bsflag_ = new ::std::string;
  }
  return bsflag_;
}
inline ::std::string* ETF_Message_ack::release_bsflag() {
  clear_has_bsflag();
  if (bsflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bsflag_;
    bsflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ETF_WT_Status = 11;
inline bool ETF_Message_ack::has_etf_wt_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ETF_Message_ack::set_has_etf_wt_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ETF_Message_ack::clear_has_etf_wt_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ETF_Message_ack::clear_etf_wt_status() {
  if (etf_wt_status_ != &::google::protobuf::internal::kEmptyString) {
    etf_wt_status_->clear();
  }
  clear_has_etf_wt_status();
}
inline const ::std::string& ETF_Message_ack::etf_wt_status() const {
  return *etf_wt_status_;
}
inline void ETF_Message_ack::set_etf_wt_status(const ::std::string& value) {
  set_has_etf_wt_status();
  if (etf_wt_status_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_status_ = new ::std::string;
  }
  etf_wt_status_->assign(value);
}
inline void ETF_Message_ack::set_etf_wt_status(const char* value) {
  set_has_etf_wt_status();
  if (etf_wt_status_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_status_ = new ::std::string;
  }
  etf_wt_status_->assign(value);
}
inline void ETF_Message_ack::set_etf_wt_status(const char* value, size_t size) {
  set_has_etf_wt_status();
  if (etf_wt_status_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_status_ = new ::std::string;
  }
  etf_wt_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_etf_wt_status() {
  set_has_etf_wt_status();
  if (etf_wt_status_ == &::google::protobuf::internal::kEmptyString) {
    etf_wt_status_ = new ::std::string;
  }
  return etf_wt_status_;
}
inline ::std::string* ETF_Message_ack::release_etf_wt_status() {
  clear_has_etf_wt_status();
  if (etf_wt_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = etf_wt_status_;
    etf_wt_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CjPriceSum = 12;
inline bool ETF_Message_ack::has_cjpricesum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ETF_Message_ack::set_has_cjpricesum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ETF_Message_ack::clear_has_cjpricesum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ETF_Message_ack::clear_cjpricesum() {
  if (cjpricesum_ != &::google::protobuf::internal::kEmptyString) {
    cjpricesum_->clear();
  }
  clear_has_cjpricesum();
}
inline const ::std::string& ETF_Message_ack::cjpricesum() const {
  return *cjpricesum_;
}
inline void ETF_Message_ack::set_cjpricesum(const ::std::string& value) {
  set_has_cjpricesum();
  if (cjpricesum_ == &::google::protobuf::internal::kEmptyString) {
    cjpricesum_ = new ::std::string;
  }
  cjpricesum_->assign(value);
}
inline void ETF_Message_ack::set_cjpricesum(const char* value) {
  set_has_cjpricesum();
  if (cjpricesum_ == &::google::protobuf::internal::kEmptyString) {
    cjpricesum_ = new ::std::string;
  }
  cjpricesum_->assign(value);
}
inline void ETF_Message_ack::set_cjpricesum(const char* value, size_t size) {
  set_has_cjpricesum();
  if (cjpricesum_ == &::google::protobuf::internal::kEmptyString) {
    cjpricesum_ = new ::std::string;
  }
  cjpricesum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ETF_Message_ack::mutable_cjpricesum() {
  set_has_cjpricesum();
  if (cjpricesum_ == &::google::protobuf::internal::kEmptyString) {
    cjpricesum_ = new ::std::string;
  }
  return cjpricesum_;
}
inline ::std::string* ETF_Message_ack::release_cjpricesum() {
  clear_has_cjpricesum();
  if (cjpricesum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cjpricesum_;
    cjpricesum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StockServer

// required string FuncID = 1;
inline bool StockServer::has_funcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StockServer::set_has_funcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StockServer::clear_has_funcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StockServer::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& StockServer::funcid() const {
  return *funcid_;
}
inline void StockServer::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void StockServer::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void StockServer::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StockServer::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* StockServer::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string IsAckFlag = 2;
inline bool StockServer::has_isackflag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StockServer::set_has_isackflag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StockServer::clear_has_isackflag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StockServer::clear_isackflag() {
  if (isackflag_ != &::google::protobuf::internal::kEmptyString) {
    isackflag_->clear();
  }
  clear_has_isackflag();
}
inline const ::std::string& StockServer::isackflag() const {
  return *isackflag_;
}
inline void StockServer::set_isackflag(const ::std::string& value) {
  set_has_isackflag();
  if (isackflag_ == &::google::protobuf::internal::kEmptyString) {
    isackflag_ = new ::std::string;
  }
  isackflag_->assign(value);
}
inline void StockServer::set_isackflag(const char* value) {
  set_has_isackflag();
  if (isackflag_ == &::google::protobuf::internal::kEmptyString) {
    isackflag_ = new ::std::string;
  }
  isackflag_->assign(value);
}
inline void StockServer::set_isackflag(const char* value, size_t size) {
  set_has_isackflag();
  if (isackflag_ == &::google::protobuf::internal::kEmptyString) {
    isackflag_ = new ::std::string;
  }
  isackflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StockServer::mutable_isackflag() {
  set_has_isackflag();
  if (isackflag_ == &::google::protobuf::internal::kEmptyString) {
    isackflag_ = new ::std::string;
  }
  return isackflag_;
}
inline ::std::string* StockServer::release_isackflag() {
  clear_has_isackflag();
  if (isackflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isackflag_;
    isackflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string DestModule = 3;
inline bool StockServer::has_destmodule() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StockServer::set_has_destmodule() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StockServer::clear_has_destmodule() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StockServer::clear_destmodule() {
  if (destmodule_ != &::google::protobuf::internal::kEmptyString) {
    destmodule_->clear();
  }
  clear_has_destmodule();
}
inline const ::std::string& StockServer::destmodule() const {
  return *destmodule_;
}
inline void StockServer::set_destmodule(const ::std::string& value) {
  set_has_destmodule();
  if (destmodule_ == &::google::protobuf::internal::kEmptyString) {
    destmodule_ = new ::std::string;
  }
  destmodule_->assign(value);
}
inline void StockServer::set_destmodule(const char* value) {
  set_has_destmodule();
  if (destmodule_ == &::google::protobuf::internal::kEmptyString) {
    destmodule_ = new ::std::string;
  }
  destmodule_->assign(value);
}
inline void StockServer::set_destmodule(const char* value, size_t size) {
  set_has_destmodule();
  if (destmodule_ == &::google::protobuf::internal::kEmptyString) {
    destmodule_ = new ::std::string;
  }
  destmodule_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StockServer::mutable_destmodule() {
  set_has_destmodule();
  if (destmodule_ == &::google::protobuf::internal::kEmptyString) {
    destmodule_ = new ::std::string;
  }
  return destmodule_;
}
inline ::std::string* StockServer::release_destmodule() {
  clear_has_destmodule();
  if (destmodule_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = destmodule_;
    destmodule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string SrcModule = 4;
inline bool StockServer::has_srcmodule() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StockServer::set_has_srcmodule() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StockServer::clear_has_srcmodule() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StockServer::clear_srcmodule() {
  if (srcmodule_ != &::google::protobuf::internal::kEmptyString) {
    srcmodule_->clear();
  }
  clear_has_srcmodule();
}
inline const ::std::string& StockServer::srcmodule() const {
  return *srcmodule_;
}
inline void StockServer::set_srcmodule(const ::std::string& value) {
  set_has_srcmodule();
  if (srcmodule_ == &::google::protobuf::internal::kEmptyString) {
    srcmodule_ = new ::std::string;
  }
  srcmodule_->assign(value);
}
inline void StockServer::set_srcmodule(const char* value) {
  set_has_srcmodule();
  if (srcmodule_ == &::google::protobuf::internal::kEmptyString) {
    srcmodule_ = new ::std::string;
  }
  srcmodule_->assign(value);
}
inline void StockServer::set_srcmodule(const char* value, size_t size) {
  set_has_srcmodule();
  if (srcmodule_ == &::google::protobuf::internal::kEmptyString) {
    srcmodule_ = new ::std::string;
  }
  srcmodule_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StockServer::mutable_srcmodule() {
  set_has_srcmodule();
  if (srcmodule_ == &::google::protobuf::internal::kEmptyString) {
    srcmodule_ = new ::std::string;
  }
  return srcmodule_;
}
inline ::std::string* StockServer::release_srcmodule() {
  clear_has_srcmodule();
  if (srcmodule_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcmodule_;
    srcmodule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RequestID = 5;
inline bool StockServer::has_requestid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StockServer::set_has_requestid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StockServer::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StockServer::clear_requestid() {
  if (requestid_ != &::google::protobuf::internal::kEmptyString) {
    requestid_->clear();
  }
  clear_has_requestid();
}
inline const ::std::string& StockServer::requestid() const {
  return *requestid_;
}
inline void StockServer::set_requestid(const ::std::string& value) {
  set_has_requestid();
  if (requestid_ == &::google::protobuf::internal::kEmptyString) {
    requestid_ = new ::std::string;
  }
  requestid_->assign(value);
}
inline void StockServer::set_requestid(const char* value) {
  set_has_requestid();
  if (requestid_ == &::google::protobuf::internal::kEmptyString) {
    requestid_ = new ::std::string;
  }
  requestid_->assign(value);
}
inline void StockServer::set_requestid(const char* value, size_t size) {
  set_has_requestid();
  if (requestid_ == &::google::protobuf::internal::kEmptyString) {
    requestid_ = new ::std::string;
  }
  requestid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StockServer::mutable_requestid() {
  set_has_requestid();
  if (requestid_ == &::google::protobuf::internal::kEmptyString) {
    requestid_ = new ::std::string;
  }
  return requestid_;
}
inline ::std::string* StockServer::release_requestid() {
  clear_has_requestid();
  if (requestid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requestid_;
    requestid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string PackSum = 36;
inline bool StockServer::has_packsum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StockServer::set_has_packsum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StockServer::clear_has_packsum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StockServer::clear_packsum() {
  if (packsum_ != &::google::protobuf::internal::kEmptyString) {
    packsum_->clear();
  }
  clear_has_packsum();
}
inline const ::std::string& StockServer::packsum() const {
  return *packsum_;
}
inline void StockServer::set_packsum(const ::std::string& value) {
  set_has_packsum();
  if (packsum_ == &::google::protobuf::internal::kEmptyString) {
    packsum_ = new ::std::string;
  }
  packsum_->assign(value);
}
inline void StockServer::set_packsum(const char* value) {
  set_has_packsum();
  if (packsum_ == &::google::protobuf::internal::kEmptyString) {
    packsum_ = new ::std::string;
  }
  packsum_->assign(value);
}
inline void StockServer::set_packsum(const char* value, size_t size) {
  set_has_packsum();
  if (packsum_ == &::google::protobuf::internal::kEmptyString) {
    packsum_ = new ::std::string;
  }
  packsum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StockServer::mutable_packsum() {
  set_has_packsum();
  if (packsum_ == &::google::protobuf::internal::kEmptyString) {
    packsum_ = new ::std::string;
  }
  return packsum_;
}
inline ::std::string* StockServer::release_packsum() {
  clear_has_packsum();
  if (packsum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packsum_;
    packsum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string PackSeq = 37;
inline bool StockServer::has_packseq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StockServer::set_has_packseq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StockServer::clear_has_packseq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StockServer::clear_packseq() {
  if (packseq_ != &::google::protobuf::internal::kEmptyString) {
    packseq_->clear();
  }
  clear_has_packseq();
}
inline const ::std::string& StockServer::packseq() const {
  return *packseq_;
}
inline void StockServer::set_packseq(const ::std::string& value) {
  set_has_packseq();
  if (packseq_ == &::google::protobuf::internal::kEmptyString) {
    packseq_ = new ::std::string;
  }
  packseq_->assign(value);
}
inline void StockServer::set_packseq(const char* value) {
  set_has_packseq();
  if (packseq_ == &::google::protobuf::internal::kEmptyString) {
    packseq_ = new ::std::string;
  }
  packseq_->assign(value);
}
inline void StockServer::set_packseq(const char* value, size_t size) {
  set_has_packseq();
  if (packseq_ == &::google::protobuf::internal::kEmptyString) {
    packseq_ = new ::std::string;
  }
  packseq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StockServer::mutable_packseq() {
  set_has_packseq();
  if (packseq_ == &::google::protobuf::internal::kEmptyString) {
    packseq_ = new ::std::string;
  }
  return packseq_;
}
inline ::std::string* StockServer::release_packseq() {
  clear_has_packseq();
  if (packseq_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packseq_;
    packseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .INF_OneEntrust_Req OneEntrust_Req = 6;
inline bool StockServer::has_oneentrust_req() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StockServer::set_has_oneentrust_req() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StockServer::clear_has_oneentrust_req() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StockServer::clear_oneentrust_req() {
  if (oneentrust_req_ != NULL) oneentrust_req_->::INF_OneEntrust_Req::Clear();
  clear_has_oneentrust_req();
}
inline const ::INF_OneEntrust_Req& StockServer::oneentrust_req() const {
  return oneentrust_req_ != NULL ? *oneentrust_req_ : *default_instance_->oneentrust_req_;
}
inline ::INF_OneEntrust_Req* StockServer::mutable_oneentrust_req() {
  set_has_oneentrust_req();
  if (oneentrust_req_ == NULL) oneentrust_req_ = new ::INF_OneEntrust_Req;
  return oneentrust_req_;
}
inline ::INF_OneEntrust_Req* StockServer::release_oneentrust_req() {
  clear_has_oneentrust_req();
  ::INF_OneEntrust_Req* temp = oneentrust_req_;
  oneentrust_req_ = NULL;
  return temp;
}

// optional .INF_OneCancel_Req OneCancel_Req = 7;
inline bool StockServer::has_onecancel_req() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StockServer::set_has_onecancel_req() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StockServer::clear_has_onecancel_req() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StockServer::clear_onecancel_req() {
  if (onecancel_req_ != NULL) onecancel_req_->::INF_OneCancel_Req::Clear();
  clear_has_onecancel_req();
}
inline const ::INF_OneCancel_Req& StockServer::onecancel_req() const {
  return onecancel_req_ != NULL ? *onecancel_req_ : *default_instance_->onecancel_req_;
}
inline ::INF_OneCancel_Req* StockServer::mutable_onecancel_req() {
  set_has_onecancel_req();
  if (onecancel_req_ == NULL) onecancel_req_ = new ::INF_OneCancel_Req;
  return onecancel_req_;
}
inline ::INF_OneCancel_Req* StockServer::release_onecancel_req() {
  clear_has_onecancel_req();
  ::INF_OneCancel_Req* temp = onecancel_req_;
  onecancel_req_ = NULL;
  return temp;
}

// optional .INF_QueryOneEntrust_Req QueryOneEntrust_Req = 8;
inline bool StockServer::has_queryoneentrust_req() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StockServer::set_has_queryoneentrust_req() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StockServer::clear_has_queryoneentrust_req() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StockServer::clear_queryoneentrust_req() {
  if (queryoneentrust_req_ != NULL) queryoneentrust_req_->::INF_QueryOneEntrust_Req::Clear();
  clear_has_queryoneentrust_req();
}
inline const ::INF_QueryOneEntrust_Req& StockServer::queryoneentrust_req() const {
  return queryoneentrust_req_ != NULL ? *queryoneentrust_req_ : *default_instance_->queryoneentrust_req_;
}
inline ::INF_QueryOneEntrust_Req* StockServer::mutable_queryoneentrust_req() {
  set_has_queryoneentrust_req();
  if (queryoneentrust_req_ == NULL) queryoneentrust_req_ = new ::INF_QueryOneEntrust_Req;
  return queryoneentrust_req_;
}
inline ::INF_QueryOneEntrust_Req* StockServer::release_queryoneentrust_req() {
  clear_has_queryoneentrust_req();
  ::INF_QueryOneEntrust_Req* temp = queryoneentrust_req_;
  queryoneentrust_req_ = NULL;
  return temp;
}

// optional .INF_QueryCJMX_Req QueryCJMX_Req = 9;
inline bool StockServer::has_querycjmx_req() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StockServer::set_has_querycjmx_req() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StockServer::clear_has_querycjmx_req() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StockServer::clear_querycjmx_req() {
  if (querycjmx_req_ != NULL) querycjmx_req_->::INF_QueryCJMX_Req::Clear();
  clear_has_querycjmx_req();
}
inline const ::INF_QueryCJMX_Req& StockServer::querycjmx_req() const {
  return querycjmx_req_ != NULL ? *querycjmx_req_ : *default_instance_->querycjmx_req_;
}
inline ::INF_QueryCJMX_Req* StockServer::mutable_querycjmx_req() {
  set_has_querycjmx_req();
  if (querycjmx_req_ == NULL) querycjmx_req_ = new ::INF_QueryCJMX_Req;
  return querycjmx_req_;
}
inline ::INF_QueryCJMX_Req* StockServer::release_querycjmx_req() {
  clear_has_querycjmx_req();
  ::INF_QueryCJMX_Req* temp = querycjmx_req_;
  querycjmx_req_ = NULL;
  return temp;
}

// optional .INF_QueryPosition_Req QueryPosition_Req = 10;
inline bool StockServer::has_queryposition_req() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StockServer::set_has_queryposition_req() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StockServer::clear_has_queryposition_req() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StockServer::clear_queryposition_req() {
  if (queryposition_req_ != NULL) queryposition_req_->::INF_QueryPosition_Req::Clear();
  clear_has_queryposition_req();
}
inline const ::INF_QueryPosition_Req& StockServer::queryposition_req() const {
  return queryposition_req_ != NULL ? *queryposition_req_ : *default_instance_->queryposition_req_;
}
inline ::INF_QueryPosition_Req* StockServer::mutable_queryposition_req() {
  set_has_queryposition_req();
  if (queryposition_req_ == NULL) queryposition_req_ = new ::INF_QueryPosition_Req;
  return queryposition_req_;
}
inline ::INF_QueryPosition_Req* StockServer::release_queryposition_req() {
  clear_has_queryposition_req();
  ::INF_QueryPosition_Req* temp = queryposition_req_;
  queryposition_req_ = NULL;
  return temp;
}

// optional .INF_QueryETFbaseInfo_Req QueryETFbaseInfo_Req = 11;
inline bool StockServer::has_queryetfbaseinfo_req() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StockServer::set_has_queryetfbaseinfo_req() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StockServer::clear_has_queryetfbaseinfo_req() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StockServer::clear_queryetfbaseinfo_req() {
  if (queryetfbaseinfo_req_ != NULL) queryetfbaseinfo_req_->::INF_QueryETFbaseInfo_Req::Clear();
  clear_has_queryetfbaseinfo_req();
}
inline const ::INF_QueryETFbaseInfo_Req& StockServer::queryetfbaseinfo_req() const {
  return queryetfbaseinfo_req_ != NULL ? *queryetfbaseinfo_req_ : *default_instance_->queryetfbaseinfo_req_;
}
inline ::INF_QueryETFbaseInfo_Req* StockServer::mutable_queryetfbaseinfo_req() {
  set_has_queryetfbaseinfo_req();
  if (queryetfbaseinfo_req_ == NULL) queryetfbaseinfo_req_ = new ::INF_QueryETFbaseInfo_Req;
  return queryetfbaseinfo_req_;
}
inline ::INF_QueryETFbaseInfo_Req* StockServer::release_queryetfbaseinfo_req() {
  clear_has_queryetfbaseinfo_req();
  ::INF_QueryETFbaseInfo_Req* temp = queryetfbaseinfo_req_;
  queryetfbaseinfo_req_ = NULL;
  return temp;
}

// optional .INF_QueryETFlistInfo_Req QueryETFlistInfo_Req = 12;
inline bool StockServer::has_queryetflistinfo_req() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StockServer::set_has_queryetflistinfo_req() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StockServer::clear_has_queryetflistinfo_req() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StockServer::clear_queryetflistinfo_req() {
  if (queryetflistinfo_req_ != NULL) queryetflistinfo_req_->::INF_QueryETFlistInfo_Req::Clear();
  clear_has_queryetflistinfo_req();
}
inline const ::INF_QueryETFlistInfo_Req& StockServer::queryetflistinfo_req() const {
  return queryetflistinfo_req_ != NULL ? *queryetflistinfo_req_ : *default_instance_->queryetflistinfo_req_;
}
inline ::INF_QueryETFlistInfo_Req* StockServer::mutable_queryetflistinfo_req() {
  set_has_queryetflistinfo_req();
  if (queryetflistinfo_req_ == NULL) queryetflistinfo_req_ = new ::INF_QueryETFlistInfo_Req;
  return queryetflistinfo_req_;
}
inline ::INF_QueryETFlistInfo_Req* StockServer::release_queryetflistinfo_req() {
  clear_has_queryetflistinfo_req();
  ::INF_QueryETFlistInfo_Req* temp = queryetflistinfo_req_;
  queryetflistinfo_req_ = NULL;
  return temp;
}

// optional .INF_QueryETFdynamicInfo_Req QueryETFdynamicInfo_Req = 13;
inline bool StockServer::has_queryetfdynamicinfo_req() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StockServer::set_has_queryetfdynamicinfo_req() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StockServer::clear_has_queryetfdynamicinfo_req() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void StockServer::clear_queryetfdynamicinfo_req() {
  if (queryetfdynamicinfo_req_ != NULL) queryetfdynamicinfo_req_->::INF_QueryETFdynamicInfo_Req::Clear();
  clear_has_queryetfdynamicinfo_req();
}
inline const ::INF_QueryETFdynamicInfo_Req& StockServer::queryetfdynamicinfo_req() const {
  return queryetfdynamicinfo_req_ != NULL ? *queryetfdynamicinfo_req_ : *default_instance_->queryetfdynamicinfo_req_;
}
inline ::INF_QueryETFdynamicInfo_Req* StockServer::mutable_queryetfdynamicinfo_req() {
  set_has_queryetfdynamicinfo_req();
  if (queryetfdynamicinfo_req_ == NULL) queryetfdynamicinfo_req_ = new ::INF_QueryETFdynamicInfo_Req;
  return queryetfdynamicinfo_req_;
}
inline ::INF_QueryETFdynamicInfo_Req* StockServer::release_queryetfdynamicinfo_req() {
  clear_has_queryetfdynamicinfo_req();
  ::INF_QueryETFdynamicInfo_Req* temp = queryetfdynamicinfo_req_;
  queryetfdynamicinfo_req_ = NULL;
  return temp;
}

// optional .INF_QueryFundCondition_Req QueryFundCondition_Req = 14;
inline bool StockServer::has_queryfundcondition_req() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void StockServer::set_has_queryfundcondition_req() {
  _has_bits_[0] |= 0x00008000u;
}
inline void StockServer::clear_has_queryfundcondition_req() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void StockServer::clear_queryfundcondition_req() {
  if (queryfundcondition_req_ != NULL) queryfundcondition_req_->::INF_QueryFundCondition_Req::Clear();
  clear_has_queryfundcondition_req();
}
inline const ::INF_QueryFundCondition_Req& StockServer::queryfundcondition_req() const {
  return queryfundcondition_req_ != NULL ? *queryfundcondition_req_ : *default_instance_->queryfundcondition_req_;
}
inline ::INF_QueryFundCondition_Req* StockServer::mutable_queryfundcondition_req() {
  set_has_queryfundcondition_req();
  if (queryfundcondition_req_ == NULL) queryfundcondition_req_ = new ::INF_QueryFundCondition_Req;
  return queryfundcondition_req_;
}
inline ::INF_QueryFundCondition_Req* StockServer::release_queryfundcondition_req() {
  clear_has_queryfundcondition_req();
  ::INF_QueryFundCondition_Req* temp = queryfundcondition_req_;
  queryfundcondition_req_ = NULL;
  return temp;
}

// optional .INF_ETFPurRedem_Req ETFPurRedem_Req = 15;
inline bool StockServer::has_etfpurredem_req() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void StockServer::set_has_etfpurredem_req() {
  _has_bits_[0] |= 0x00010000u;
}
inline void StockServer::clear_has_etfpurredem_req() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void StockServer::clear_etfpurredem_req() {
  if (etfpurredem_req_ != NULL) etfpurredem_req_->::INF_ETFPurRedem_Req::Clear();
  clear_has_etfpurredem_req();
}
inline const ::INF_ETFPurRedem_Req& StockServer::etfpurredem_req() const {
  return etfpurredem_req_ != NULL ? *etfpurredem_req_ : *default_instance_->etfpurredem_req_;
}
inline ::INF_ETFPurRedem_Req* StockServer::mutable_etfpurredem_req() {
  set_has_etfpurredem_req();
  if (etfpurredem_req_ == NULL) etfpurredem_req_ = new ::INF_ETFPurRedem_Req;
  return etfpurredem_req_;
}
inline ::INF_ETFPurRedem_Req* StockServer::release_etfpurredem_req() {
  clear_has_etfpurredem_req();
  ::INF_ETFPurRedem_Req* temp = etfpurredem_req_;
  etfpurredem_req_ = NULL;
  return temp;
}

// optional .INF_QueryBatchEntrust_Req QueryBatchEntrust_Req = 16;
inline bool StockServer::has_querybatchentrust_req() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void StockServer::set_has_querybatchentrust_req() {
  _has_bits_[0] |= 0x00020000u;
}
inline void StockServer::clear_has_querybatchentrust_req() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void StockServer::clear_querybatchentrust_req() {
  if (querybatchentrust_req_ != NULL) querybatchentrust_req_->::INF_QueryBatchEntrust_Req::Clear();
  clear_has_querybatchentrust_req();
}
inline const ::INF_QueryBatchEntrust_Req& StockServer::querybatchentrust_req() const {
  return querybatchentrust_req_ != NULL ? *querybatchentrust_req_ : *default_instance_->querybatchentrust_req_;
}
inline ::INF_QueryBatchEntrust_Req* StockServer::mutable_querybatchentrust_req() {
  set_has_querybatchentrust_req();
  if (querybatchentrust_req_ == NULL) querybatchentrust_req_ = new ::INF_QueryBatchEntrust_Req;
  return querybatchentrust_req_;
}
inline ::INF_QueryBatchEntrust_Req* StockServer::release_querybatchentrust_req() {
  clear_has_querybatchentrust_req();
  ::INF_QueryBatchEntrust_Req* temp = querybatchentrust_req_;
  querybatchentrust_req_ = NULL;
  return temp;
}

// optional .INF_BatchEntrust_Req BatchEntrust_Req = 17;
inline bool StockServer::has_batchentrust_req() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void StockServer::set_has_batchentrust_req() {
  _has_bits_[0] |= 0x00040000u;
}
inline void StockServer::clear_has_batchentrust_req() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void StockServer::clear_batchentrust_req() {
  if (batchentrust_req_ != NULL) batchentrust_req_->::INF_BatchEntrust_Req::Clear();
  clear_has_batchentrust_req();
}
inline const ::INF_BatchEntrust_Req& StockServer::batchentrust_req() const {
  return batchentrust_req_ != NULL ? *batchentrust_req_ : *default_instance_->batchentrust_req_;
}
inline ::INF_BatchEntrust_Req* StockServer::mutable_batchentrust_req() {
  set_has_batchentrust_req();
  if (batchentrust_req_ == NULL) batchentrust_req_ = new ::INF_BatchEntrust_Req;
  return batchentrust_req_;
}
inline ::INF_BatchEntrust_Req* StockServer::release_batchentrust_req() {
  clear_has_batchentrust_req();
  ::INF_BatchEntrust_Req* temp = batchentrust_req_;
  batchentrust_req_ = NULL;
  return temp;
}

// optional .INF_BatchCancel_Req BatchCancel_Req = 18;
inline bool StockServer::has_batchcancel_req() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void StockServer::set_has_batchcancel_req() {
  _has_bits_[0] |= 0x00080000u;
}
inline void StockServer::clear_has_batchcancel_req() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void StockServer::clear_batchcancel_req() {
  if (batchcancel_req_ != NULL) batchcancel_req_->::INF_BatchCancel_Req::Clear();
  clear_has_batchcancel_req();
}
inline const ::INF_BatchCancel_Req& StockServer::batchcancel_req() const {
  return batchcancel_req_ != NULL ? *batchcancel_req_ : *default_instance_->batchcancel_req_;
}
inline ::INF_BatchCancel_Req* StockServer::mutable_batchcancel_req() {
  set_has_batchcancel_req();
  if (batchcancel_req_ == NULL) batchcancel_req_ = new ::INF_BatchCancel_Req;
  return batchcancel_req_;
}
inline ::INF_BatchCancel_Req* StockServer::release_batchcancel_req() {
  clear_has_batchcancel_req();
  ::INF_BatchCancel_Req* temp = batchcancel_req_;
  batchcancel_req_ = NULL;
  return temp;
}

// optional .INF_QueryVaildRedemNum_Req QueryVaildRedemNum_Req = 19;
inline bool StockServer::has_queryvaildredemnum_req() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void StockServer::set_has_queryvaildredemnum_req() {
  _has_bits_[0] |= 0x00100000u;
}
inline void StockServer::clear_has_queryvaildredemnum_req() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void StockServer::clear_queryvaildredemnum_req() {
  if (queryvaildredemnum_req_ != NULL) queryvaildredemnum_req_->::INF_QueryVaildRedemNum_Req::Clear();
  clear_has_queryvaildredemnum_req();
}
inline const ::INF_QueryVaildRedemNum_Req& StockServer::queryvaildredemnum_req() const {
  return queryvaildredemnum_req_ != NULL ? *queryvaildredemnum_req_ : *default_instance_->queryvaildredemnum_req_;
}
inline ::INF_QueryVaildRedemNum_Req* StockServer::mutable_queryvaildredemnum_req() {
  set_has_queryvaildredemnum_req();
  if (queryvaildredemnum_req_ == NULL) queryvaildredemnum_req_ = new ::INF_QueryVaildRedemNum_Req;
  return queryvaildredemnum_req_;
}
inline ::INF_QueryVaildRedemNum_Req* StockServer::release_queryvaildredemnum_req() {
  clear_has_queryvaildredemnum_req();
  ::INF_QueryVaildRedemNum_Req* temp = queryvaildredemnum_req_;
  queryvaildredemnum_req_ = NULL;
  return temp;
}

// optional .INF_OneEntrust_Ack OneEntrust_Ack = 20;
inline bool StockServer::has_oneentrust_ack() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void StockServer::set_has_oneentrust_ack() {
  _has_bits_[0] |= 0x00200000u;
}
inline void StockServer::clear_has_oneentrust_ack() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void StockServer::clear_oneentrust_ack() {
  if (oneentrust_ack_ != NULL) oneentrust_ack_->::INF_OneEntrust_Ack::Clear();
  clear_has_oneentrust_ack();
}
inline const ::INF_OneEntrust_Ack& StockServer::oneentrust_ack() const {
  return oneentrust_ack_ != NULL ? *oneentrust_ack_ : *default_instance_->oneentrust_ack_;
}
inline ::INF_OneEntrust_Ack* StockServer::mutable_oneentrust_ack() {
  set_has_oneentrust_ack();
  if (oneentrust_ack_ == NULL) oneentrust_ack_ = new ::INF_OneEntrust_Ack;
  return oneentrust_ack_;
}
inline ::INF_OneEntrust_Ack* StockServer::release_oneentrust_ack() {
  clear_has_oneentrust_ack();
  ::INF_OneEntrust_Ack* temp = oneentrust_ack_;
  oneentrust_ack_ = NULL;
  return temp;
}

// optional .INF_OneCancel_Ack OneCancel_Ack = 21;
inline bool StockServer::has_onecancel_ack() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void StockServer::set_has_onecancel_ack() {
  _has_bits_[0] |= 0x00400000u;
}
inline void StockServer::clear_has_onecancel_ack() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void StockServer::clear_onecancel_ack() {
  if (onecancel_ack_ != NULL) onecancel_ack_->::INF_OneCancel_Ack::Clear();
  clear_has_onecancel_ack();
}
inline const ::INF_OneCancel_Ack& StockServer::onecancel_ack() const {
  return onecancel_ack_ != NULL ? *onecancel_ack_ : *default_instance_->onecancel_ack_;
}
inline ::INF_OneCancel_Ack* StockServer::mutable_onecancel_ack() {
  set_has_onecancel_ack();
  if (onecancel_ack_ == NULL) onecancel_ack_ = new ::INF_OneCancel_Ack;
  return onecancel_ack_;
}
inline ::INF_OneCancel_Ack* StockServer::release_onecancel_ack() {
  clear_has_onecancel_ack();
  ::INF_OneCancel_Ack* temp = onecancel_ack_;
  onecancel_ack_ = NULL;
  return temp;
}

// optional .INF_QueryOneEntrust_Ack QueryOneEntrust_Ack = 22;
inline bool StockServer::has_queryoneentrust_ack() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void StockServer::set_has_queryoneentrust_ack() {
  _has_bits_[0] |= 0x00800000u;
}
inline void StockServer::clear_has_queryoneentrust_ack() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void StockServer::clear_queryoneentrust_ack() {
  if (queryoneentrust_ack_ != NULL) queryoneentrust_ack_->::INF_QueryOneEntrust_Ack::Clear();
  clear_has_queryoneentrust_ack();
}
inline const ::INF_QueryOneEntrust_Ack& StockServer::queryoneentrust_ack() const {
  return queryoneentrust_ack_ != NULL ? *queryoneentrust_ack_ : *default_instance_->queryoneentrust_ack_;
}
inline ::INF_QueryOneEntrust_Ack* StockServer::mutable_queryoneentrust_ack() {
  set_has_queryoneentrust_ack();
  if (queryoneentrust_ack_ == NULL) queryoneentrust_ack_ = new ::INF_QueryOneEntrust_Ack;
  return queryoneentrust_ack_;
}
inline ::INF_QueryOneEntrust_Ack* StockServer::release_queryoneentrust_ack() {
  clear_has_queryoneentrust_ack();
  ::INF_QueryOneEntrust_Ack* temp = queryoneentrust_ack_;
  queryoneentrust_ack_ = NULL;
  return temp;
}

// optional .INF_QueryCJMX_Ack QueryCJMX_Ack = 23;
inline bool StockServer::has_querycjmx_ack() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void StockServer::set_has_querycjmx_ack() {
  _has_bits_[0] |= 0x01000000u;
}
inline void StockServer::clear_has_querycjmx_ack() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void StockServer::clear_querycjmx_ack() {
  if (querycjmx_ack_ != NULL) querycjmx_ack_->::INF_QueryCJMX_Ack::Clear();
  clear_has_querycjmx_ack();
}
inline const ::INF_QueryCJMX_Ack& StockServer::querycjmx_ack() const {
  return querycjmx_ack_ != NULL ? *querycjmx_ack_ : *default_instance_->querycjmx_ack_;
}
inline ::INF_QueryCJMX_Ack* StockServer::mutable_querycjmx_ack() {
  set_has_querycjmx_ack();
  if (querycjmx_ack_ == NULL) querycjmx_ack_ = new ::INF_QueryCJMX_Ack;
  return querycjmx_ack_;
}
inline ::INF_QueryCJMX_Ack* StockServer::release_querycjmx_ack() {
  clear_has_querycjmx_ack();
  ::INF_QueryCJMX_Ack* temp = querycjmx_ack_;
  querycjmx_ack_ = NULL;
  return temp;
}

// optional .INF_QueryPosition_Ack QueryPosition_Ack = 24;
inline bool StockServer::has_queryposition_ack() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void StockServer::set_has_queryposition_ack() {
  _has_bits_[0] |= 0x02000000u;
}
inline void StockServer::clear_has_queryposition_ack() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void StockServer::clear_queryposition_ack() {
  if (queryposition_ack_ != NULL) queryposition_ack_->::INF_QueryPosition_Ack::Clear();
  clear_has_queryposition_ack();
}
inline const ::INF_QueryPosition_Ack& StockServer::queryposition_ack() const {
  return queryposition_ack_ != NULL ? *queryposition_ack_ : *default_instance_->queryposition_ack_;
}
inline ::INF_QueryPosition_Ack* StockServer::mutable_queryposition_ack() {
  set_has_queryposition_ack();
  if (queryposition_ack_ == NULL) queryposition_ack_ = new ::INF_QueryPosition_Ack;
  return queryposition_ack_;
}
inline ::INF_QueryPosition_Ack* StockServer::release_queryposition_ack() {
  clear_has_queryposition_ack();
  ::INF_QueryPosition_Ack* temp = queryposition_ack_;
  queryposition_ack_ = NULL;
  return temp;
}

// optional .INF_QueryETFbaseInfo_Ack QueryETFbaseInfo_Ack = 25;
inline bool StockServer::has_queryetfbaseinfo_ack() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void StockServer::set_has_queryetfbaseinfo_ack() {
  _has_bits_[0] |= 0x04000000u;
}
inline void StockServer::clear_has_queryetfbaseinfo_ack() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void StockServer::clear_queryetfbaseinfo_ack() {
  if (queryetfbaseinfo_ack_ != NULL) queryetfbaseinfo_ack_->::INF_QueryETFbaseInfo_Ack::Clear();
  clear_has_queryetfbaseinfo_ack();
}
inline const ::INF_QueryETFbaseInfo_Ack& StockServer::queryetfbaseinfo_ack() const {
  return queryetfbaseinfo_ack_ != NULL ? *queryetfbaseinfo_ack_ : *default_instance_->queryetfbaseinfo_ack_;
}
inline ::INF_QueryETFbaseInfo_Ack* StockServer::mutable_queryetfbaseinfo_ack() {
  set_has_queryetfbaseinfo_ack();
  if (queryetfbaseinfo_ack_ == NULL) queryetfbaseinfo_ack_ = new ::INF_QueryETFbaseInfo_Ack;
  return queryetfbaseinfo_ack_;
}
inline ::INF_QueryETFbaseInfo_Ack* StockServer::release_queryetfbaseinfo_ack() {
  clear_has_queryetfbaseinfo_ack();
  ::INF_QueryETFbaseInfo_Ack* temp = queryetfbaseinfo_ack_;
  queryetfbaseinfo_ack_ = NULL;
  return temp;
}

// optional .INF_QueryETFlistInfo_Ack QueryETFlistInfo_Ack = 26;
inline bool StockServer::has_queryetflistinfo_ack() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void StockServer::set_has_queryetflistinfo_ack() {
  _has_bits_[0] |= 0x08000000u;
}
inline void StockServer::clear_has_queryetflistinfo_ack() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void StockServer::clear_queryetflistinfo_ack() {
  if (queryetflistinfo_ack_ != NULL) queryetflistinfo_ack_->::INF_QueryETFlistInfo_Ack::Clear();
  clear_has_queryetflistinfo_ack();
}
inline const ::INF_QueryETFlistInfo_Ack& StockServer::queryetflistinfo_ack() const {
  return queryetflistinfo_ack_ != NULL ? *queryetflistinfo_ack_ : *default_instance_->queryetflistinfo_ack_;
}
inline ::INF_QueryETFlistInfo_Ack* StockServer::mutable_queryetflistinfo_ack() {
  set_has_queryetflistinfo_ack();
  if (queryetflistinfo_ack_ == NULL) queryetflistinfo_ack_ = new ::INF_QueryETFlistInfo_Ack;
  return queryetflistinfo_ack_;
}
inline ::INF_QueryETFlistInfo_Ack* StockServer::release_queryetflistinfo_ack() {
  clear_has_queryetflistinfo_ack();
  ::INF_QueryETFlistInfo_Ack* temp = queryetflistinfo_ack_;
  queryetflistinfo_ack_ = NULL;
  return temp;
}

// optional .INF_QueryETFdynamicInfo_Ack QueryETFdynamicInfo_Ack = 27;
inline bool StockServer::has_queryetfdynamicinfo_ack() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void StockServer::set_has_queryetfdynamicinfo_ack() {
  _has_bits_[0] |= 0x10000000u;
}
inline void StockServer::clear_has_queryetfdynamicinfo_ack() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void StockServer::clear_queryetfdynamicinfo_ack() {
  if (queryetfdynamicinfo_ack_ != NULL) queryetfdynamicinfo_ack_->::INF_QueryETFdynamicInfo_Ack::Clear();
  clear_has_queryetfdynamicinfo_ack();
}
inline const ::INF_QueryETFdynamicInfo_Ack& StockServer::queryetfdynamicinfo_ack() const {
  return queryetfdynamicinfo_ack_ != NULL ? *queryetfdynamicinfo_ack_ : *default_instance_->queryetfdynamicinfo_ack_;
}
inline ::INF_QueryETFdynamicInfo_Ack* StockServer::mutable_queryetfdynamicinfo_ack() {
  set_has_queryetfdynamicinfo_ack();
  if (queryetfdynamicinfo_ack_ == NULL) queryetfdynamicinfo_ack_ = new ::INF_QueryETFdynamicInfo_Ack;
  return queryetfdynamicinfo_ack_;
}
inline ::INF_QueryETFdynamicInfo_Ack* StockServer::release_queryetfdynamicinfo_ack() {
  clear_has_queryetfdynamicinfo_ack();
  ::INF_QueryETFdynamicInfo_Ack* temp = queryetfdynamicinfo_ack_;
  queryetfdynamicinfo_ack_ = NULL;
  return temp;
}

// optional .INF_QueryFundCondition_Ack QueryFundCondition_Ack = 28;
inline bool StockServer::has_queryfundcondition_ack() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void StockServer::set_has_queryfundcondition_ack() {
  _has_bits_[0] |= 0x20000000u;
}
inline void StockServer::clear_has_queryfundcondition_ack() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void StockServer::clear_queryfundcondition_ack() {
  if (queryfundcondition_ack_ != NULL) queryfundcondition_ack_->::INF_QueryFundCondition_Ack::Clear();
  clear_has_queryfundcondition_ack();
}
inline const ::INF_QueryFundCondition_Ack& StockServer::queryfundcondition_ack() const {
  return queryfundcondition_ack_ != NULL ? *queryfundcondition_ack_ : *default_instance_->queryfundcondition_ack_;
}
inline ::INF_QueryFundCondition_Ack* StockServer::mutable_queryfundcondition_ack() {
  set_has_queryfundcondition_ack();
  if (queryfundcondition_ack_ == NULL) queryfundcondition_ack_ = new ::INF_QueryFundCondition_Ack;
  return queryfundcondition_ack_;
}
inline ::INF_QueryFundCondition_Ack* StockServer::release_queryfundcondition_ack() {
  clear_has_queryfundcondition_ack();
  ::INF_QueryFundCondition_Ack* temp = queryfundcondition_ack_;
  queryfundcondition_ack_ = NULL;
  return temp;
}

// optional .INF_ETFPurRedem_Ack ETFPurRedem_Ack = 29;
inline bool StockServer::has_etfpurredem_ack() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void StockServer::set_has_etfpurredem_ack() {
  _has_bits_[0] |= 0x40000000u;
}
inline void StockServer::clear_has_etfpurredem_ack() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void StockServer::clear_etfpurredem_ack() {
  if (etfpurredem_ack_ != NULL) etfpurredem_ack_->::INF_ETFPurRedem_Ack::Clear();
  clear_has_etfpurredem_ack();
}
inline const ::INF_ETFPurRedem_Ack& StockServer::etfpurredem_ack() const {
  return etfpurredem_ack_ != NULL ? *etfpurredem_ack_ : *default_instance_->etfpurredem_ack_;
}
inline ::INF_ETFPurRedem_Ack* StockServer::mutable_etfpurredem_ack() {
  set_has_etfpurredem_ack();
  if (etfpurredem_ack_ == NULL) etfpurredem_ack_ = new ::INF_ETFPurRedem_Ack;
  return etfpurredem_ack_;
}
inline ::INF_ETFPurRedem_Ack* StockServer::release_etfpurredem_ack() {
  clear_has_etfpurredem_ack();
  ::INF_ETFPurRedem_Ack* temp = etfpurredem_ack_;
  etfpurredem_ack_ = NULL;
  return temp;
}

// optional .INF_QueryBatchEntrust_Ack QueryBatchEntrust_Ack = 30;
inline bool StockServer::has_querybatchentrust_ack() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void StockServer::set_has_querybatchentrust_ack() {
  _has_bits_[0] |= 0x80000000u;
}
inline void StockServer::clear_has_querybatchentrust_ack() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void StockServer::clear_querybatchentrust_ack() {
  if (querybatchentrust_ack_ != NULL) querybatchentrust_ack_->::INF_QueryBatchEntrust_Ack::Clear();
  clear_has_querybatchentrust_ack();
}
inline const ::INF_QueryBatchEntrust_Ack& StockServer::querybatchentrust_ack() const {
  return querybatchentrust_ack_ != NULL ? *querybatchentrust_ack_ : *default_instance_->querybatchentrust_ack_;
}
inline ::INF_QueryBatchEntrust_Ack* StockServer::mutable_querybatchentrust_ack() {
  set_has_querybatchentrust_ack();
  if (querybatchentrust_ack_ == NULL) querybatchentrust_ack_ = new ::INF_QueryBatchEntrust_Ack;
  return querybatchentrust_ack_;
}
inline ::INF_QueryBatchEntrust_Ack* StockServer::release_querybatchentrust_ack() {
  clear_has_querybatchentrust_ack();
  ::INF_QueryBatchEntrust_Ack* temp = querybatchentrust_ack_;
  querybatchentrust_ack_ = NULL;
  return temp;
}

// optional .INF_BatchEntrust_Ack BatchEntrust_Ack = 31;
inline bool StockServer::has_batchentrust_ack() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void StockServer::set_has_batchentrust_ack() {
  _has_bits_[1] |= 0x00000001u;
}
inline void StockServer::clear_has_batchentrust_ack() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void StockServer::clear_batchentrust_ack() {
  if (batchentrust_ack_ != NULL) batchentrust_ack_->::INF_BatchEntrust_Ack::Clear();
  clear_has_batchentrust_ack();
}
inline const ::INF_BatchEntrust_Ack& StockServer::batchentrust_ack() const {
  return batchentrust_ack_ != NULL ? *batchentrust_ack_ : *default_instance_->batchentrust_ack_;
}
inline ::INF_BatchEntrust_Ack* StockServer::mutable_batchentrust_ack() {
  set_has_batchentrust_ack();
  if (batchentrust_ack_ == NULL) batchentrust_ack_ = new ::INF_BatchEntrust_Ack;
  return batchentrust_ack_;
}
inline ::INF_BatchEntrust_Ack* StockServer::release_batchentrust_ack() {
  clear_has_batchentrust_ack();
  ::INF_BatchEntrust_Ack* temp = batchentrust_ack_;
  batchentrust_ack_ = NULL;
  return temp;
}

// optional .INF_BatchCancel_Ack BatchCancel_Ack = 32;
inline bool StockServer::has_batchcancel_ack() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void StockServer::set_has_batchcancel_ack() {
  _has_bits_[1] |= 0x00000002u;
}
inline void StockServer::clear_has_batchcancel_ack() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void StockServer::clear_batchcancel_ack() {
  if (batchcancel_ack_ != NULL) batchcancel_ack_->::INF_BatchCancel_Ack::Clear();
  clear_has_batchcancel_ack();
}
inline const ::INF_BatchCancel_Ack& StockServer::batchcancel_ack() const {
  return batchcancel_ack_ != NULL ? *batchcancel_ack_ : *default_instance_->batchcancel_ack_;
}
inline ::INF_BatchCancel_Ack* StockServer::mutable_batchcancel_ack() {
  set_has_batchcancel_ack();
  if (batchcancel_ack_ == NULL) batchcancel_ack_ = new ::INF_BatchCancel_Ack;
  return batchcancel_ack_;
}
inline ::INF_BatchCancel_Ack* StockServer::release_batchcancel_ack() {
  clear_has_batchcancel_ack();
  ::INF_BatchCancel_Ack* temp = batchcancel_ack_;
  batchcancel_ack_ = NULL;
  return temp;
}

// optional .INF_Account Account = 34;
inline bool StockServer::has_account() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void StockServer::set_has_account() {
  _has_bits_[1] |= 0x00000004u;
}
inline void StockServer::clear_has_account() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void StockServer::clear_account() {
  if (account_ != NULL) account_->::INF_Account::Clear();
  clear_has_account();
}
inline const ::INF_Account& StockServer::account() const {
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::INF_Account* StockServer::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::INF_Account;
  return account_;
}
inline ::INF_Account* StockServer::release_account() {
  clear_has_account();
  ::INF_Account* temp = account_;
  account_ = NULL;
  return temp;
}

// optional .INF_ETF_Message ETF_Message = 35;
inline bool StockServer::has_etf_message() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void StockServer::set_has_etf_message() {
  _has_bits_[1] |= 0x00000008u;
}
inline void StockServer::clear_has_etf_message() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void StockServer::clear_etf_message() {
  if (etf_message_ != NULL) etf_message_->::INF_ETF_Message::Clear();
  clear_has_etf_message();
}
inline const ::INF_ETF_Message& StockServer::etf_message() const {
  return etf_message_ != NULL ? *etf_message_ : *default_instance_->etf_message_;
}
inline ::INF_ETF_Message* StockServer::mutable_etf_message() {
  set_has_etf_message();
  if (etf_message_ == NULL) etf_message_ = new ::INF_ETF_Message;
  return etf_message_;
}
inline ::INF_ETF_Message* StockServer::release_etf_message() {
  clear_has_etf_message();
  ::INF_ETF_Message* temp = etf_message_;
  etf_message_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CQconnection_2eprotoc__INCLUDED
